import { MAU, CopyActions, BigSegmentTargetChanges, FeatureFlagCopyObject, Statement, Role, SemanticPatchInstruction, ClientSideAvailability, Defaults, Variation, PatchOperation, Policy, Api, Links, RelayProxyConfigs, RelayProxyConfig, AuditLogEntries, AuditLogEntry, Destinations, Destination, FeatureFlagStatusAcrossEnvironments, UsageError, FeatureFlagStatuses, FeatureFlagStatus, FeatureFlags, FeatureFlag, DependentFlagsByEnvironment, MultiEnvironmentDependentFlags, UserTargetingExpirationForFlags, Integrations, Integration, IntegrationSubscription, Members, Member, Projects, Project, Environment, EnvironmentPost, ApprovalRequests, ApprovalRequest, FeatureFlagScheduledChanges, FeatureFlagScheduledChange, FeatureFlagScheduledChangesConflicts, CustomRoles, CustomRole, UserSegments, UserSegment, UserTargetingExpirationForSegment, Tokens, Token, Usage, StreamSDKVersion, Events, MAUbyCategory, Streams, Stream, StreamBySDK, Users, UserRecord, UserFlagSettings, UserFlagSetting, UserTargetingExpirationOnFlagsForUser, Webhooks, Webhook } from './api';
import * as hasuraSdk from "@hasura/ndc-lambda-sdk"

const api = new Api({
  baseUrl: '',
});

/**
 * undefined
 * @request GET :/
 * @readonly
 */
export async function getGetRoot(): Promise<Links> {
  const result = await api.getRoot({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of relay proxy configurations in the account.
 * @request GET :/account/relay-auto-configs
 * @readonly
 * @allowrelaxedtypes
 */
export async function getAccountGetRelayProxyConfigs(): Promise<RelayProxyConfigs> {
  const result = await api.account.getRelayProxyConfigs({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new relay proxy config.
 * @request POST :/account/relay-auto-configs
 * @allowrelaxedtypes
 */
export async function postAccountPostRelayAutoConfig(
  /** Request body */
  relayProxyConfigBody: {
  /**
   * A human-friendly name for the relay proxy configuration
   * @example "My relay proxy config"
   */
    name?: string,
    policy?: Policy[],

},      
): Promise<RelayProxyConfig> {
  const result = await api.account.postRelayAutoConfig({
    relayProxyConfigBody: relayProxyConfigBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a relay proxy configuration by ID.
 * @request DELETE :/account/relay-auto-configs/{id}
 * @allowrelaxedtypes
 */
export async function deleteAccountDeleteRelayProxyConfig(
  /** The relay proxy configuration ID */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.account.deleteRelayProxyConfig({
    id: id,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single relay proxy configuration by ID.
 * @request GET :/account/relay-auto-configs/{id}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getAccountGetRelayProxyConfig(
  /** The relay proxy configuration ID */
  id: string,      
): Promise<RelayProxyConfig> {
  const result = await api.account.getRelayProxyConfig({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify a relay proxy configuration by ID.
 * @request PATCH :/account/relay-auto-configs/{id}
 * @allowrelaxedtypes
 */
export async function patchAccountPatchRelayProxyConfig(
  /** The relay proxy configuration ID */
  id: string,      
  /** Request body */
  patchDelta: PatchOperation[],      
): Promise<RelayProxyConfig> {
  const result = await api.account.patchRelayProxyConfig({
    id: id,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset a relay proxy configuration's secret key with an optional expiry time for the old key.
 * @request POST :/account/relay-auto-configs/{id}/reset
 * @allowrelaxedtypes
 */
export async function postAccountResetRelayProxyConfig(
  /** The relay proxy configuration ID */
  id: string,      
  /** An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately */
  expiry?: number,      
): Promise<RelayProxyConfig> {
  const result = await api.account.resetRelayProxyConfig({
    query: {
      expiry: expiry,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
 * @request GET :/auditlog
 * @readonly
 * @allowrelaxedtypes
 */
export async function getAuditlogGetAuditLogEntries(
  /** A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp. */
  before?: number,      
  /** A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp. */
  after?: number,      
  /** Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change. */
  q?: string,      
  /** A limit on the number of audit log entries to be returned, between 1 and 20. */
  limit?: number,      
  /** A resource specifier, allowing you to filter audit log listings by resource. */
  spec?: string,      
): Promise<AuditLogEntries> {
  const result = await api.auditlog.getAuditLogEntries({
    query: {
      before: before,
      after: after,
      q: q,
      limit: limit,
      spec: spec,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Use this endpoint to fetch a single audit log entry by its resouce ID.
 * @request GET :/auditlog/{resourceId}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getAuditlogGetAuditLogEntry(
  /** The resource ID. */
  resourceId: string,      
): Promise<AuditLogEntry> {
  const result = await api.auditlog.getAuditLogEntry({
    resourceId: resourceId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of all data export destinations.
 * @request GET :/destinations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getDestinationsGetDestinations(): Promise<Destinations> {
  const result = await api.destinations.getDestinations({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new data export destination
 * @request POST :/destinations/{projectKey}/{environmentKey}
 * @allowrelaxedtypes
 */
export async function postDestinationsPostDestination(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Request body */
  destinationBody: {
  /**
   * destination-specific configuration.
   * @example {"project":"cool-project","topic":"test"}
   */
    config: object,
  /**
   * The data export destination type. Available choices are kinesis, google-pubsub, mparticle, or segment.
   * @example "google-pubsub"
   */
    kind: "google-pubsub" | "kinesis" | "mparticle" | "segment",
  /**
   * A human-readable name for your data export destination.
   * @example "Example Google Pub/Sub Destination"
   */
    name: string,
  /**
   * Whether the data export destination is on or not.
   * @example true
   */
    on?: boolean,

},      
): Promise<Destination> {
  const result = await api.destinations.postDestination({
    projectKey: projectKey,
    environmentKey: environmentKey,
    destinationBody: destinationBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single data export destination by ID
 * @request DELETE :/destinations/{projectKey}/{environmentKey}/{destinationId}
 * @allowrelaxedtypes
 */
export async function deleteDestinationsDeleteDestination(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The data export destination ID. */
  destinationId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.destinations.deleteDestination({
    projectKey: projectKey,
    environmentKey: environmentKey,
    destinationId: destinationId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single data export destination by ID
 * @request GET :/destinations/{projectKey}/{environmentKey}/{destinationId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getDestinationsGetDestination(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The data export destination ID. */
  destinationId: string,      
): Promise<Destination> {
  const result = await api.destinations.getDestination({
    projectKey: projectKey,
    environmentKey: environmentKey,
    destinationId: destinationId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Perform a partial update to a data export destination.
 * @request PATCH :/destinations/{projectKey}/{environmentKey}/{destinationId}
 * @allowrelaxedtypes
 */
export async function patchDestinationsPatchDestination(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The data export destination ID. */
  destinationId: string,      
  /** Request body */
  PatchOnly: (PatchOperation)[],      
): Promise<Destination> {
  const result = await api.destinations.patchDestination({
    projectKey: projectKey,
    environmentKey: environmentKey,
    destinationId: destinationId,
    PatchOnly: PatchOnly,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the status for a particular feature flag across environments
 * @request GET :/flag-status/{projectKey}/{featureFlagKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getFlagStatusGetFeatureFlagStatusAcrossEnvironments(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<FeatureFlagStatusAcrossEnvironments> {
  const result = await api.flagStatus.getFeatureFlagStatusAcrossEnvironments({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
 * @request GET :/flag-statuses/{projectKey}/{environmentKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getFlagStatusesGetFeatureFlagStatuses(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
): Promise<FeatureFlagStatuses> {
  const result = await api.flagStatuses.getFeatureFlagStatuses({
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the status for a particular feature flag.
 * @request GET :/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getFlagStatusesGetFeatureFlagStatus(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<FeatureFlagStatus> {
  const result = await api.flagStatuses.getFeatureFlagStatus({
    projectKey: projectKey,
    environmentKey: environmentKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of all features in the given project.
 * @request GET :/flags/{projectKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getFlagsGetFeatureFlags(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env=["production"] will restrict the returned configurations to just your production environment. */
  env?: string[],      
  /** By default in api version >= 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary=0 to include these fields for each flag returned. */
  summary?: boolean,      
  /** When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. */
  archived?: boolean,      
  /** The number of objects to return. Defaults to -1, which returns everything. */
  limit?: number,      
  /** Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. */
  offset?: number,      
  /** A comma-separated list of filters. Each filter is of the form field:value. */
  filter?: string,      
  /** A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. */
  sort?: string,      
  /** Filter by tag. A tag can be used to group flags across projects. */
  tag?: string,      
): Promise<FeatureFlags> {
  const result = await api.flags.getFeatureFlags({
    query: {
      env: env,
      summary: summary,
      archived: archived,
      limit: limit,
      offset: offset,
      filter: filter,
      sort: sort,
      tag: tag,
    },
    projectKey: projectKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Creates a new feature flag.
 * @request POST :/flags/{projectKey}
 * @allowrelaxedtypes
 */
export async function postFlagsPostFeatureFlag(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** Request body */
  featureFlagBody: {
    clientSideAvailability?: ClientSideAvailability,
  /** Default values to be used when a new environment is created. */
    defaults?: Defaults,
  /**
   * A description of the feature flag.
   * @example "This flag controls whether test feature is turned on or not."
   */
    description?: string,
  /** Whether or not this flag should be made available to the client-side JavaScript SDK. */
    includeInSnippet?: boolean,
  /**
   * A unique key that will be used to reference the flag in your code.
   * @example "new-test-flag"
   */
    key: string,
  /**
   * A human-friendly name for the feature flag. Remember to note if this flag is intended to be temporary or permanent.
   * @example "new test flag"
   */
    name: string,
  /** Tags for the feature flag. */
    tags?: (string)[],
  /** Whether or not the flag is a temporary flag. */
    temporary?: boolean,
  /** An array of possible variations for the flag. */
    variations: (Variation)[],

},      
  /** The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone=flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. */
  clone?: string,      
): Promise<FeatureFlag> {
  const result = await api.flags.postFeatureFlag({
    query: {
      clone: clone,
    },
    projectKey: projectKey,
    featureFlagBody: featureFlagBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get dependent flags for the flag in the environment specified in path parameters
 * @request GET :/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags
 * @readonly
 */
export async function getFlagsDependentFlagsDetail(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<DependentFlagsByEnvironment> {
  const result = await api.flags.dependentFlagsDetail({
    projectKey: projectKey,
    environmentKey: environmentKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
 * @request DELETE :/flags/{projectKey}/{featureFlagKey}
 * @allowrelaxedtypes
 */
export async function deleteFlagsDeleteFeatureFlag(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.flags.deleteFeatureFlag({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single feature flag by key.
 * @request GET :/flags/{projectKey}/{featureFlagKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getFlagsGetFeatureFlag(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env=["production"] will restrict the returned configurations to just your production environment. */
  env?: string[],      
): Promise<FeatureFlag> {
  const result = await api.flags.getFeatureFlag({
    query: {
      env: env,
    },
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Perform a partial update to a feature.
 * @request PATCH :/flags/{projectKey}/{featureFlagKey}
 * @allowrelaxedtypes
 */
export async function patchFlagsPatchFeatureFlag(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** Request body */
  patchComment: {
  /** @example "This is a comment string" */
    comment?: string,
    patch?: (PatchOperation)[],

},      
): Promise<FeatureFlag> {
  const result = await api.flags.patchFeatureFlag({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    patchComment: patchComment,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Copies the feature flag configuration from one environment to the same feature flag in another environment.
 * @request POST :/flags/{projectKey}/{featureFlagKey}/copy
 * @allowrelaxedtypes
 */
export async function postFlagsCopyFeatureFlag(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** Request body */
  featureFlagCopyBody: {
  /**
   * comment will be included in audit log item for change.
   * @example "This is a comment string"
   */
    comment?: string,
  /** Define the parts of the flag configuration that will not be copied. */
    excludedActions?: (CopyActions)[],
  /** Define the parts of the flag configuration that will be copied. */
    includedActions?: (CopyActions)[],
    source?: FeatureFlagCopyObject,
    target?: FeatureFlagCopyObject,

},      
): Promise<FeatureFlag> {
  const result = await api.flags.copyFeatureFlag({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    featureFlagCopyBody: featureFlagCopyBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get dependent flags across all environments for the flag specified in the path parameters
 * @request GET :/flags/{projectKey}/{featureFlagKey}/dependent-flags
 * @readonly
 */
export async function getFlagsDependentFlagsDetail2(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<MultiEnvironmentDependentFlags> {
  const result = await api.flags.dependentFlagsDetail2({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get expiring user targets for feature flag
 * @request GET :/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}
 * @readonly
 */
export async function getFlagsGetExpiringUserTargets(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<UserTargetingExpirationForFlags> {
  const result = await api.flags.getExpiringUserTargets({
    projectKey: projectKey,
    environmentKey: environmentKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update, add, or delete expiring user targets on feature flag
 * @request PATCH :/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}
 * @allowrelaxedtypes
 */
export async function patchFlagsPatchExpiringUserTargets(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** Request body */
  SemanticPatchWithComment: object,      
): Promise<UserTargetingExpirationForFlags> {
  const result = await api.flags.patchExpiringUserTargets({
    projectKey: projectKey,
    environmentKey: environmentKey,
    featureFlagKey: featureFlagKey,
    SemanticPatchWithComment: SemanticPatchWithComment,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of all configured audit log event integrations associated with this account.
 * @request GET :/integrations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getIntegrationsGetIntegrations(): Promise<Integrations> {
  const result = await api.integrations.getIntegrations({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of all configured integrations of a given kind.
 * @request GET :/integrations/{integrationKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getIntegrationsGetIntegrationSubscriptions(
  /** The key used to specify the integration kind. */
  integrationKey: string,      
): Promise<Integration> {
  const result = await api.integrations.getIntegrationSubscriptions({
    integrationKey: integrationKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new integration subscription of a given kind.
 * @request POST :/integrations/{integrationKey}
 * @allowrelaxedtypes
 */
export async function postIntegrationsPostIntegrationSubscription(
  /** The key used to specify the integration kind. */
  integrationKey: string,      
  /** Request body */
  subscriptionBody: {
  /**
   * Integration-specific configuration fields.
   * @example {"apiKey":"582**************************116","hostURL":"https://api.datadoghq.com"}
   */
    config: object,
  /**
   * A human-readable name for your subscription configuration.
   * @example "Example Datadog Integration"
   */
    name: string,
  /**
   * Whether the integration subscription is active or not.
   * @example true
   */
    on?: boolean,
    statements?: (Statement)[],
  /**
   * Tags for the integration subscription.
   * @example []
   */
    tags?: (string)[],

},      
): Promise<IntegrationSubscription> {
  const result = await api.integrations.postIntegrationSubscription({
    integrationKey: integrationKey,
    subscriptionBody: subscriptionBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an integration subscription by ID.
 * @request DELETE :/integrations/{integrationKey}/{integrationId}
 * @allowrelaxedtypes
 */
export async function deleteIntegrationsDeleteIntegrationSubscription(
  /** The key used to specify the integration kind. */
  integrationKey: string,      
  /** The integration ID. */
  integrationId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.integrations.deleteIntegrationSubscription({
    integrationKey: integrationKey,
    integrationId: integrationId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single integration subscription by ID.
 * @request GET :/integrations/{integrationKey}/{integrationId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getIntegrationsGetIntegrationSubscription(
  /** The key used to specify the integration kind. */
  integrationKey: string,      
  /** The integration ID. */
  integrationId: string,      
): Promise<IntegrationSubscription> {
  const result = await api.integrations.getIntegrationSubscription({
    integrationKey: integrationKey,
    integrationId: integrationId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify an integration subscription by ID.
 * @request PATCH :/integrations/{integrationKey}/{integrationId}
 * @allowrelaxedtypes
 */
export async function patchIntegrationsPatchIntegrationSubscription(
  /** The key used to specify the integration kind. */
  integrationKey: string,      
  /** The integration ID. */
  integrationId: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<IntegrationSubscription> {
  const result = await api.integrations.patchIntegrationSubscription({
    integrationKey: integrationKey,
    integrationId: integrationId,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of all members in the account.
 * @request GET :/members
 * @readonly
 * @allowrelaxedtypes
 */
export async function getMembersGetMembers(
  /** The number of objects to return. Defaults to -1, which returns everything. */
  limit?: number,      
  /** Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. */
  offset?: number,      
  /** A comma-separated list of filters. Each filter is of the form field:value. */
  filter?: string,      
  /** A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. */
  sort?: string,      
): Promise<Members> {
  const result = await api.members.getMembers({
    query: {
      limit: limit,
      offset: offset,
      filter: filter,
      sort: sort,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Invite new members.
 * @request POST :/members
 * @allowrelaxedtypes
 */
export async function postMembersPostMembers(
  /** Request body */
  membersBody: ({
    customRoles?: (string)[],
  /** @example "exampleuser@email.com" */
    email: string,
  /** @example "Bob" */
    firstName?: string,
    inlineRole?: (Statement)[],
  /** @example "Loblaw" */
    lastName?: string,
    role?: Role,

})[],      
): Promise<Members> {
  const result = await api.members.postMembers({
    membersBody: membersBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the current team member associated with the token
 * @request GET :/members/me
 * @readonly
 * @allowrelaxedtypes
 */
export async function getMembersGetMe(): Promise<Member> {
  const result = await api.members.getMe({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a team member by ID.
 * @request DELETE :/members/{memberId}
 * @allowrelaxedtypes
 */
export async function deleteMembersDeleteMember(
  /** The member ID. */
  memberId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.members.deleteMember({
    memberId: memberId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single team member by ID.
 * @request GET :/members/{memberId}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getMembersGetMember(
  /** The member ID. */
  memberId: string,      
): Promise<Member> {
  const result = await api.members.getMember({
    memberId: memberId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify a team member by ID.
 * @request PATCH :/members/{memberId}
 * @allowrelaxedtypes
 */
export async function patchMembersPatchMember(
  /** The member ID. */
  memberId: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<Member> {
  const result = await api.members.patchMember({
    memberId: memberId,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of all projects in the account.
 * @request GET :/projects
 * @readonly
 * @allowrelaxedtypes
 */
export async function getProjectsGetProjects(): Promise<Projects> {
  const result = await api.projects.getProjects({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new project with the given key and name.
 * @request POST :/projects
 * @allowrelaxedtypes
 */
export async function postProjectsPostProject(
  /** Request body */
  projectBody: {
    defaultClientSideAvailability?: ClientSideAvailability,
  /** @minLength 1 */
    environments?: (EnvironmentPost)[],
  /** @example false */
    includeInSnippetByDefault?: boolean,
  /** @example "new-project" */
    key: string,
  /** @example "New Project" */
    name: string,
  /** @example ["ops","dev"] */
    tags?: (string)[],

},      
): Promise<Project> {
  const result = await api.projects.postProject({
    projectBody: projectBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
 * @request DELETE :/projects/{projectKey}
 * @allowrelaxedtypes
 */
export async function deleteProjectsDeleteProject(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.projects.deleteProject({
    projectKey: projectKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Fetch a single project by key.
 * @request GET :/projects/{projectKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getProjectsGetProject(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
): Promise<Project> {
  const result = await api.projects.getProject({
    projectKey: projectKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify a project by ID.
 * @request PATCH :/projects/{projectKey}
 * @allowrelaxedtypes
 */
export async function patchProjectsPatchProject(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<Project> {
  const result = await api.projects.patchProject({
    projectKey: projectKey,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new environment in a specified project with a given name, key, and swatch color.
 * @request POST :/projects/{projectKey}/environments
 * @allowrelaxedtypes
 */
export async function postProjectsPostEnvironment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** Request body */
  environmentBody: EnvironmentPost,      
): Promise<Environment> {
  const result = await api.projects.postEnvironment({
    projectKey: projectKey,
    environmentBody: environmentBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an environment in a specific project.
 * @request DELETE :/projects/{projectKey}/environments/{environmentKey}
 * @allowrelaxedtypes
 */
export async function deleteProjectsDeleteEnvironment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.projects.deleteEnvironment({
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get an environment given a project and key.
 * @request GET :/projects/{projectKey}/environments/{environmentKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getProjectsGetEnvironment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
): Promise<Environment> {
  const result = await api.projects.getEnvironment({
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify an environment by ID. If you try to patch the environment by setting both required and requiredApprovalTags, it will result in an error. Users can specify either required approvals for all flags in an environment or those with specific tags, but not both. Only customers on an Enterprise plan can require approval for flag updates with either mechanism.
 * @request PATCH :/projects/{projectKey}/environments/{environmentKey}
 * @allowrelaxedtypes
 */
export async function patchProjectsPatchEnvironment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<Environment> {
  const result = await api.projects.patchEnvironment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset an environment's SDK key with an optional expiry time for the old key.
 * @request POST :/projects/{projectKey}/environments/{environmentKey}/apiKey
 * @allowrelaxedtypes
 */
export async function postProjectsResetEnvironmentSdkKey(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately. */
  expiry?: number,      
): Promise<Environment> {
  const result = await api.projects.resetEnvironmentSdkKey({
    query: {
      expiry: expiry,
    },
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset an environment's mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
 * @request POST :/projects/{projectKey}/environments/{environmentKey}/mobileKey
 */
export async function postProjectsResetEnvironmentMobileKey(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version. */
  expiry?: number,      
): Promise<Environment> {
  const result = await api.projects.resetEnvironmentMobileKey({
    query: {
      expiry: expiry,
    },
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all approval requests for a feature flag config
 * @request GET :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests
 * @allowrelaxedtypes
 * @readonly
 */
export async function getProjectsGetApprovalRequests(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
): Promise<ApprovalRequests> {
  const result = await api.projects.getApprovalRequests({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an approval request for a feature flag config
 * @request DELETE :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}
 * @allowrelaxedtypes
 */
export async function deleteProjectsDeleteApprovalRequest(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The approval request ID */
  approvalRequestId: string,      
  /** Request body */
  approvalRequestConfigBody: {
  /** comment will be included in audit log item for change. */
    comment?: string,
  /** A name that describes the changes you would like to apply to a feature flag configuration */
    description: string,
  /**
   * Timestamp for when instructions will be executed
   * @format int64
   */
    executionDate?: number,
    instructions: SemanticPatchInstruction,
  /** @example ["memberId","memberId2"] */
    notifyMemberIds: (string)[],
  /** ID of scheduled change to edit or delete */
    operatingOnId?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.projects.deleteApprovalRequest({
    projectKey: projectKey,
    environmentKey: environmentKey,
    featureFlagKey: featureFlagKey,
    approvalRequestId: approvalRequestId,
    approvalRequestConfigBody: approvalRequestConfigBody,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single approval request for a feature flag config
 * @request GET :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getProjectsGetApprovalRequest(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The approval request ID */
  approvalRequestId: string,      
): Promise<ApprovalRequests> {
  const result = await api.projects.getApprovalRequest({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    approvalRequestId: approvalRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create an approval request for a feature flag config
 * @request POST :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}
 * @allowrelaxedtypes
 */
export async function postProjectsPostApprovalRequest(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The approval request ID */
  approvalRequestId: string,      
  /** Request body */
  approvalRequestConfigBody: {
  /** comment will be included in audit log item for change. */
    comment?: string,
  /** A name that describes the changes you would like to apply to a feature flag configuration */
    description: string,
  /**
   * Timestamp for when instructions will be executed
   * @format int64
   */
    executionDate?: number,
    instructions: SemanticPatchInstruction,
  /** @example ["memberId","memberId2"] */
    notifyMemberIds: (string)[],
  /** ID of scheduled change to edit or delete */
    operatingOnId?: string,

},      
): Promise<ApprovalRequest> {
  const result = await api.projects.postApprovalRequest({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    approvalRequestId: approvalRequestId,
    approvalRequestConfigBody: approvalRequestConfigBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Apply approval request for a feature flag config
 * @request POST :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}/apply
 * @allowrelaxedtypes
 */
export async function postProjectsPostApplyApprovalRequest(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The approval request ID */
  approvalRequestId: string,      
  /** Request body */
  approvalRequestApplyConfigBody: {
  /**
   * comment will be included in audit log item for change.
   * @example "Applying approved changes"
   */
    comment?: string,

},      
): Promise<ApprovalRequests> {
  const result = await api.projects.postApplyApprovalRequest({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    approvalRequestId: approvalRequestId,
    approvalRequestApplyConfigBody: approvalRequestApplyConfigBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Review approval request for a feature flag config
 * @request POST :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}/review
 * @allowrelaxedtypes
 */
export async function postProjectsPostReviewApprovalRequest(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The approval request ID */
  approvalRequestId: string,      
  /** Request body */
  approvalRequestReviewConfigBody: {
  /**
   * comment will be included in audit log item for change.
   * @example "This is a comment string"
   */
    comment?: string,
  /**
   * One of approve, decline, or comment.
   * @example "approve"
   */
    kind: "approve" | "decline" | "comment",

},      
): Promise<ApprovalRequests> {
  const result = await api.projects.postReviewApprovalRequest({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    approvalRequestId: approvalRequestId,
    approvalRequestReviewConfigBody: approvalRequestReviewConfigBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all scheduled workflows for a feature flag by key.
 * @request GET :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes
 * @readonly
 */
export async function getProjectsGetFlagConfigScheduledChanges(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
): Promise<FeatureFlagScheduledChanges> {
  const result = await api.projects.getFlagConfigScheduledChanges({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Creates a new scheduled change for a feature flag.
 * @request POST :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes
 */
export async function postProjectsPostFlagConfigScheduledChanges(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Request body */
  flagConfigScheduledChangesPostBody: {
  /** Used to describe the scheduled changes. */
    comment?: string,
  /** A unix epoch time in milliseconds specifying the date the scheduled changes will be applied */
    executionDate?: number,
    instructions?: SemanticPatchInstruction,

},      
): Promise<FeatureFlagScheduledChange> {
  const result = await api.projects.postFlagConfigScheduledChanges({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    flagConfigScheduledChangesPostBody: flagConfigScheduledChangesPostBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Lists conflicts between the given instructions and any existing scheduled changes for the feature flag. The actual HTTP verb should be REPORT, not POST.
 * @request POST :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes-conflicts
 */
export async function postProjectsGetFlagConfigScheduledChangesConflicts(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Request body */
  flagConfigScheduledChangesConflictsBody: {
  /** A unix epoch time in milliseconds specifying the date the scheduled changes will be applied */
    executionDate?: number,
    instructions?: SemanticPatchInstruction,

},      
): Promise<FeatureFlagScheduledChangesConflicts> {
  const result = await api.projects.getFlagConfigScheduledChangesConflicts({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    flagConfigScheduledChangesConflictsBody: flagConfigScheduledChangesConflictsBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a scheduled change on a feature flag in an environment.
 * @request DELETE :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}
 * @allowrelaxedtypes
 */
export async function deleteProjectsDeleteFlagConfigScheduledChanges(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The id of the scheduled change */
  scheduledChangeId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.projects.deleteFlagConfigScheduledChanges({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    scheduledChangeId: scheduledChangeId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a scheduled change on a feature flag by id.
 * @request GET :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}
 * @readonly
 */
export async function getProjectsGetFlagConfigScheduledChange(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The id of the scheduled change */
  scheduledChangeId: string,      
): Promise<FeatureFlagScheduledChange> {
  const result = await api.projects.getFlagConfigScheduledChange({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    scheduledChangeId: scheduledChangeId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Updates an existing scheduled-change on a feature flag in an environment.
 * @request PATCH :/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}
 */
export async function patchProjectsPatchFlagConfigScheduledChange(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The id of the scheduled change */
  scheduledChangeId: string,      
  /** Request body */
  flagConfigScheduledChangesPatchBody: {
  /** Used to describe the scheduled changes. */
    comment?: string,
    instructions?: SemanticPatchInstruction,

},      
): Promise<FeatureFlagScheduledChange> {
  const result = await api.projects.patchFlagConfigScheduledChange({
    projectKey: projectKey,
    featureFlagKey: featureFlagKey,
    environmentKey: environmentKey,
    scheduledChangeId: scheduledChangeId,
    flagConfigScheduledChangesPatchBody: flagConfigScheduledChangesPatchBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Return a complete list of custom roles.
 * @request GET :/roles
 * @readonly
 */
export async function getRolesGetCustomRoles(): Promise<CustomRoles> {
  const result = await api.roles.getCustomRoles({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new custom role.
 * @request POST :/roles
 */
export async function postRolesPostCustomRole(
  /** Request body */
  customRoleBody: {
  /**
   * Description of the custom role.
   * @example "Description of revenue team role here"
   */
    description?: string,
  /**
   * The 20-hexdigit id or the key for a custom role.
   * @example "revenue-team"
   */
    key: string,
  /**
   * Name of the custom role.
   * @example "revenue team"
   */
    name: string,
    policy: (Policy)[],

},      
): Promise<CustomRole> {
  const result = await api.roles.postCustomRole({
    customRoleBody: customRoleBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a custom role by key.
 * @request DELETE :/roles/{customRoleKey}
 * @allowrelaxedtypes
 */
export async function deleteRolesDeleteCustomRole(
  /** The custom role key. */
  customRoleKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.roles.deleteCustomRole({
    customRoleKey: customRoleKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get one custom role by key.
 * @request GET :/roles/{customRoleKey}
 * @readonly
 */
export async function getRolesGetCustomRole(
  /** The custom role key. */
  customRoleKey: string,      
): Promise<CustomRole> {
  const result = await api.roles.getCustomRole({
    customRoleKey: customRoleKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify a custom role by key.
 * @request PATCH :/roles/{customRoleKey}
 * @allowrelaxedtypes
 */
export async function patchRolesPatchCustomRole(
  /** The custom role key. */
  customRoleKey: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<CustomRole> {
  const result = await api.roles.patchCustomRole({
    customRoleKey: customRoleKey,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of all user segments in the given project.
 * @request GET :/segments/{projectKey}/{environmentKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getSegmentsGetUserSegments(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Filter by tag. A tag can be used to group flags across projects. */
  tag?: string,      
): Promise<UserSegments> {
  const result = await api.segments.getUserSegments({
    query: {
      tag: tag,
    },
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Creates a new user segment.
 * @request POST :/segments/{projectKey}/{environmentKey}
 * @allowrelaxedtypes
 */
export async function postSegmentsPostUserSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Request body */
  userSegmentBody: {
  /**
   * A description for the user segment.
   * @example "Users in this segment will have access to beta features."
   */
    description?: string,
  /**
   * A unique key that will be used to reference the user segment in feature flags.
   * @example "new-segment"
   */
    key: string,
  /**
   * A human-friendly name for the user segment.
   * @example "new segment"
   */
    name: string,
  /** Tags for the user segment. */
    tags?: (string)[],
  /**
   * Controls whether this is considered a "big segment" which can support an unlimited numbers of users. Include/exclude lists sent with this payload are not used in big segments. Contact your account manager for early access to this feature.
   * @example false
   */
    unbounded?: boolean,

},      
): Promise<UserSegment> {
  const result = await api.segments.postUserSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentBody: userSegmentBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a user segment.
 * @request DELETE :/segments/{projectKey}/{environmentKey}/{userSegmentKey}
 * @allowrelaxedtypes
 */
export async function deleteSegmentsDeleteUserSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.segments.deleteUserSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single user segment by key.
 * @request GET :/segments/{projectKey}/{environmentKey}/{userSegmentKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getSegmentsGetUserSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
): Promise<UserSegment> {
  const result = await api.segments.getUserSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Perform a partial update to a user segment.
 * @request PATCH :/segments/{projectKey}/{environmentKey}/{userSegmentKey}
 * @allowrelaxedtypes
 */
export async function patchSegmentsPatchUserSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
  /** Request body */
  PatchOnly: (PatchOperation)[],      
): Promise<UserSegment> {
  const result = await api.segments.patchUserSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
    PatchOnly: PatchOnly,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update targets included or excluded in a big segment
 * @request POST :/segments/{projectKey}/{environmentKey}/{userSegmentKey}/users
 * @allowrelaxedtypes
 */
export async function postSegmentsUpdateBigSegmentTargets(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
  /** Request body */
  bigSegmentTargetsBody: {
    excluded?: BigSegmentTargetChanges,
    included?: BigSegmentTargetChanges,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.segments.updateBigSegmentTargets({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
    bigSegmentTargetsBody: bigSegmentTargetsBody,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get expiring user targets for user segment
 * @request GET :/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}
 * @readonly
 */
export async function getSegmentsGetExpiringUserTargetsOnSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
): Promise<UserTargetingExpirationForSegment> {
  const result = await api.segments.getExpiringUserTargetsOnSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update, add, or delete expiring user targets on user segment
 * @request PATCH :/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}
 * @allowrelaxedtypes
 */
export async function patchSegmentsPatchExpiringUserTargetsOnSegment(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user segment's key. The key identifies the user segment in your code. */
  userSegmentKey: string,      
  /** Request body */
  SemanticPatchWithComment: object,      
): Promise<UserTargetingExpirationForSegment> {
  const result = await api.segments.patchExpiringUserTargetsOnSegment({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userSegmentKey: userSegmentKey,
    SemanticPatchWithComment: SemanticPatchWithComment,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of tokens in the account.
 * @request GET :/tokens
 * @allowrelaxedtypes
 * @readonly
 */
export async function getTokensGetTokens(
  /** If set to true, and the authentication access token has the "Admin" role, personal access tokens for all members will be retrieved. */
  showAll?: boolean,      
): Promise<Tokens> {
  const result = await api.tokens.getTokens({
    query: {
      showAll: showAll,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new token.
 * @request POST :/tokens
 * @allowrelaxedtypes
 */
export async function postTokensPostToken(
  /** Request body */
  tokenBody: {
  /** A list of custom role IDs to use as access limits for the access token */
    customRoleIds?: (string)[],
  /** The default API version for this token */
    defaultApiVersion?: number,
    inlineRole?: (Statement)[],
  /**
   * A human-friendly name for the access token
   * @example "My access token"
   */
    name?: string,
  /**
   * The name of a built-in role for the token
   * @example "writer"
   */
    role?: string,
  /** Whether the token will be a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens */
    serviceToken?: boolean,

},      
): Promise<Token> {
  const result = await api.tokens.postToken({
    tokenBody: tokenBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an access token by ID.
 * @request DELETE :/tokens/{tokenId}
 * @allowrelaxedtypes
 */
export async function deleteTokensDeleteToken(
  /** The access token ID. */
  tokenId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.tokens.deleteToken({
    tokenId: tokenId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a single access token by ID.
 * @request GET :/tokens/{tokenId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getTokensGetToken(
  /** The access token ID. */
  tokenId: string,      
): Promise<Token> {
  const result = await api.tokens.getToken({
    tokenId: tokenId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify an access token by ID.
 * @request PATCH :/tokens/{tokenId}
 * @allowrelaxedtypes
 */
export async function patchTokensPatchToken(
  /** The access token ID. */
  tokenId: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<Token> {
  const result = await api.tokens.patchToken({
    tokenId: tokenId,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset an access token's secret key with an optional expiry time for the old key.
 * @request POST :/tokens/{tokenId}/reset
 * @allowrelaxedtypes
 */
export async function postTokensResetToken(
  /** The access token ID. */
  tokenId: string,      
  /** An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately. */
  expiry?: number,      
): Promise<Token> {
  const result = await api.tokens.resetToken({
    query: {
      expiry: expiry,
    },
    tokenId: tokenId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns of the usage endpoints available.
 * @request GET :/usage
 * @readonly
 */
export async function getUsageGetUsage(): Promise<Usage> {
  const result = await api.usage.getUsage({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get events usage by event id and the feature flag key.
 * @request GET :/usage/evaluations/{envId}/{flagKey}
 * @readonly
 */
export async function getUsageGetEvaluations(
  /** The environment id for the flag evaluations in question. */
  envId: string,      
  /** The key of the flag we want metrics for. */
  flagKey: string,      
): Promise<StreamSDKVersion> {
  const result = await api.usage.getEvaluations({
    envId: envId,
    flagKey: flagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get events usage endpoints.
 * @request GET :/usage/events
 * @readonly
 */
export async function getUsageGetEvents(): Promise<Events> {
  const result = await api.usage.getEvents({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get events usage by event type.
 * @request GET :/usage/events/{type}
 * @readonly
 */
export async function getUsageGetEvent(
  /** The type of event we would like to track. */
  type: string,      
): Promise<StreamSDKVersion> {
  const result = await api.usage.getEvent({
    type: type,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get monthly active user data.
 * @request GET :/usage/mau
 * @readonly
 */
export async function getUsageGetMau(): Promise<MAU> {
  const result = await api.usage.getMau({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get monthly active user data by category.
 * @request GET :/usage/mau/bycategory
 * @readonly
 * @allowrelaxedtypes
 */
export async function getUsageGetMauByCategory(): Promise<MAUbyCategory> {
  const result = await api.usage.getMauByCategory({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Returns a list of all streams.
 * @request GET :/usage/streams
 * @readonly
 */
export async function getUsageGetStreams(): Promise<Streams> {
  const result = await api.usage.getStreams({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a stream endpoint and return timeseries data.
 * @request GET :/usage/streams/{source}
 * @readonly
 */
export async function getUsageGetStream(
  /** The source of where the stream comes from. */
  source: string,      
): Promise<Stream> {
  const result = await api.usage.getStream({
    source: source,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a stream timeseries data by source show sdk version metadata.
 * @request GET :/usage/streams/{source}/bysdkversion
 * @readonly
 */
export async function getUsageGetStreamBySdk(
  /** The source of where the stream comes from. */
  source: string,      
): Promise<StreamBySDK> {
  const result = await api.usage.getStreamBySdk({
    source: source,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a stream timeseries data by source and show all sdk version associated.
 * @request GET :/usage/streams/{source}/sdkversions
 * @readonly
 */
export async function getUsageGetStreamSdkVersion(
  /** The source of where the stream comes from. */
  source: string,      
): Promise<StreamSDKVersion> {
  const result = await api.usage.getStreamSdkVersion({
    source: source,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
 * @request GET :/user-search/{projectKey}/{environmentKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getUserSearchGetSearchUsers(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Search query. */
  q?: string,      
  /** Pagination limit. */
  limit?: number,      
  /** Specifies the first item to return in the collection. */
  offset?: number,      
  /** A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp. */
  after?: number,      
): Promise<Users> {
  const result = await api.userSearch.getSearchUsers({
    query: {
      q: q,
      limit: limit,
      offset: offset,
      after: after,
    },
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * List all users in the environment. Includes the total count of users. In each page, there will be up to 'limit' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
 * @request GET :/users/{projectKey}/{environmentKey}
 * @readonly
 * @allowrelaxedtypes
 */
export async function getUsersGetUsers(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** Pagination limit. */
  limit?: number,      
  /** This parameter is required when following "next" links. */
  h?: string,      
  /** This parameter is required when following "next" links. */
  scrollId?: string,      
): Promise<Users> {
  const result = await api.users.getUsers({
    query: {
      limit: limit,
      h: h,
      scrollId: scrollId,
    },
    projectKey: projectKey,
    environmentKey: environmentKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a user by ID.
 * @request DELETE :/users/{projectKey}/{environmentKey}/{userKey}
 * @allowrelaxedtypes
 */
export async function deleteUsersDeleteUser(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.users.deleteUser({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a user by key.
 * @request GET :/users/{projectKey}/{environmentKey}/{userKey}
 * @readonly
 */
export async function getUsersGetUser(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
): Promise<UserRecord> {
  const result = await api.users.getUser({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Fetch a single flag setting for a user by key.
 * @request GET :/users/{projectKey}/{environmentKey}/{userKey}/flags
 * @readonly
 * @allowrelaxedtypes
 */
export async function getUsersGetUserFlagSettings(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
): Promise<UserFlagSettings> {
  const result = await api.users.getUserFlagSettings({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Fetch a single flag setting for a user by key.
 * @request GET :/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}
 * @readonly
 */
export async function getUsersGetUserFlagSetting(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
): Promise<UserFlagSetting> {
  const result = await api.users.getUserFlagSetting({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
    featureFlagKey: featureFlagKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Specifically enable or disable a feature flag for a user based on their key.
 * @request PUT :/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}
 * @allowrelaxedtypes
 */
export async function putUsersPutFlagSetting(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
  /** The feature flag's key. The key identifies the flag in your code. */
  featureFlagKey: string,      
  /** Request body */
  userSettingsBody: {
  /** The variation value to set for the user. Must match the variation type of the flag. */
    setting?: boolean,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.users.putFlagSetting({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
    featureFlagKey: featureFlagKey,
    userSettingsBody: userSettingsBody,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get expiring dates on flags for user
 * @request GET :/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}
 * @readonly
 */
export async function getUsersGetExpiringUserTargetsForUser(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
): Promise<UserTargetingExpirationOnFlagsForUser> {
  const result = await api.users.getExpiringUserTargetsForUser({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update, add, or delete expiring user targets for a single user on all flags
 * @request PATCH :/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}
 * @allowrelaxedtypes
 */
export async function patchUsersPatchExpiringUserTargetsForFlags(
  /** The project key, used to tie the flags together under one project so they can be managed together. */
  projectKey: string,      
  /** The environment key, used to tie together flag configuration and users under one environment so they can be managed together. */
  environmentKey: string,      
  /** The user's key. */
  userKey: string,      
  /** Request body */
  SemanticPatchWithComment: object,      
): Promise<UserTargetingExpirationOnFlagsForUser> {
  const result = await api.users.patchExpiringUserTargetsForFlags({
    projectKey: projectKey,
    environmentKey: environmentKey,
    userKey: userKey,
    SemanticPatchWithComment: SemanticPatchWithComment,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Fetch a list of all webhooks.
 * @request GET :/webhooks
 * @allowrelaxedtypes
 * @readonly
 */
export async function getWebhooksGetWebhooks(): Promise<Webhooks> {
  const result = await api.webhooks.getWebhooks({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a webhook.
 * @request POST :/webhooks
 * @allowrelaxedtypes
 */
export async function postWebhooksPostWebhook(
  /** Request body */
  webhookBody: {
  /**
   * The name of the webhook.
   * @example "Example hook"
   */
    name?: string,
  /**
   * Whether this webhook is enabled or not.
   * @example true
   */
    on: boolean,
  /**
   * If sign is true, and the secret attribute is omitted, LaunchDarkly will automatically generate a secret for you.
   * @example "<password>"
   */
    secret?: string,
  /** If sign is false, the webhook will not include a signature header, and the secret can be omitted. */
    sign: boolean,
    statements?: (Statement)[],
  /**
   * Tags for the webhook.
   * @example []
   */
    tags?: (string)[],
  /**
   * The URL of the remote webhook.
   * @example "https://example.com/example"
   */
    url: string,

},      
): Promise<Webhook> {
  const result = await api.webhooks.postWebhook({
    webhookBody: webhookBody,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a webhook by ID.
 * @request DELETE :/webhooks/{resourceId}
 * @allowrelaxedtypes
 */
export async function deleteWebhooksDeleteWebhook(
  /** The resource ID. */
  resourceId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.webhooks.deleteWebhook({
    resourceId: resourceId,
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw (result.error)
  }
}

/**
 * Get a webhook by ID.
 * @request GET :/webhooks/{resourceId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getWebhooksGetWebhook(
  /** The resource ID. */
  resourceId: string,      
): Promise<Webhook> {
  const result = await api.webhooks.getWebhook({
    resourceId: resourceId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify a webhook by ID.
 * @request PATCH :/webhooks/{resourceId}
 * @allowrelaxedtypes
 */
export async function patchWebhooksPatchWebhook(
  /** The resource ID. */
  resourceId: string,      
  /** Request body */
  patchDelta: (PatchOperation)[],      
): Promise<Webhook> {
  const result = await api.webhooks.patchWebhook({
    resourceId: resourceId,
    patchDelta: patchDelta,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}
