import * as hasuraSdk from "@hasura/ndc-lambda-sdk";
import {
  AgeRatingDeclarationResponse,
  AgeRatingDeclarationUpdateRequest,
  Api,
  AppBetaTestersLinkagesRequest,
  AppCategoriesResponse,
  AppCategoryResponse,
  AppEncryptionDeclarationBuildsLinkagesRequest,
  AppEncryptionDeclarationResponse,
  AppEncryptionDeclarationsResponse,
  AppInfoLocalizationCreateRequest,
  AppInfoLocalizationResponse,
  AppInfoLocalizationUpdateRequest,
  AppInfoLocalizationsResponse,
  AppInfoResponse,
  AppInfoUpdateRequest,
  AppInfosResponse,
  AppPreOrderCreateRequest,
  AppPreOrderResponse,
  AppPreOrderUpdateRequest,
  AppPreviewCreateRequest,
  AppPreviewResponse,
  AppPreviewSetAppPreviewsLinkagesRequest,
  AppPreviewSetAppPreviewsLinkagesResponse,
  AppPreviewSetCreateRequest,
  AppPreviewSetResponse,
  AppPreviewSetsResponse,
  AppPreviewUpdateRequest,
  AppPreviewsResponse,
  AppPricePointResponse,
  AppPricePointsResponse,
  AppPriceResponse,
  AppPriceTierResponse,
  AppPriceTiersResponse,
  AppPricesResponse,
  AppResponse,
  AppScreenshotCreateRequest,
  AppScreenshotResponse,
  AppScreenshotSetAppScreenshotsLinkagesRequest,
  AppScreenshotSetAppScreenshotsLinkagesResponse,
  AppScreenshotSetCreateRequest,
  AppScreenshotSetResponse,
  AppScreenshotSetsResponse,
  AppScreenshotUpdateRequest,
  AppScreenshotsResponse,
  AppStoreReviewAttachmentCreateRequest,
  AppStoreReviewAttachmentResponse,
  AppStoreReviewAttachmentUpdateRequest,
  AppStoreReviewAttachmentsResponse,
  AppStoreReviewDetailCreateRequest,
  AppStoreReviewDetailResponse,
  AppStoreReviewDetailUpdateRequest,
  AppStoreVersionBuildLinkageRequest,
  AppStoreVersionBuildLinkageResponse,
  AppStoreVersionCreateRequest,
  AppStoreVersionLocalizationCreateRequest,
  AppStoreVersionLocalizationResponse,
  AppStoreVersionLocalizationUpdateRequest,
  AppStoreVersionLocalizationsResponse,
  AppStoreVersionPhasedReleaseCreateRequest,
  AppStoreVersionPhasedReleaseResponse,
  AppStoreVersionPhasedReleaseUpdateRequest,
  AppStoreVersionResponse,
  AppStoreVersionSubmissionCreateRequest,
  AppStoreVersionSubmissionResponse,
  AppStoreVersionUpdateRequest,
  AppStoreVersionsResponse,
  AppUpdateRequest,
  AppsResponse,
  BetaAppLocalizationCreateRequest,
  BetaAppLocalizationResponse,
  BetaAppLocalizationUpdateRequest,
  BetaAppLocalizationsResponse,
  BetaAppReviewDetailResponse,
  BetaAppReviewDetailUpdateRequest,
  BetaAppReviewDetailsResponse,
  BetaAppReviewSubmissionCreateRequest,
  BetaAppReviewSubmissionResponse,
  BetaAppReviewSubmissionsResponse,
  BetaBuildLocalizationCreateRequest,
  BetaBuildLocalizationResponse,
  BetaBuildLocalizationUpdateRequest,
  BetaBuildLocalizationsResponse,
  BetaGroupBetaTestersLinkagesRequest,
  BetaGroupBetaTestersLinkagesResponse,
  BetaGroupBuildsLinkagesRequest,
  BetaGroupBuildsLinkagesResponse,
  BetaGroupCreateRequest,
  BetaGroupResponse,
  BetaGroupUpdateRequest,
  BetaGroupsResponse,
  BetaLicenseAgreementResponse,
  BetaLicenseAgreementUpdateRequest,
  BetaLicenseAgreementsResponse,
  BetaTesterAppsLinkagesRequest,
  BetaTesterAppsLinkagesResponse,
  BetaTesterBetaGroupsLinkagesRequest,
  BetaTesterBetaGroupsLinkagesResponse,
  BetaTesterBuildsLinkagesRequest,
  BetaTesterBuildsLinkagesResponse,
  BetaTesterCreateRequest,
  BetaTesterInvitationCreateRequest,
  BetaTesterInvitationResponse,
  BetaTesterResponse,
  BetaTestersResponse,
  BuildAppEncryptionDeclarationLinkageRequest,
  BuildAppEncryptionDeclarationLinkageResponse,
  BuildBetaDetailResponse,
  BuildBetaDetailUpdateRequest,
  BuildBetaDetailsResponse,
  BuildBetaGroupsLinkagesRequest,
  BuildBetaNotificationCreateRequest,
  BuildBetaNotificationResponse,
  BuildIconsResponse,
  BuildIndividualTestersLinkagesRequest,
  BuildIndividualTestersLinkagesResponse,
  BuildResponse,
  BuildUpdateRequest,
  BuildsResponse,
  BundleIdCapabilitiesResponse,
  BundleIdCapabilityCreateRequest,
  BundleIdCapabilityResponse,
  BundleIdCapabilityUpdateRequest,
  BundleIdCreateRequest,
  BundleIdResponse,
  BundleIdUpdateRequest,
  BundleIdsResponse,
  CertificateCreateRequest,
  CertificateResponse,
  CertificatesResponse,
  DeviceCreateRequest,
  DeviceResponse,
  DeviceUpdateRequest,
  DevicesResponse,
  DiagnosticLogsResponse,
  DiagnosticSignaturesResponse,
  EndUserLicenseAgreementCreateRequest,
  EndUserLicenseAgreementResponse,
  EndUserLicenseAgreementUpdateRequest,
  GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
  GameCenterEnabledVersionCompatibleVersionsLinkagesResponse,
  GameCenterEnabledVersionsResponse,
  IdfaDeclarationCreateRequest,
  IdfaDeclarationResponse,
  IdfaDeclarationUpdateRequest,
  InAppPurchaseResponse,
  InAppPurchasesResponse,
  PerfPowerMetricsResponse,
  PreReleaseVersionsResponse,
  PrereleaseVersionResponse,
  ProfileCreateRequest,
  ProfileResponse,
  ProfilesResponse,
  RoutingAppCoverageCreateRequest,
  RoutingAppCoverageResponse,
  RoutingAppCoverageUpdateRequest,
  TerritoriesResponse,
  TerritoryResponse,
  UserInvitationCreateRequest,
  UserInvitationResponse,
  UserInvitationsResponse,
  UserResponse,
  UserUpdateRequest,
  UserVisibleAppsLinkagesRequest,
  UserVisibleAppsLinkagesResponse,
  UsersResponse,
} from "./api";

const api = new Api({
  baseUrl: `${process.env.NDC_OAS_BASE_URL}`,
});

/**
 * @request PATCH :/v1/ageRatingDeclarations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AgeRatingDeclarationsUpdateInstance(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: AgeRatingDeclarationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AgeRatingDeclarationResponse> {
  const result = await api.v1.ageRatingDeclarationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appCategories
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppCategoriesGetCollection(
  query: {
    /** filter by attribute 'platforms' */
    "filter[platforms]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by existence or non-existence of related 'parent' */
    "exists[parent]"?: string[];
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("parent" | "subcategories")[];
    /** maximum number of related subcategories returned (when they are included) */
    "limit[subcategories]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoriesResponse> {
  const result = await api.v1.appCategoriesGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appCategories/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppCategoriesGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
    /** comma-separated list of relationships to include */
    include?: ("parent" | "subcategories")[];
    /** maximum number of related subcategories returned (when they are included) */
    "limit[subcategories]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appCategoriesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appCategories/{id}/parent
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppCategoriesParentGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appCategoriesParentGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appCategories/{id}/subcategories
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppCategoriesSubcategoriesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoriesResponse> {
  const result = await api.v1.appCategoriesSubcategoriesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appEncryptionDeclarations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppEncryptionDeclarationsGetCollection(
  query: {
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** filter by id(s) of related 'builds' */
    "filter[builds]"?: string[];
    /** the fields to include for returned resources of type appEncryptionDeclarations */
    "fields[appEncryptionDeclarations]"?: (
      | "app"
      | "appEncryptionDeclarationState"
      | "availableOnFrenchStore"
      | "builds"
      | "codeValue"
      | "containsProprietaryCryptography"
      | "containsThirdPartyCryptography"
      | "documentName"
      | "documentType"
      | "documentUrl"
      | "exempt"
      | "platform"
      | "uploadedDate"
      | "usesEncryption"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppEncryptionDeclarationsResponse> {
  const result = await api.v1.appEncryptionDeclarationsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appEncryptionDeclarations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppEncryptionDeclarationsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appEncryptionDeclarations */
    "fields[appEncryptionDeclarations]"?: (
      | "app"
      | "appEncryptionDeclarationState"
      | "availableOnFrenchStore"
      | "builds"
      | "codeValue"
      | "containsProprietaryCryptography"
      | "containsThirdPartyCryptography"
      | "documentName"
      | "documentType"
      | "documentUrl"
      | "exempt"
      | "platform"
      | "uploadedDate"
      | "usesEncryption"
    )[];
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppEncryptionDeclarationResponse> {
  const result = await api.v1.appEncryptionDeclarationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appEncryptionDeclarations/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppEncryptionDeclarationsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.appEncryptionDeclarationsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appEncryptionDeclarations/{id}/relationships/builds
 * @allowrelaxedtypes
 */
export async function postV1AppEncryptionDeclarationsBuildsCreateToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: AppEncryptionDeclarationBuildsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.appEncryptionDeclarationsBuildsCreateToManyRelationship({
      id: id,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appInfoLocalizations
 * @allowrelaxedtypes
 */
export async function postV1AppInfoLocalizationsCreateInstance(
  /** Request body */
  data: AppInfoLocalizationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoLocalizationResponse> {
  const result = await api.v1.appInfoLocalizationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appInfoLocalizations/{id}
 */
export async function deleteV1AppInfoLocalizationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appInfoLocalizationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfoLocalizations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfoLocalizationsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appInfoLocalizations */
    "fields[appInfoLocalizations]"?: (
      | "appInfo"
      | "locale"
      | "name"
      | "privacyPolicyText"
      | "privacyPolicyUrl"
      | "subtitle"
    )[];
    /** comma-separated list of relationships to include */
    include?: "appInfo"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoLocalizationResponse> {
  const result = await api.v1.appInfoLocalizationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appInfoLocalizations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppInfoLocalizationsUpdateInstance(
  id: string,
  /** Request body */
  data: AppInfoLocalizationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoLocalizationResponse> {
  const result = await api.v1.appInfoLocalizationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appInfos */
    "fields[appInfos]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "appStoreAgeRating"
      | "appStoreState"
      | "brazilAgeRating"
      | "kidsAgeBand"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** comma-separated list of relationships to include */
    include?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "contests"
      | "gambling"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "seventeenPlus"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
    /** the fields to include for returned resources of type appInfoLocalizations */
    "fields[appInfoLocalizations]"?: (
      | "appInfo"
      | "locale"
      | "name"
      | "privacyPolicyText"
      | "privacyPolicyUrl"
      | "subtitle"
    )[];
    /** maximum number of related appInfoLocalizations returned (when they are included) */
    "limit[appInfoLocalizations]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoResponse> {
  const result = await api.v1.appInfosGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appInfos/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppInfosUpdateInstance(
  id: string,
  /** Request body */
  data: AppInfoUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoResponse> {
  const result = await api.v1.appInfosUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/ageRatingDeclaration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosAgeRatingDeclarationGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "contests"
      | "gambling"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "seventeenPlus"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AgeRatingDeclarationResponse> {
  const result = await api.v1.appInfosAgeRatingDeclarationGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/appInfoLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosAppInfoLocalizationsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'locale' */
    "filter[locale]"?: string[];
    /** the fields to include for returned resources of type appInfos */
    "fields[appInfos]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "appStoreAgeRating"
      | "appStoreState"
      | "brazilAgeRating"
      | "kidsAgeBand"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** the fields to include for returned resources of type appInfoLocalizations */
    "fields[appInfoLocalizations]"?: (
      | "appInfo"
      | "locale"
      | "name"
      | "privacyPolicyText"
      | "privacyPolicyUrl"
      | "subtitle"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "appInfo"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfoLocalizationsResponse> {
  const result = await api.v1.appInfosAppInfoLocalizationsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/primaryCategory
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosPrimaryCategoryGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosPrimaryCategoryGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/primarySubcategoryOne
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosPrimarySubcategoryOneGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosPrimarySubcategoryOneGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/primarySubcategoryTwo
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosPrimarySubcategoryTwoGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosPrimarySubcategoryTwoGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/secondaryCategory
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosSecondaryCategoryGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosSecondaryCategoryGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/secondarySubcategoryOne
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosSecondarySubcategoryOneGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosSecondarySubcategoryOneGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appInfos/{id}/secondarySubcategoryTwo
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppInfosSecondarySubcategoryTwoGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppCategoryResponse> {
  const result = await api.v1.appInfosSecondarySubcategoryTwoGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appPreOrders
 * @allowrelaxedtypes
 */
export async function postV1AppPreOrdersCreateInstance(
  /** Request body */
  data: AppPreOrderCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreOrderResponse> {
  const result = await api.v1.appPreOrdersCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appPreOrders/{id}
 */
export async function deleteV1AppPreOrdersDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appPreOrdersDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPreOrders/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPreOrdersGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appPreOrders */
    "fields[appPreOrders]"?: (
      | "app"
      | "appReleaseDate"
      | "preOrderAvailableDate"
    )[];
    /** comma-separated list of relationships to include */
    include?: "app"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreOrderResponse> {
  const result = await api.v1.appPreOrdersGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appPreOrders/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppPreOrdersUpdateInstance(
  id: string,
  /** Request body */
  data: AppPreOrderUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreOrderResponse> {
  const result = await api.v1.appPreOrdersUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appPreviewSets
 * @allowrelaxedtypes
 */
export async function postV1AppPreviewSetsCreateInstance(
  /** Request body */
  data: AppPreviewSetCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewSetResponse> {
  const result = await api.v1.appPreviewSetsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appPreviewSets/{id}
 */
export async function deleteV1AppPreviewSetsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appPreviewSetsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPreviewSets/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPreviewSetsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appPreviewSets */
    "fields[appPreviewSets]"?: (
      | "appPreviews"
      | "appStoreVersionLocalization"
      | "previewType"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("appPreviews" | "appStoreVersionLocalization")[];
    /** the fields to include for returned resources of type appPreviews */
    "fields[appPreviews]"?: (
      | "appPreviewSet"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "mimeType"
      | "previewFrameTimeCode"
      | "previewImage"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
      | "videoUrl"
    )[];
    /** maximum number of related appPreviews returned (when they are included) */
    "limit[appPreviews]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewSetResponse> {
  const result = await api.v1.appPreviewSetsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPreviewSets/{id}/appPreviews
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPreviewSetsAppPreviewsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPreviews */
    "fields[appPreviews]"?: (
      | "appPreviewSet"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "mimeType"
      | "previewFrameTimeCode"
      | "previewImage"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
      | "videoUrl"
    )[];
    /** the fields to include for returned resources of type appPreviewSets */
    "fields[appPreviewSets]"?: (
      | "appPreviews"
      | "appStoreVersionLocalization"
      | "previewType"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "appPreviewSet"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewsResponse> {
  const result = await api.v1.appPreviewSetsAppPreviewsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPreviewSets/{id}/relationships/appPreviews
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPreviewSetsAppPreviewsGetToManyRelationship(
  /** the id of the requested resource */
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewSetAppPreviewsLinkagesResponse> {
  const result = await api.v1.appPreviewSetsAppPreviewsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appPreviewSets/{id}/relationships/appPreviews
 * @allowrelaxedtypes
 */
export async function patchV1AppPreviewSetsAppPreviewsReplaceToManyRelationship(
  id: string,
  /** Request body */
  data: AppPreviewSetAppPreviewsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.appPreviewSetsAppPreviewsReplaceToManyRelationship({
      id: id,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appPreviews
 * @allowrelaxedtypes
 */
export async function postV1AppPreviewsCreateInstance(
  /** Request body */
  data: AppPreviewCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewResponse> {
  const result = await api.v1.appPreviewsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appPreviews/{id}
 */
export async function deleteV1AppPreviewsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appPreviewsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPreviews/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPreviewsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appPreviews */
    "fields[appPreviews]"?: (
      | "appPreviewSet"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "mimeType"
      | "previewFrameTimeCode"
      | "previewImage"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
      | "videoUrl"
    )[];
    /** comma-separated list of relationships to include */
    include?: "appPreviewSet"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewResponse> {
  const result = await api.v1.appPreviewsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appPreviews/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppPreviewsUpdateInstance(
  id: string,
  /** Request body */
  data: AppPreviewUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewResponse> {
  const result = await api.v1.appPreviewsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPricePoints
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPricePointsGetCollection(
  query: {
    /** filter by id(s) of related 'priceTier' */
    "filter[priceTier]"?: string[];
    /** filter by id(s) of related 'territory' */
    "filter[territory]"?: string[];
    /** the fields to include for returned resources of type appPricePoints */
    "fields[appPricePoints]"?: (
      | "customerPrice"
      | "priceTier"
      | "proceeds"
      | "territory"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("priceTier" | "territory")[];
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPricePointsResponse> {
  const result = await api.v1.appPricePointsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPricePoints/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPricePointsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPricePoints */
    "fields[appPricePoints]"?: (
      | "customerPrice"
      | "priceTier"
      | "proceeds"
      | "territory"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("priceTier" | "territory")[];
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPricePointResponse> {
  const result = await api.v1.appPricePointsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPricePoints/{id}/territory
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPricePointsTerritoryGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<TerritoryResponse> {
  const result = await api.v1.appPricePointsTerritoryGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPriceTiers
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPriceTiersGetCollection(
  query: {
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** the fields to include for returned resources of type appPriceTiers */
    "fields[appPriceTiers]"?: "pricePoints"[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "pricePoints"[];
    /** the fields to include for returned resources of type appPricePoints */
    "fields[appPricePoints]"?: (
      | "customerPrice"
      | "priceTier"
      | "proceeds"
      | "territory"
    )[];
    /** maximum number of related pricePoints returned (when they are included) */
    "limit[pricePoints]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPriceTiersResponse> {
  const result = await api.v1.appPriceTiersGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPriceTiers/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPriceTiersGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPriceTiers */
    "fields[appPriceTiers]"?: "pricePoints"[];
    /** comma-separated list of relationships to include */
    include?: "pricePoints"[];
    /** the fields to include for returned resources of type appPricePoints */
    "fields[appPricePoints]"?: (
      | "customerPrice"
      | "priceTier"
      | "proceeds"
      | "territory"
    )[];
    /** maximum number of related pricePoints returned (when they are included) */
    "limit[pricePoints]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPriceTierResponse> {
  const result = await api.v1.appPriceTiersGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPriceTiers/{id}/pricePoints
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPriceTiersPricePointsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPricePoints */
    "fields[appPricePoints]"?: (
      | "customerPrice"
      | "priceTier"
      | "proceeds"
      | "territory"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPricePointsResponse> {
  const result = await api.v1.appPriceTiersPricePointsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appPrices/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppPricesGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPrices */
    "fields[appPrices]"?: ("app" | "priceTier")[];
    /** comma-separated list of relationships to include */
    include?: ("app" | "priceTier")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPriceResponse> {
  const result = await api.v1.appPricesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appScreenshotSets
 * @allowrelaxedtypes
 */
export async function postV1AppScreenshotSetsCreateInstance(
  /** Request body */
  data: AppScreenshotSetCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotSetResponse> {
  const result = await api.v1.appScreenshotSetsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appScreenshotSets/{id}
 */
export async function deleteV1AppScreenshotSetsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appScreenshotSetsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appScreenshotSets/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppScreenshotSetsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appScreenshotSets */
    "fields[appScreenshotSets]"?: (
      | "appScreenshots"
      | "appStoreVersionLocalization"
      | "screenshotDisplayType"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("appScreenshots" | "appStoreVersionLocalization")[];
    /** the fields to include for returned resources of type appScreenshots */
    "fields[appScreenshots]"?: (
      | "appScreenshotSet"
      | "assetDeliveryState"
      | "assetToken"
      | "assetType"
      | "fileName"
      | "fileSize"
      | "imageAsset"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** maximum number of related appScreenshots returned (when they are included) */
    "limit[appScreenshots]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotSetResponse> {
  const result = await api.v1.appScreenshotSetsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appScreenshotSets/{id}/appScreenshots
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppScreenshotSetsAppScreenshotsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appScreenshotSets */
    "fields[appScreenshotSets]"?: (
      | "appScreenshots"
      | "appStoreVersionLocalization"
      | "screenshotDisplayType"
    )[];
    /** the fields to include for returned resources of type appScreenshots */
    "fields[appScreenshots]"?: (
      | "appScreenshotSet"
      | "assetDeliveryState"
      | "assetToken"
      | "assetType"
      | "fileName"
      | "fileSize"
      | "imageAsset"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "appScreenshotSet"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotsResponse> {
  const result = await api.v1.appScreenshotSetsAppScreenshotsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appScreenshotSets/{id}/relationships/appScreenshots
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppScreenshotSetsAppScreenshotsGetToManyRelationship(
  /** the id of the requested resource */
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotSetAppScreenshotsLinkagesResponse> {
  const result =
    await api.v1.appScreenshotSetsAppScreenshotsGetToManyRelationship({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appScreenshotSets/{id}/relationships/appScreenshots
 * @allowrelaxedtypes
 */
export async function patchV1AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(
  id: string,
  /** Request body */
  data: AppScreenshotSetAppScreenshotsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.appScreenshotSetsAppScreenshotsReplaceToManyRelationship({
      id: id,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appScreenshots
 * @allowrelaxedtypes
 */
export async function postV1AppScreenshotsCreateInstance(
  /** Request body */
  data: AppScreenshotCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotResponse> {
  const result = await api.v1.appScreenshotsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appScreenshots/{id}
 */
export async function deleteV1AppScreenshotsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appScreenshotsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appScreenshots/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppScreenshotsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appScreenshots */
    "fields[appScreenshots]"?: (
      | "appScreenshotSet"
      | "assetDeliveryState"
      | "assetToken"
      | "assetType"
      | "fileName"
      | "fileSize"
      | "imageAsset"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** comma-separated list of relationships to include */
    include?: "appScreenshotSet"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotResponse> {
  const result = await api.v1.appScreenshotsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appScreenshots/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppScreenshotsUpdateInstance(
  id: string,
  /** Request body */
  data: AppScreenshotUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotResponse> {
  const result = await api.v1.appScreenshotsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreReviewAttachments
 * @allowrelaxedtypes
 */
export async function postV1AppStoreReviewAttachmentsCreateInstance(
  /** Request body */
  data: AppStoreReviewAttachmentCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewAttachmentResponse> {
  const result = await api.v1.appStoreReviewAttachmentsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appStoreReviewAttachments/{id}
 */
export async function deleteV1AppStoreReviewAttachmentsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreReviewAttachmentsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreReviewAttachments/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreReviewAttachmentsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreReviewAttachments */
    "fields[appStoreReviewAttachments]"?: (
      | "appStoreReviewDetail"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** comma-separated list of relationships to include */
    include?: "appStoreReviewDetail"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewAttachmentResponse> {
  const result = await api.v1.appStoreReviewAttachmentsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreReviewAttachments/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreReviewAttachmentsUpdateInstance(
  id: string,
  /** Request body */
  data: AppStoreReviewAttachmentUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewAttachmentResponse> {
  const result = await api.v1.appStoreReviewAttachmentsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreReviewDetails
 * @allowrelaxedtypes
 */
export async function postV1AppStoreReviewDetailsCreateInstance(
  /** Request body */
  data: AppStoreReviewDetailCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewDetailResponse> {
  const result = await api.v1.appStoreReviewDetailsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreReviewDetails/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreReviewDetailsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreReviewDetails */
    "fields[appStoreReviewDetails]"?: (
      | "appStoreReviewAttachments"
      | "appStoreVersion"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("appStoreReviewAttachments" | "appStoreVersion")[];
    /** the fields to include for returned resources of type appStoreReviewAttachments */
    "fields[appStoreReviewAttachments]"?: (
      | "appStoreReviewDetail"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** maximum number of related appStoreReviewAttachments returned (when they are included) */
    "limit[appStoreReviewAttachments]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewDetailResponse> {
  const result = await api.v1.appStoreReviewDetailsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreReviewDetails/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreReviewDetailsUpdateInstance(
  id: string,
  /** Request body */
  data: AppStoreReviewDetailUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewDetailResponse> {
  const result = await api.v1.appStoreReviewDetailsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreReviewDetails/{id}/appStoreReviewAttachments
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreReviewDetails */
    "fields[appStoreReviewDetails]"?: (
      | "appStoreReviewAttachments"
      | "appStoreVersion"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type appStoreReviewAttachments */
    "fields[appStoreReviewAttachments]"?: (
      | "appStoreReviewDetail"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "appStoreReviewDetail"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewAttachmentsResponse> {
  const result =
    await api.v1.appStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(
      {
        id: id,
        query: query,
        params: {
          headers: (headers?.value as Record<string, string>) ?? undefined,
        },
      },
    );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreVersionLocalizations
 * @allowrelaxedtypes
 */
export async function postV1AppStoreVersionLocalizationsCreateInstance(
  /** Request body */
  data: AppStoreVersionLocalizationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionLocalizationResponse> {
  const result = await api.v1.appStoreVersionLocalizationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appStoreVersionLocalizations/{id}
 */
export async function deleteV1AppStoreVersionLocalizationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreVersionLocalizationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersionLocalizations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionLocalizationsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("appPreviewSets" | "appScreenshotSets" | "appStoreVersion")[];
    /** the fields to include for returned resources of type appScreenshotSets */
    "fields[appScreenshotSets]"?: (
      | "appScreenshots"
      | "appStoreVersionLocalization"
      | "screenshotDisplayType"
    )[];
    /** the fields to include for returned resources of type appPreviewSets */
    "fields[appPreviewSets]"?: (
      | "appPreviews"
      | "appStoreVersionLocalization"
      | "previewType"
    )[];
    /** maximum number of related appPreviewSets returned (when they are included) */
    "limit[appPreviewSets]"?: number;
    /** maximum number of related appScreenshotSets returned (when they are included) */
    "limit[appScreenshotSets]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionLocalizationResponse> {
  const result = await api.v1.appStoreVersionLocalizationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreVersionLocalizations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreVersionLocalizationsUpdateInstance(
  id: string,
  /** Request body */
  data: AppStoreVersionLocalizationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionLocalizationResponse> {
  const result = await api.v1.appStoreVersionLocalizationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersionLocalizations/{id}/appPreviewSets
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'previewType' */
    "filter[previewType]"?: (
      | "IPHONE_65"
      | "IPHONE_58"
      | "IPHONE_55"
      | "IPHONE_47"
      | "IPHONE_40"
      | "IPHONE_35"
      | "IPAD_PRO_3GEN_129"
      | "IPAD_PRO_3GEN_11"
      | "IPAD_PRO_129"
      | "IPAD_105"
      | "IPAD_97"
      | "DESKTOP"
      | "WATCH_SERIES_4"
      | "WATCH_SERIES_3"
      | "APPLE_TV"
    )[];
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** the fields to include for returned resources of type appPreviews */
    "fields[appPreviews]"?: (
      | "appPreviewSet"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "mimeType"
      | "previewFrameTimeCode"
      | "previewImage"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
      | "videoUrl"
    )[];
    /** the fields to include for returned resources of type appPreviewSets */
    "fields[appPreviewSets]"?: (
      | "appPreviews"
      | "appStoreVersionLocalization"
      | "previewType"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("appPreviews" | "appStoreVersionLocalization")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreviewSetsResponse> {
  const result =
    await api.v1.appStoreVersionLocalizationsAppPreviewSetsGetToManyRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersionLocalizations/{id}/appScreenshotSets
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'screenshotDisplayType' */
    "filter[screenshotDisplayType]"?: (
      | "APP_IPHONE_65"
      | "APP_IPHONE_58"
      | "APP_IPHONE_55"
      | "APP_IPHONE_47"
      | "APP_IPHONE_40"
      | "APP_IPHONE_35"
      | "APP_IPAD_PRO_3GEN_129"
      | "APP_IPAD_PRO_3GEN_11"
      | "APP_IPAD_PRO_129"
      | "APP_IPAD_105"
      | "APP_IPAD_97"
      | "APP_DESKTOP"
      | "APP_WATCH_SERIES_4"
      | "APP_WATCH_SERIES_3"
      | "APP_APPLE_TV"
      | "IMESSAGE_APP_IPHONE_65"
      | "IMESSAGE_APP_IPHONE_58"
      | "IMESSAGE_APP_IPHONE_55"
      | "IMESSAGE_APP_IPHONE_47"
      | "IMESSAGE_APP_IPHONE_40"
      | "IMESSAGE_APP_IPAD_PRO_3GEN_129"
      | "IMESSAGE_APP_IPAD_PRO_3GEN_11"
      | "IMESSAGE_APP_IPAD_PRO_129"
      | "IMESSAGE_APP_IPAD_105"
      | "IMESSAGE_APP_IPAD_97"
    )[];
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** the fields to include for returned resources of type appScreenshotSets */
    "fields[appScreenshotSets]"?: (
      | "appScreenshots"
      | "appStoreVersionLocalization"
      | "screenshotDisplayType"
    )[];
    /** the fields to include for returned resources of type appScreenshots */
    "fields[appScreenshots]"?: (
      | "appScreenshotSet"
      | "assetDeliveryState"
      | "assetToken"
      | "assetType"
      | "fileName"
      | "fileSize"
      | "imageAsset"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("appScreenshots" | "appStoreVersionLocalization")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppScreenshotSetsResponse> {
  const result =
    await api.v1.appStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreVersionPhasedReleases
 * @allowrelaxedtypes
 */
export async function postV1AppStoreVersionPhasedReleasesCreateInstance(
  /** Request body */
  data: AppStoreVersionPhasedReleaseCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionPhasedReleaseResponse> {
  const result = await api.v1.appStoreVersionPhasedReleasesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appStoreVersionPhasedReleases/{id}
 */
export async function deleteV1AppStoreVersionPhasedReleasesDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreVersionPhasedReleasesDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreVersionPhasedReleases/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreVersionPhasedReleasesUpdateInstance(
  id: string,
  /** Request body */
  data: AppStoreVersionPhasedReleaseUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionPhasedReleaseResponse> {
  const result = await api.v1.appStoreVersionPhasedReleasesUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreVersionSubmissions
 * @allowrelaxedtypes
 */
export async function postV1AppStoreVersionSubmissionsCreateInstance(
  /** Request body */
  data: AppStoreVersionSubmissionCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionSubmissionResponse> {
  const result = await api.v1.appStoreVersionSubmissionsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appStoreVersionSubmissions/{id}
 */
export async function deleteV1AppStoreVersionSubmissionsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreVersionSubmissionsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/appStoreVersions
 * @allowrelaxedtypes
 */
export async function postV1AppStoreVersionsCreateInstance(
  /** Request body */
  data: AppStoreVersionCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionResponse> {
  const result = await api.v1.appStoreVersionsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/appStoreVersions/{id}
 */
export async function deleteV1AppStoreVersionsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreVersionsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** comma-separated list of relationships to include */
    include?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "idfaDeclaration"
      | "routingAppCoverage"
    )[];
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** the fields to include for returned resources of type idfaDeclarations */
    "fields[idfaDeclarations]"?: (
      | "appStoreVersion"
      | "attributesActionWithPreviousAd"
      | "attributesAppInstallationToPreviousAd"
      | "honorsLimitedAdTracking"
      | "servesAds"
    )[];
    /** the fields to include for returned resources of type routingAppCoverages */
    "fields[routingAppCoverages]"?: (
      | "appStoreVersion"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
    "fields[appStoreVersionPhasedReleases]"?: (
      | "appStoreVersion"
      | "currentDayNumber"
      | "phasedReleaseState"
      | "startDate"
      | "totalPauseDuration"
    )[];
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
    /** the fields to include for returned resources of type appStoreReviewDetails */
    "fields[appStoreReviewDetails]"?: (
      | "appStoreReviewAttachments"
      | "appStoreVersion"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type appStoreVersionSubmissions */
    "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
    /** maximum number of related appStoreVersionLocalizations returned (when they are included) */
    "limit[appStoreVersionLocalizations]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionResponse> {
  const result = await api.v1.appStoreVersionsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreVersions/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreVersionsUpdateInstance(
  id: string,
  /** Request body */
  data: AppStoreVersionUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionResponse> {
  const result = await api.v1.appStoreVersionsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/ageRatingDeclaration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsAgeRatingDeclarationGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AgeRatingDeclarationResponse> {
  const result =
    await api.v1.appStoreVersionsAgeRatingDeclarationGetToOneRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/appStoreReviewDetail
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsAppStoreReviewDetailGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreReviewDetails */
    "fields[appStoreReviewDetails]"?: (
      | "appStoreReviewAttachments"
      | "appStoreVersion"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type appStoreReviewAttachments */
    "fields[appStoreReviewAttachments]"?: (
      | "appStoreReviewDetail"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("appStoreReviewAttachments" | "appStoreVersion")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreReviewDetailResponse> {
  const result =
    await api.v1.appStoreVersionsAppStoreReviewDetailGetToOneRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/appStoreVersionLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionLocalizationsResponse> {
  const result =
    await api.v1.appStoreVersionsAppStoreVersionLocalizationsGetToManyRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/appStoreVersionPhasedRelease
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
    "fields[appStoreVersionPhasedReleases]"?: (
      | "appStoreVersion"
      | "currentDayNumber"
      | "phasedReleaseState"
      | "startDate"
      | "totalPauseDuration"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionPhasedReleaseResponse> {
  const result =
    await api.v1.appStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/appStoreVersionSubmission
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type appStoreVersionSubmissions */
    "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
    /** comma-separated list of relationships to include */
    include?: "appStoreVersion"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionSubmissionResponse> {
  const result =
    await api.v1.appStoreVersionsAppStoreVersionSubmissionGetToOneRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/build
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsBuildGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.appStoreVersionsBuildGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/idfaDeclaration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsIdfaDeclarationGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type idfaDeclarations */
    "fields[idfaDeclarations]"?: (
      | "appStoreVersion"
      | "attributesActionWithPreviousAd"
      | "attributesAppInstallationToPreviousAd"
      | "honorsLimitedAdTracking"
      | "servesAds"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<IdfaDeclarationResponse> {
  const result = await api.v1.appStoreVersionsIdfaDeclarationGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/relationships/build
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsBuildGetToOneRelationship(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionBuildLinkageResponse> {
  const result = await api.v1.appStoreVersionsBuildGetToOneRelationship({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/appStoreVersions/{id}/relationships/build
 * @allowrelaxedtypes
 */
export async function patchV1AppStoreVersionsBuildUpdateToOneRelationship(
  id: string,
  /** Request body */
  data: AppStoreVersionBuildLinkageRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appStoreVersionsBuildUpdateToOneRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/appStoreVersions/{id}/routingAppCoverage
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppStoreVersionsRoutingAppCoverageGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type routingAppCoverages */
    "fields[routingAppCoverages]"?: (
      | "appStoreVersion"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<RoutingAppCoverageResponse> {
  const result = await api.v1.appStoreVersionsRoutingAppCoverageGetToOneRelated(
    {
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    },
  );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsGetCollection(
  query: {
    /** filter by attribute 'appStoreVersions.appStoreState' */
    filterAppStoreVersionsAppStoreState?: (
      | "DEVELOPER_REMOVED_FROM_SALE"
      | "DEVELOPER_REJECTED"
      | "IN_REVIEW"
      | "INVALID_BINARY"
      | "METADATA_REJECTED"
      | "PENDING_APPLE_RELEASE"
      | "PENDING_CONTRACT"
      | "PENDING_DEVELOPER_RELEASE"
      | "PREPARE_FOR_SUBMISSION"
      | "PREORDER_READY_FOR_SALE"
      | "PROCESSING_FOR_APP_STORE"
      | "READY_FOR_SALE"
      | "REJECTED"
      | "REMOVED_FROM_SALE"
      | "WAITING_FOR_EXPORT_COMPLIANCE"
      | "WAITING_FOR_REVIEW"
      | "REPLACED_WITH_NEW_VERSION"
    )[];
    /** filter by attribute 'appStoreVersions.platform' */
    filterAppStoreVersionsPlatform?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'bundleId' */
    "filter[bundleId]"?: string[];
    /** filter by attribute 'name' */
    "filter[name]"?: string[];
    /** filter by attribute 'sku' */
    "filter[sku]"?: string[];
    /** filter by id(s) of related 'appStoreVersions' */
    "filter[appStoreVersions]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** filter by existence or non-existence of related 'gameCenterEnabledVersions' */
    "exists[gameCenterEnabledVersions]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("bundleId" | "-bundleId" | "name" | "-name" | "sku" | "-sku")[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "builds"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
    )[];
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** the fields to include for returned resources of type perfPowerMetrics */
    "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
    /** the fields to include for returned resources of type appInfos */
    "fields[appInfos]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "appStoreAgeRating"
      | "appStoreState"
      | "brazilAgeRating"
      | "kidsAgeBand"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** the fields to include for returned resources of type appPreOrders */
    "fields[appPreOrders]"?: (
      | "app"
      | "appReleaseDate"
      | "preOrderAvailableDate"
    )[];
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** the fields to include for returned resources of type appPrices */
    "fields[appPrices]"?: ("app" | "priceTier")[];
    /** the fields to include for returned resources of type inAppPurchases */
    "fields[inAppPurchases]"?: (
      | "apps"
      | "inAppPurchaseType"
      | "productId"
      | "referenceName"
      | "state"
    )[];
    /** the fields to include for returned resources of type betaAppReviewDetails */
    "fields[betaAppReviewDetails]"?: (
      | "app"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** the fields to include for returned resources of type gameCenterEnabledVersions */
    "fields[gameCenterEnabledVersions]"?: (
      | "app"
      | "compatibleVersions"
      | "iconAsset"
      | "platform"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type betaAppLocalizations */
    "fields[betaAppLocalizations]"?: (
      | "app"
      | "description"
      | "feedbackEmail"
      | "locale"
      | "marketingUrl"
      | "privacyPolicyUrl"
      | "tvOsPrivacyPolicy"
    )[];
    /** the fields to include for returned resources of type betaLicenseAgreements */
    "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
    /** the fields to include for returned resources of type endUserLicenseAgreements */
    "fields[endUserLicenseAgreements]"?: (
      | "agreementText"
      | "app"
      | "territories"
    )[];
    /** maximum number of related appInfos returned (when they are included) */
    "limit[appInfos]"?: number;
    /** maximum number of related appStoreVersions returned (when they are included) */
    "limit[appStoreVersions]"?: number;
    /** maximum number of related availableTerritories returned (when they are included) */
    "limit[availableTerritories]"?: number;
    /** maximum number of related betaAppLocalizations returned (when they are included) */
    "limit[betaAppLocalizations]"?: number;
    /** maximum number of related betaGroups returned (when they are included) */
    "limit[betaGroups]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
    /** maximum number of related gameCenterEnabledVersions returned (when they are included) */
    "limit[gameCenterEnabledVersions]"?: number;
    /** maximum number of related inAppPurchases returned (when they are included) */
    "limit[inAppPurchases]"?: number;
    /** maximum number of related preReleaseVersions returned (when they are included) */
    "limit[preReleaseVersions]"?: number;
    /** maximum number of related prices returned (when they are included) */
    "limit[prices]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppsResponse> {
  const result = await api.v1.appsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** comma-separated list of relationships to include */
    include?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "builds"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
    )[];
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** the fields to include for returned resources of type perfPowerMetrics */
    "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
    /** the fields to include for returned resources of type appInfos */
    "fields[appInfos]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "appStoreAgeRating"
      | "appStoreState"
      | "brazilAgeRating"
      | "kidsAgeBand"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** the fields to include for returned resources of type appPreOrders */
    "fields[appPreOrders]"?: (
      | "app"
      | "appReleaseDate"
      | "preOrderAvailableDate"
    )[];
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** the fields to include for returned resources of type appPrices */
    "fields[appPrices]"?: ("app" | "priceTier")[];
    /** the fields to include for returned resources of type inAppPurchases */
    "fields[inAppPurchases]"?: (
      | "apps"
      | "inAppPurchaseType"
      | "productId"
      | "referenceName"
      | "state"
    )[];
    /** the fields to include for returned resources of type betaAppReviewDetails */
    "fields[betaAppReviewDetails]"?: (
      | "app"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** the fields to include for returned resources of type gameCenterEnabledVersions */
    "fields[gameCenterEnabledVersions]"?: (
      | "app"
      | "compatibleVersions"
      | "iconAsset"
      | "platform"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type betaAppLocalizations */
    "fields[betaAppLocalizations]"?: (
      | "app"
      | "description"
      | "feedbackEmail"
      | "locale"
      | "marketingUrl"
      | "privacyPolicyUrl"
      | "tvOsPrivacyPolicy"
    )[];
    /** the fields to include for returned resources of type betaLicenseAgreements */
    "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
    /** the fields to include for returned resources of type endUserLicenseAgreements */
    "fields[endUserLicenseAgreements]"?: (
      | "agreementText"
      | "app"
      | "territories"
    )[];
    /** maximum number of related appInfos returned (when they are included) */
    "limit[appInfos]"?: number;
    /** maximum number of related appStoreVersions returned (when they are included) */
    "limit[appStoreVersions]"?: number;
    /** maximum number of related availableTerritories returned (when they are included) */
    "limit[availableTerritories]"?: number;
    /** maximum number of related betaAppLocalizations returned (when they are included) */
    "limit[betaAppLocalizations]"?: number;
    /** maximum number of related betaGroups returned (when they are included) */
    "limit[betaGroups]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
    /** maximum number of related gameCenterEnabledVersions returned (when they are included) */
    "limit[gameCenterEnabledVersions]"?: number;
    /** maximum number of related inAppPurchases returned (when they are included) */
    "limit[inAppPurchases]"?: number;
    /** maximum number of related preReleaseVersions returned (when they are included) */
    "limit[preReleaseVersions]"?: number;
    /** maximum number of related prices returned (when they are included) */
    "limit[prices]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.appsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/apps/{id}
 * @allowrelaxedtypes
 */
export async function patchV1AppsUpdateInstance(
  id: string,
  /** Request body */
  data: AppUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.appsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/appInfos
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsAppInfosGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "contests"
      | "gambling"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "seventeenPlus"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
    /** the fields to include for returned resources of type appInfos */
    "fields[appInfos]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appInfoLocalizations"
      | "appStoreAgeRating"
      | "appStoreState"
      | "brazilAgeRating"
      | "kidsAgeBand"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
    /** the fields to include for returned resources of type appCategories */
    "fields[appCategories]"?: ("parent" | "platforms" | "subcategories")[];
    /** the fields to include for returned resources of type appInfoLocalizations */
    "fields[appInfoLocalizations]"?: (
      | "appInfo"
      | "locale"
      | "name"
      | "privacyPolicyText"
      | "privacyPolicyUrl"
      | "subtitle"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: (
      | "app"
      | "appInfoLocalizations"
      | "primaryCategory"
      | "primarySubcategoryOne"
      | "primarySubcategoryTwo"
      | "secondaryCategory"
      | "secondarySubcategoryOne"
      | "secondarySubcategoryTwo"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppInfosResponse> {
  const result = await api.v1.appsAppInfosGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/appStoreVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsAppStoreVersionsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'appStoreState' */
    "filter[appStoreState]"?: (
      | "DEVELOPER_REMOVED_FROM_SALE"
      | "DEVELOPER_REJECTED"
      | "IN_REVIEW"
      | "INVALID_BINARY"
      | "METADATA_REJECTED"
      | "PENDING_APPLE_RELEASE"
      | "PENDING_CONTRACT"
      | "PENDING_DEVELOPER_RELEASE"
      | "PREPARE_FOR_SUBMISSION"
      | "PREORDER_READY_FOR_SALE"
      | "PROCESSING_FOR_APP_STORE"
      | "READY_FOR_SALE"
      | "REJECTED"
      | "REMOVED_FROM_SALE"
      | "WAITING_FOR_EXPORT_COMPLIANCE"
      | "WAITING_FOR_REVIEW"
      | "REPLACED_WITH_NEW_VERSION"
    )[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'versionString' */
    "filter[versionString]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** the fields to include for returned resources of type idfaDeclarations */
    "fields[idfaDeclarations]"?: (
      | "appStoreVersion"
      | "attributesActionWithPreviousAd"
      | "attributesAppInstallationToPreviousAd"
      | "honorsLimitedAdTracking"
      | "servesAds"
    )[];
    /** the fields to include for returned resources of type appStoreVersionLocalizations */
    "fields[appStoreVersionLocalizations]"?: (
      | "appPreviewSets"
      | "appScreenshotSets"
      | "appStoreVersion"
      | "description"
      | "keywords"
      | "locale"
      | "marketingUrl"
      | "promotionalText"
      | "supportUrl"
      | "whatsNew"
    )[];
    /** the fields to include for returned resources of type routingAppCoverages */
    "fields[routingAppCoverages]"?: (
      | "appStoreVersion"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** the fields to include for returned resources of type appStoreVersionPhasedReleases */
    "fields[appStoreVersionPhasedReleases]"?: (
      | "appStoreVersion"
      | "currentDayNumber"
      | "phasedReleaseState"
      | "startDate"
      | "totalPauseDuration"
    )[];
    /** the fields to include for returned resources of type ageRatingDeclarations */
    "fields[ageRatingDeclarations]"?: (
      | "alcoholTobaccoOrDrugUseOrReferences"
      | "gamblingAndContests"
      | "gamblingSimulated"
      | "horrorOrFearThemes"
      | "kidsAgeBand"
      | "matureOrSuggestiveThemes"
      | "medicalOrTreatmentInformation"
      | "profanityOrCrudeHumor"
      | "sexualContentGraphicAndNudity"
      | "sexualContentOrNudity"
      | "unrestrictedWebAccess"
      | "violenceCartoonOrFantasy"
      | "violenceRealistic"
      | "violenceRealisticProlongedGraphicOrSadistic"
    )[];
    /** the fields to include for returned resources of type appStoreReviewDetails */
    "fields[appStoreReviewDetails]"?: (
      | "appStoreReviewAttachments"
      | "appStoreVersion"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type appStoreVersionSubmissions */
    "fields[appStoreVersionSubmissions]"?: "appStoreVersion"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "idfaDeclaration"
      | "routingAppCoverage"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionsResponse> {
  const result = await api.v1.appsAppStoreVersionsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/availableTerritories
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsAvailableTerritoriesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<TerritoriesResponse> {
  const result = await api.v1.appsAvailableTerritoriesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/betaAppLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsBetaAppLocalizationsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppLocalizations */
    "fields[betaAppLocalizations]"?: (
      | "app"
      | "description"
      | "feedbackEmail"
      | "locale"
      | "marketingUrl"
      | "privacyPolicyUrl"
      | "tvOsPrivacyPolicy"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppLocalizationsResponse> {
  const result = await api.v1.appsBetaAppLocalizationsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/betaAppReviewDetail
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsBetaAppReviewDetailGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppReviewDetails */
    "fields[betaAppReviewDetails]"?: (
      | "app"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewDetailResponse> {
  const result = await api.v1.appsBetaAppReviewDetailGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/betaGroups
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsBetaGroupsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupsResponse> {
  const result = await api.v1.appsBetaGroupsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/betaLicenseAgreement
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsBetaLicenseAgreementGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaLicenseAgreements */
    "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaLicenseAgreementResponse> {
  const result = await api.v1.appsBetaLicenseAgreementGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsBuildsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildsResponse> {
  const result = await api.v1.appsBuildsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/endUserLicenseAgreement
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsEndUserLicenseAgreementGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type endUserLicenseAgreements */
    "fields[endUserLicenseAgreements]"?: (
      | "agreementText"
      | "app"
      | "territories"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<EndUserLicenseAgreementResponse> {
  const result = await api.v1.appsEndUserLicenseAgreementGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/gameCenterEnabledVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsGameCenterEnabledVersionsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'versionString' */
    "filter[versionString]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("versionString" | "-versionString")[];
    /** the fields to include for returned resources of type gameCenterEnabledVersions */
    "fields[gameCenterEnabledVersions]"?: (
      | "app"
      | "compatibleVersions"
      | "iconAsset"
      | "platform"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "compatibleVersions")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<GameCenterEnabledVersionsResponse> {
  const result = await api.v1.appsGameCenterEnabledVersionsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/inAppPurchases
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsInAppPurchasesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'inAppPurchaseType' */
    "filter[inAppPurchaseType]"?: (
      | "AUTOMATICALLY_RENEWABLE_SUBSCRIPTION"
      | "NON_CONSUMABLE"
      | "CONSUMABLE"
      | "NON_RENEWING_SUBSCRIPTION"
      | "FREE_SUBSCRIPTION"
    )[];
    /** filter by canBeSubmitted */
    "filter[canBeSubmitted]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "inAppPurchaseType"
      | "-inAppPurchaseType"
      | "productId"
      | "-productId"
      | "referenceName"
      | "-referenceName"
    )[];
    /** the fields to include for returned resources of type inAppPurchases */
    "fields[inAppPurchases]"?: (
      | "apps"
      | "inAppPurchaseType"
      | "productId"
      | "referenceName"
      | "state"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "apps"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<InAppPurchasesResponse> {
  const result = await api.v1.appsInAppPurchasesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/perfPowerMetrics
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsPerfPowerMetricsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'deviceType' */
    "filter[deviceType]"?: string[];
    /** filter by attribute 'metricType' */
    "filter[metricType]"?: (
      | "DISK"
      | "HANG"
      | "BATTERY"
      | "LAUNCH"
      | "MEMORY"
      | "ANIMATION"
      | "TERMINATION"
    )[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: "IOS"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PerfPowerMetricsResponse> {
  const result = await api.v1.appsPerfPowerMetricsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/preOrder
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsPreOrderGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPreOrders */
    "fields[appPreOrders]"?: (
      | "app"
      | "appReleaseDate"
      | "preOrderAvailableDate"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPreOrderResponse> {
  const result = await api.v1.appsPreOrderGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/preReleaseVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsPreReleaseVersionsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PreReleaseVersionsResponse> {
  const result = await api.v1.appsPreReleaseVersionsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/apps/{id}/prices
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1AppsPricesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appPrices */
    "fields[appPrices]"?: ("app" | "priceTier")[];
    /** the fields to include for returned resources of type appPriceTiers */
    "fields[appPriceTiers]"?: "pricePoints"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "priceTier")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppPricesResponse> {
  const result = await api.v1.appsPricesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/apps/{id}/relationships/betaTesters
 * @allowrelaxedtypes
 */
export async function deleteV1AppsBetaTestersDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: AppBetaTestersLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.appsBetaTestersDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppLocalizationsGetCollection(
  query: {
    /** filter by attribute 'locale' */
    "filter[locale]"?: string[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** the fields to include for returned resources of type betaAppLocalizations */
    "fields[betaAppLocalizations]"?: (
      | "app"
      | "description"
      | "feedbackEmail"
      | "locale"
      | "marketingUrl"
      | "privacyPolicyUrl"
      | "tvOsPrivacyPolicy"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppLocalizationsResponse> {
  const result = await api.v1.betaAppLocalizationsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaAppLocalizations
 * @allowrelaxedtypes
 */
export async function postV1BetaAppLocalizationsCreateInstance(
  /** Request body */
  data: BetaAppLocalizationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppLocalizationResponse> {
  const result = await api.v1.betaAppLocalizationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaAppLocalizations/{id}
 */
export async function deleteV1BetaAppLocalizationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaAppLocalizationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppLocalizations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppLocalizationsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppLocalizations */
    "fields[betaAppLocalizations]"?: (
      | "app"
      | "description"
      | "feedbackEmail"
      | "locale"
      | "marketingUrl"
      | "privacyPolicyUrl"
      | "tvOsPrivacyPolicy"
    )[];
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppLocalizationResponse> {
  const result = await api.v1.betaAppLocalizationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/betaAppLocalizations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BetaAppLocalizationsUpdateInstance(
  id: string,
  /** Request body */
  data: BetaAppLocalizationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppLocalizationResponse> {
  const result = await api.v1.betaAppLocalizationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppLocalizations/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppLocalizationsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.betaAppLocalizationsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewDetails
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewDetailsGetCollection(
  query: {
    /** filter by id(s) of related 'app' */
    "filter[app]": string[];
    /** the fields to include for returned resources of type betaAppReviewDetails */
    "fields[betaAppReviewDetails]"?: (
      | "app"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewDetailsResponse> {
  const result = await api.v1.betaAppReviewDetailsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewDetails/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewDetailsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppReviewDetails */
    "fields[betaAppReviewDetails]"?: (
      | "app"
      | "contactEmail"
      | "contactFirstName"
      | "contactLastName"
      | "contactPhone"
      | "demoAccountName"
      | "demoAccountPassword"
      | "demoAccountRequired"
      | "notes"
    )[];
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewDetailResponse> {
  const result = await api.v1.betaAppReviewDetailsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/betaAppReviewDetails/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BetaAppReviewDetailsUpdateInstance(
  id: string,
  /** Request body */
  data: BetaAppReviewDetailUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewDetailResponse> {
  const result = await api.v1.betaAppReviewDetailsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewDetails/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewDetailsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.betaAppReviewDetailsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewSubmissions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewSubmissionsGetCollection(
  query: {
    /** filter by attribute 'betaReviewState' */
    "filter[betaReviewState]"?: (
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "REJECTED"
      | "APPROVED"
    )[];
    /** filter by id(s) of related 'build' */
    "filter[build]": string[];
    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build")[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewSubmissionsResponse> {
  const result = await api.v1.betaAppReviewSubmissionsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaAppReviewSubmissions
 * @allowrelaxedtypes
 */
export async function postV1BetaAppReviewSubmissionsCreateInstance(
  /** Request body */
  data: BetaAppReviewSubmissionCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewSubmissionResponse> {
  const result = await api.v1.betaAppReviewSubmissionsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewSubmissions/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewSubmissionsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build")[];
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewSubmissionResponse> {
  const result = await api.v1.betaAppReviewSubmissionsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaAppReviewSubmissions/{id}/build
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaAppReviewSubmissionsBuildGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.betaAppReviewSubmissionsBuildGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaBuildLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaBuildLocalizationsGetCollection(
  query: {
    /** filter by attribute 'locale' */
    "filter[locale]"?: string[];
    /** filter by id(s) of related 'build' */
    "filter[build]"?: string[];
    /** the fields to include for returned resources of type betaBuildLocalizations */
    "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaBuildLocalizationsResponse> {
  const result = await api.v1.betaBuildLocalizationsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaBuildLocalizations
 * @allowrelaxedtypes
 */
export async function postV1BetaBuildLocalizationsCreateInstance(
  /** Request body */
  data: BetaBuildLocalizationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaBuildLocalizationResponse> {
  const result = await api.v1.betaBuildLocalizationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaBuildLocalizations/{id}
 */
export async function deleteV1BetaBuildLocalizationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaBuildLocalizationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaBuildLocalizations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaBuildLocalizationsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type betaBuildLocalizations */
    "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaBuildLocalizationResponse> {
  const result = await api.v1.betaBuildLocalizationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/betaBuildLocalizations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BetaBuildLocalizationsUpdateInstance(
  id: string,
  /** Request body */
  data: BetaBuildLocalizationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaBuildLocalizationResponse> {
  const result = await api.v1.betaBuildLocalizationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaBuildLocalizations/{id}/build
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaBuildLocalizationsBuildGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.betaBuildLocalizationsBuildGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsGetCollection(
  query: {
    /** filter by attribute 'isInternalGroup' */
    "filter[isInternalGroup]"?: string[];
    /** filter by attribute 'name' */
    "filter[name]"?: string[];
    /** filter by attribute 'publicLink' */
    "filter[publicLink]"?: string[];
    /** filter by attribute 'publicLinkEnabled' */
    "filter[publicLinkEnabled]"?: string[];
    /** filter by attribute 'publicLinkLimitEnabled' */
    "filter[publicLinkLimitEnabled]"?: string[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** filter by id(s) of related 'builds' */
    "filter[builds]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "createdDate"
      | "-createdDate"
      | "name"
      | "-name"
      | "publicLinkEnabled"
      | "-publicLinkEnabled"
      | "publicLinkLimit"
      | "-publicLinkLimit"
    )[];
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "betaTesters" | "builds")[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related betaTesters returned (when they are included) */
    "limit[betaTesters]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupsResponse> {
  const result = await api.v1.betaGroupsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaGroups
 * @allowrelaxedtypes
 */
export async function postV1BetaGroupsCreateInstance(
  /** Request body */
  data: BetaGroupCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupResponse> {
  const result = await api.v1.betaGroupsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaGroups/{id}
 */
export async function deleteV1BetaGroupsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaGroupsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("app" | "betaTesters" | "builds")[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related betaTesters returned (when they are included) */
    "limit[betaTesters]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupResponse> {
  const result = await api.v1.betaGroupsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/betaGroups/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BetaGroupsUpdateInstance(
  id: string,
  /** Request body */
  data: BetaGroupUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupResponse> {
  const result = await api.v1.betaGroupsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.betaGroupsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}/betaTesters
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsBetaTestersGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTestersResponse> {
  const result = await api.v1.betaGroupsBetaTestersGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsBuildsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildsResponse> {
  const result = await api.v1.betaGroupsBuildsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaGroups/{id}/relationships/betaTesters
 * @allowrelaxedtypes
 */
export async function deleteV1BetaGroupsBetaTestersDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BetaGroupBetaTestersLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaGroupsBetaTestersDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}/relationships/betaTesters
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsBetaTestersGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupBetaTestersLinkagesResponse> {
  const result = await api.v1.betaGroupsBetaTestersGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaGroups/{id}/relationships/betaTesters
 * @allowrelaxedtypes
 */
export async function postV1BetaGroupsBetaTestersCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BetaGroupBetaTestersLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaGroupsBetaTestersCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaGroups/{id}/relationships/builds
 * @allowrelaxedtypes
 */
export async function deleteV1BetaGroupsBuildsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BetaGroupBuildsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaGroupsBuildsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaGroups/{id}/relationships/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaGroupsBuildsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupBuildsLinkagesResponse> {
  const result = await api.v1.betaGroupsBuildsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaGroups/{id}/relationships/builds
 * @allowrelaxedtypes
 */
export async function postV1BetaGroupsBuildsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BetaGroupBuildsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaGroupsBuildsCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaLicenseAgreements
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaLicenseAgreementsGetCollection(
  query: {
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** the fields to include for returned resources of type betaLicenseAgreements */
    "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaLicenseAgreementsResponse> {
  const result = await api.v1.betaLicenseAgreementsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaLicenseAgreements/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaLicenseAgreementsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaLicenseAgreements */
    "fields[betaLicenseAgreements]"?: ("agreementText" | "app")[];
    /** comma-separated list of relationships to include */
    include?: "app"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaLicenseAgreementResponse> {
  const result = await api.v1.betaLicenseAgreementsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/betaLicenseAgreements/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BetaLicenseAgreementsUpdateInstance(
  id: string,
  /** Request body */
  data: BetaLicenseAgreementUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaLicenseAgreementResponse> {
  const result = await api.v1.betaLicenseAgreementsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaLicenseAgreements/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaLicenseAgreementsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.betaLicenseAgreementsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaTesterInvitations
 * @allowrelaxedtypes
 */
export async function postV1BetaTesterInvitationsCreateInstance(
  /** Request body */
  data: BetaTesterInvitationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterInvitationResponse> {
  const result = await api.v1.betaTesterInvitationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersGetCollection(
  query: {
    /** filter by attribute 'email' */
    "filter[email]"?: string[];
    /** filter by attribute 'firstName' */
    "filter[firstName]"?: string[];
    /** filter by attribute 'inviteType' */
    "filter[inviteType]"?: ("EMAIL" | "PUBLIC_LINK")[];
    /** filter by attribute 'lastName' */
    "filter[lastName]"?: string[];
    /** filter by id(s) of related 'apps' */
    "filter[apps]"?: string[];
    /** filter by id(s) of related 'betaGroups' */
    "filter[betaGroups]"?: string[];
    /** filter by id(s) of related 'builds' */
    "filter[builds]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "email"
      | "-email"
      | "firstName"
      | "-firstName"
      | "inviteType"
      | "-inviteType"
      | "lastName"
      | "-lastName"
    )[];
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("apps" | "betaGroups" | "builds")[];
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related apps returned (when they are included) */
    "limit[apps]"?: number;
    /** maximum number of related betaGroups returned (when they are included) */
    "limit[betaGroups]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTestersResponse> {
  const result = await api.v1.betaTestersGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaTesters
 * @allowrelaxedtypes
 */
export async function postV1BetaTestersCreateInstance(
  /** Request body */
  data: BetaTesterCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterResponse> {
  const result = await api.v1.betaTestersCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaTesters/{id}
 */
export async function deleteV1BetaTestersDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("apps" | "betaGroups" | "builds")[];
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related apps returned (when they are included) */
    "limit[apps]"?: number;
    /** maximum number of related betaGroups returned (when they are included) */
    "limit[betaGroups]"?: number;
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterResponse> {
  const result = await api.v1.betaTestersGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/apps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersAppsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppsResponse> {
  const result = await api.v1.betaTestersAppsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/betaGroups
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersBetaGroupsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaGroups */
    "fields[betaGroups]"?: (
      | "app"
      | "betaTesters"
      | "builds"
      | "createdDate"
      | "feedbackEnabled"
      | "isInternalGroup"
      | "name"
      | "publicLink"
      | "publicLinkEnabled"
      | "publicLinkId"
      | "publicLinkLimit"
      | "publicLinkLimitEnabled"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaGroupsResponse> {
  const result = await api.v1.betaTestersBetaGroupsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersBuildsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildsResponse> {
  const result = await api.v1.betaTestersBuildsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaTesters/{id}/relationships/apps
 * @allowrelaxedtypes
 */
export async function deleteV1BetaTestersAppsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BetaTesterAppsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersAppsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/relationships/apps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersAppsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterAppsLinkagesResponse> {
  const result = await api.v1.betaTestersAppsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaTesters/{id}/relationships/betaGroups
 * @allowrelaxedtypes
 */
export async function deleteV1BetaTestersBetaGroupsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BetaTesterBetaGroupsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersBetaGroupsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/relationships/betaGroups
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersBetaGroupsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterBetaGroupsLinkagesResponse> {
  const result = await api.v1.betaTestersBetaGroupsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaTesters/{id}/relationships/betaGroups
 * @allowrelaxedtypes
 */
export async function postV1BetaTestersBetaGroupsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BetaTesterBetaGroupsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersBetaGroupsCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/betaTesters/{id}/relationships/builds
 * @allowrelaxedtypes
 */
export async function deleteV1BetaTestersBuildsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BetaTesterBuildsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersBuildsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/betaTesters/{id}/relationships/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BetaTestersBuildsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTesterBuildsLinkagesResponse> {
  const result = await api.v1.betaTestersBuildsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/betaTesters/{id}/relationships/builds
 * @allowrelaxedtypes
 */
export async function postV1BetaTestersBuildsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BetaTesterBuildsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.betaTestersBuildsCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/buildBetaDetails
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildBetaDetailsGetCollection(
  query: {
    /** filter by id(s) of related 'build' */
    "filter[build]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** the fields to include for returned resources of type buildBetaDetails */
    "fields[buildBetaDetails]"?: (
      | "autoNotifyEnabled"
      | "build"
      | "externalBuildState"
      | "internalBuildState"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildBetaDetailsResponse> {
  const result = await api.v1.buildBetaDetailsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/buildBetaDetails/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildBetaDetailsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type buildBetaDetails */
    "fields[buildBetaDetails]"?: (
      | "autoNotifyEnabled"
      | "build"
      | "externalBuildState"
      | "internalBuildState"
    )[];
    /** comma-separated list of relationships to include */
    include?: "build"[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildBetaDetailResponse> {
  const result = await api.v1.buildBetaDetailsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/buildBetaDetails/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BuildBetaDetailsUpdateInstance(
  id: string,
  /** Request body */
  data: BuildBetaDetailUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BuildBetaDetailResponse> {
  const result = await api.v1.buildBetaDetailsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/buildBetaDetails/{id}/build
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildBetaDetailsBuildGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.buildBetaDetailsBuildGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/buildBetaNotifications
 * @allowrelaxedtypes
 */
export async function postV1BuildBetaNotificationsCreateInstance(
  /** Request body */
  data: BuildBetaNotificationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BuildBetaNotificationResponse> {
  const result = await api.v1.buildBetaNotificationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsGetCollection(
  query: {
    /** filter by attribute 'betaAppReviewSubmission.betaReviewState' */
    filterBetaAppReviewSubmissionBetaReviewState?: (
      | "WAITING_FOR_REVIEW"
      | "IN_REVIEW"
      | "REJECTED"
      | "APPROVED"
    )[];
    /** filter by attribute 'expired' */
    "filter[expired]"?: string[];
    /** filter by attribute 'preReleaseVersion.platform' */
    filterPreReleaseVersionPlatform?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'preReleaseVersion.version' */
    filterPreReleaseVersionVersion?: string[];
    /** filter by attribute 'processingState' */
    "filter[processingState]"?: (
      | "PROCESSING"
      | "FAILED"
      | "INVALID"
      | "VALID"
    )[];
    /** filter by attribute 'usesNonExemptEncryption' */
    "filter[usesNonExemptEncryption]"?: string[];
    /** filter by attribute 'version' */
    "filter[version]"?: string[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** filter by id(s) of related 'appStoreVersion' */
    "filter[appStoreVersion]"?: string[];
    /** filter by id(s) of related 'betaGroups' */
    "filter[betaGroups]"?: string[];
    /** filter by id(s) of related 'preReleaseVersion' */
    "filter[preReleaseVersion]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "preReleaseVersion"
      | "-preReleaseVersion"
      | "uploadedDate"
      | "-uploadedDate"
      | "version"
      | "-version"
    )[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "buildBetaDetail"
      | "icons"
      | "individualTesters"
      | "preReleaseVersion"
    )[];
    /** the fields to include for returned resources of type appEncryptionDeclarations */
    "fields[appEncryptionDeclarations]"?: (
      | "app"
      | "appEncryptionDeclarationState"
      | "availableOnFrenchStore"
      | "builds"
      | "codeValue"
      | "containsProprietaryCryptography"
      | "containsThirdPartyCryptography"
      | "documentName"
      | "documentType"
      | "documentUrl"
      | "exempt"
      | "platform"
      | "uploadedDate"
      | "usesEncryption"
    )[];
    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build")[];
    /** the fields to include for returned resources of type buildBetaDetails */
    "fields[buildBetaDetails]"?: (
      | "autoNotifyEnabled"
      | "build"
      | "externalBuildState"
      | "internalBuildState"
    )[];
    /** the fields to include for returned resources of type buildIcons */
    "fields[buildIcons]"?: ("iconAsset" | "iconType")[];
    /** the fields to include for returned resources of type perfPowerMetrics */
    "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type diagnosticSignatures */
    "fields[diagnosticSignatures]"?: (
      | "diagnosticType"
      | "logs"
      | "signature"
      | "weight"
    )[];
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** the fields to include for returned resources of type betaBuildLocalizations */
    "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related betaBuildLocalizations returned (when they are included) */
    "limit[betaBuildLocalizations]"?: number;
    /** maximum number of related icons returned (when they are included) */
    "limit[icons]"?: number;
    /** maximum number of related individualTesters returned (when they are included) */
    "limit[individualTesters]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildsResponse> {
  const result = await api.v1.buildsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** comma-separated list of relationships to include */
    include?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "buildBetaDetail"
      | "icons"
      | "individualTesters"
      | "preReleaseVersion"
    )[];
    /** the fields to include for returned resources of type appEncryptionDeclarations */
    "fields[appEncryptionDeclarations]"?: (
      | "app"
      | "appEncryptionDeclarationState"
      | "availableOnFrenchStore"
      | "builds"
      | "codeValue"
      | "containsProprietaryCryptography"
      | "containsThirdPartyCryptography"
      | "documentName"
      | "documentType"
      | "documentUrl"
      | "exempt"
      | "platform"
      | "uploadedDate"
      | "usesEncryption"
    )[];
    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build")[];
    /** the fields to include for returned resources of type buildBetaDetails */
    "fields[buildBetaDetails]"?: (
      | "autoNotifyEnabled"
      | "build"
      | "externalBuildState"
      | "internalBuildState"
    )[];
    /** the fields to include for returned resources of type buildIcons */
    "fields[buildIcons]"?: ("iconAsset" | "iconType")[];
    /** the fields to include for returned resources of type perfPowerMetrics */
    "fields[perfPowerMetrics]"?: ("deviceType" | "metricType" | "platform")[];
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type diagnosticSignatures */
    "fields[diagnosticSignatures]"?: (
      | "diagnosticType"
      | "logs"
      | "signature"
      | "weight"
    )[];
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** the fields to include for returned resources of type betaBuildLocalizations */
    "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related betaBuildLocalizations returned (when they are included) */
    "limit[betaBuildLocalizations]"?: number;
    /** maximum number of related icons returned (when they are included) */
    "limit[icons]"?: number;
    /** maximum number of related individualTesters returned (when they are included) */
    "limit[individualTesters]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.buildsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/builds/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BuildsUpdateInstance(
  id: string,
  /** Request body */
  data: BuildUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BuildResponse> {
  const result = await api.v1.buildsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.buildsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/appEncryptionDeclaration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsAppEncryptionDeclarationGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appEncryptionDeclarations */
    "fields[appEncryptionDeclarations]"?: (
      | "app"
      | "appEncryptionDeclarationState"
      | "availableOnFrenchStore"
      | "builds"
      | "codeValue"
      | "containsProprietaryCryptography"
      | "containsThirdPartyCryptography"
      | "documentName"
      | "documentType"
      | "documentUrl"
      | "exempt"
      | "platform"
      | "uploadedDate"
      | "usesEncryption"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppEncryptionDeclarationResponse> {
  const result = await api.v1.buildsAppEncryptionDeclarationGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/appStoreVersion
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsAppStoreVersionGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type appStoreVersions */
    "fields[appStoreVersions]"?: (
      | "ageRatingDeclaration"
      | "app"
      | "appStoreReviewDetail"
      | "appStoreState"
      | "appStoreVersionLocalizations"
      | "appStoreVersionPhasedRelease"
      | "appStoreVersionSubmission"
      | "build"
      | "copyright"
      | "createdDate"
      | "downloadable"
      | "earliestReleaseDate"
      | "idfaDeclaration"
      | "platform"
      | "releaseType"
      | "routingAppCoverage"
      | "usesIdfa"
      | "versionString"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppStoreVersionResponse> {
  const result = await api.v1.buildsAppStoreVersionGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/betaAppReviewSubmission
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsBetaAppReviewSubmissionGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    "fields[betaAppReviewSubmissions]"?: ("betaReviewState" | "build")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaAppReviewSubmissionResponse> {
  const result = await api.v1.buildsBetaAppReviewSubmissionGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/betaBuildLocalizations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsBetaBuildLocalizationsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaBuildLocalizations */
    "fields[betaBuildLocalizations]"?: ("build" | "locale" | "whatsNew")[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaBuildLocalizationsResponse> {
  const result = await api.v1.buildsBetaBuildLocalizationsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/buildBetaDetail
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsBuildBetaDetailGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type buildBetaDetails */
    "fields[buildBetaDetails]"?: (
      | "autoNotifyEnabled"
      | "build"
      | "externalBuildState"
      | "internalBuildState"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildBetaDetailResponse> {
  const result = await api.v1.buildsBuildBetaDetailGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/diagnosticSignatures
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsDiagnosticSignaturesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'diagnosticType' */
    "filter[diagnosticType]"?: "DISK_WRITES"[];
    /** the fields to include for returned resources of type diagnosticSignatures */
    "fields[diagnosticSignatures]"?: (
      | "diagnosticType"
      | "logs"
      | "signature"
      | "weight"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DiagnosticSignaturesResponse> {
  const result = await api.v1.buildsDiagnosticSignaturesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/icons
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsIconsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type buildIcons */
    "fields[buildIcons]"?: ("iconAsset" | "iconType")[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildIconsResponse> {
  const result = await api.v1.buildsIconsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/individualTesters
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsIndividualTestersGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type betaTesters */
    "fields[betaTesters]"?: (
      | "apps"
      | "betaGroups"
      | "builds"
      | "email"
      | "firstName"
      | "inviteType"
      | "lastName"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BetaTestersResponse> {
  const result = await api.v1.buildsIndividualTestersGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/perfPowerMetrics
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsPerfPowerMetricsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'deviceType' */
    "filter[deviceType]"?: string[];
    /** filter by attribute 'metricType' */
    "filter[metricType]"?: (
      | "DISK"
      | "HANG"
      | "BATTERY"
      | "LAUNCH"
      | "MEMORY"
      | "ANIMATION"
      | "TERMINATION"
    )[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: "IOS"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PerfPowerMetricsResponse> {
  const result = await api.v1.buildsPerfPowerMetricsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/preReleaseVersion
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsPreReleaseVersionGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PrereleaseVersionResponse> {
  const result = await api.v1.buildsPreReleaseVersionGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/relationships/appEncryptionDeclaration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsAppEncryptionDeclarationGetToOneRelationship(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<BuildAppEncryptionDeclarationLinkageResponse> {
  const result =
    await api.v1.buildsAppEncryptionDeclarationGetToOneRelationship({
      id: id,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/builds/{id}/relationships/appEncryptionDeclaration
 * @allowrelaxedtypes
 */
export async function patchV1BuildsAppEncryptionDeclarationUpdateToOneRelationship(
  id: string,
  /** Request body */
  data: BuildAppEncryptionDeclarationLinkageRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.buildsAppEncryptionDeclarationUpdateToOneRelationship({
      id: id,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/builds/{id}/relationships/betaGroups
 * @allowrelaxedtypes
 */
export async function deleteV1BuildsBetaGroupsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BuildBetaGroupsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.buildsBetaGroupsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/builds/{id}/relationships/betaGroups
 * @allowrelaxedtypes
 */
export async function postV1BuildsBetaGroupsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BuildBetaGroupsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.buildsBetaGroupsCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/builds/{id}/relationships/individualTesters
 * @allowrelaxedtypes
 */
export async function deleteV1BuildsIndividualTestersDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: BuildIndividualTestersLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.buildsIndividualTestersDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/builds/{id}/relationships/individualTesters
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BuildsIndividualTestersGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildIndividualTestersLinkagesResponse> {
  const result = await api.v1.buildsIndividualTestersGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/builds/{id}/relationships/individualTesters
 * @allowrelaxedtypes
 */
export async function postV1BuildsIndividualTestersCreateToManyRelationship(
  id: string,
  /** Request body */
  data: BuildIndividualTestersLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.buildsIndividualTestersCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/bundleIdCapabilities
 * @allowrelaxedtypes
 */
export async function postV1BundleIdCapabilitiesCreateInstance(
  /** Request body */
  data: BundleIdCapabilityCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdCapabilityResponse> {
  const result = await api.v1.bundleIdCapabilitiesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/bundleIdCapabilities/{id}
 */
export async function deleteV1BundleIdCapabilitiesDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.bundleIdCapabilitiesDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/bundleIdCapabilities/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BundleIdCapabilitiesUpdateInstance(
  id: string,
  /** Request body */
  data: BundleIdCapabilityUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdCapabilityResponse> {
  const result = await api.v1.bundleIdCapabilitiesUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/bundleIds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BundleIdsGetCollection(
  query: {
    /** filter by attribute 'identifier' */
    "filter[identifier]"?: string[];
    /** filter by attribute 'name' */
    "filter[name]"?: string[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS")[];
    /** filter by attribute 'seedId' */
    "filter[seedId]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "id"
      | "-id"
      | "identifier"
      | "-identifier"
      | "name"
      | "-name"
      | "platform"
      | "-platform"
      | "seedId"
      | "-seedId"
    )[];
    /** the fields to include for returned resources of type bundleIds */
    "fields[bundleIds]"?: (
      | "app"
      | "bundleIdCapabilities"
      | "identifier"
      | "name"
      | "platform"
      | "profiles"
      | "seedId"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "bundleIdCapabilities" | "profiles")[];
    /** the fields to include for returned resources of type bundleIdCapabilities */
    "fields[bundleIdCapabilities]"?: (
      | "bundleId"
      | "capabilityType"
      | "settings"
    )[];
    /** the fields to include for returned resources of type profiles */
    "fields[profiles]"?: (
      | "bundleId"
      | "certificates"
      | "createdDate"
      | "devices"
      | "expirationDate"
      | "name"
      | "platform"
      | "profileContent"
      | "profileState"
      | "profileType"
      | "uuid"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related bundleIdCapabilities returned (when they are included) */
    "limit[bundleIdCapabilities]"?: number;
    /** maximum number of related profiles returned (when they are included) */
    "limit[profiles]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdsResponse> {
  const result = await api.v1.bundleIdsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/bundleIds
 * @allowrelaxedtypes
 */
export async function postV1BundleIdsCreateInstance(
  /** Request body */
  data: BundleIdCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdResponse> {
  const result = await api.v1.bundleIdsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/bundleIds/{id}
 */
export async function deleteV1BundleIdsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.bundleIdsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/bundleIds/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BundleIdsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type bundleIds */
    "fields[bundleIds]"?: (
      | "app"
      | "bundleIdCapabilities"
      | "identifier"
      | "name"
      | "platform"
      | "profiles"
      | "seedId"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("app" | "bundleIdCapabilities" | "profiles")[];
    /** the fields to include for returned resources of type bundleIdCapabilities */
    "fields[bundleIdCapabilities]"?: (
      | "bundleId"
      | "capabilityType"
      | "settings"
    )[];
    /** the fields to include for returned resources of type profiles */
    "fields[profiles]"?: (
      | "bundleId"
      | "certificates"
      | "createdDate"
      | "devices"
      | "expirationDate"
      | "name"
      | "platform"
      | "profileContent"
      | "profileState"
      | "profileType"
      | "uuid"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related bundleIdCapabilities returned (when they are included) */
    "limit[bundleIdCapabilities]"?: number;
    /** maximum number of related profiles returned (when they are included) */
    "limit[profiles]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdResponse> {
  const result = await api.v1.bundleIdsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/bundleIds/{id}
 * @allowrelaxedtypes
 */
export async function patchV1BundleIdsUpdateInstance(
  id: string,
  /** Request body */
  data: BundleIdUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdResponse> {
  const result = await api.v1.bundleIdsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/bundleIds/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BundleIdsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.bundleIdsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/bundleIds/{id}/bundleIdCapabilities
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BundleIdsBundleIdCapabilitiesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type bundleIdCapabilities */
    "fields[bundleIdCapabilities]"?: (
      | "bundleId"
      | "capabilityType"
      | "settings"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdCapabilitiesResponse> {
  const result = await api.v1.bundleIdsBundleIdCapabilitiesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/bundleIds/{id}/profiles
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1BundleIdsProfilesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type profiles */
    "fields[profiles]"?: (
      | "bundleId"
      | "certificates"
      | "createdDate"
      | "devices"
      | "expirationDate"
      | "name"
      | "platform"
      | "profileContent"
      | "profileState"
      | "profileType"
      | "uuid"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ProfilesResponse> {
  const result = await api.v1.bundleIdsProfilesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/certificates
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1CertificatesGetCollection(
  query: {
    /** filter by attribute 'certificateType' */
    "filter[certificateType]"?: (
      | "IOS_DEVELOPMENT"
      | "IOS_DISTRIBUTION"
      | "MAC_APP_DISTRIBUTION"
      | "MAC_INSTALLER_DISTRIBUTION"
      | "MAC_APP_DEVELOPMENT"
      | "DEVELOPER_ID_KEXT"
      | "DEVELOPER_ID_APPLICATION"
      | "DEVELOPMENT"
      | "DISTRIBUTION"
    )[];
    /** filter by attribute 'displayName' */
    "filter[displayName]"?: string[];
    /** filter by attribute 'serialNumber' */
    "filter[serialNumber]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "certificateType"
      | "-certificateType"
      | "displayName"
      | "-displayName"
      | "id"
      | "-id"
      | "serialNumber"
      | "-serialNumber"
    )[];
    /** the fields to include for returned resources of type certificates */
    "fields[certificates]"?: (
      | "certificateContent"
      | "certificateType"
      | "csrContent"
      | "displayName"
      | "expirationDate"
      | "name"
      | "platform"
      | "serialNumber"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<CertificatesResponse> {
  const result = await api.v1.certificatesGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/certificates
 * @allowrelaxedtypes
 */
export async function postV1CertificatesCreateInstance(
  /** Request body */
  data: CertificateCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<CertificateResponse> {
  const result = await api.v1.certificatesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/certificates/{id}
 */
export async function deleteV1CertificatesDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.certificatesDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/certificates/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1CertificatesGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type certificates */
    "fields[certificates]"?: (
      | "certificateContent"
      | "certificateType"
      | "csrContent"
      | "displayName"
      | "expirationDate"
      | "name"
      | "platform"
      | "serialNumber"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<CertificateResponse> {
  const result = await api.v1.certificatesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/devices
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1DevicesGetCollection(
  query: {
    /** filter by attribute 'name' */
    "filter[name]"?: string[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS")[];
    /** filter by attribute 'status' */
    "filter[status]"?: ("ENABLED" | "DISABLED")[];
    /** filter by attribute 'udid' */
    "filter[udid]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "id"
      | "-id"
      | "name"
      | "-name"
      | "platform"
      | "-platform"
      | "status"
      | "-status"
      | "udid"
      | "-udid"
    )[];
    /** the fields to include for returned resources of type devices */
    "fields[devices]"?: (
      | "addedDate"
      | "deviceClass"
      | "model"
      | "name"
      | "platform"
      | "status"
      | "udid"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DevicesResponse> {
  const result = await api.v1.devicesGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/devices
 * @allowrelaxedtypes
 */
export async function postV1DevicesCreateInstance(
  /** Request body */
  data: DeviceCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<DeviceResponse> {
  const result = await api.v1.devicesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/devices/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1DevicesGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type devices */
    "fields[devices]"?: (
      | "addedDate"
      | "deviceClass"
      | "model"
      | "name"
      | "platform"
      | "status"
      | "udid"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DeviceResponse> {
  const result = await api.v1.devicesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/devices/{id}
 * @allowrelaxedtypes
 */
export async function patchV1DevicesUpdateInstance(
  id: string,
  /** Request body */
  data: DeviceUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<DeviceResponse> {
  const result = await api.v1.devicesUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/diagnosticSignatures/{id}/logs
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1DiagnosticSignaturesLogsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DiagnosticLogsResponse> {
  const result = await api.v1.diagnosticSignaturesLogsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/endUserLicenseAgreements
 * @allowrelaxedtypes
 */
export async function postV1EndUserLicenseAgreementsCreateInstance(
  /** Request body */
  data: EndUserLicenseAgreementCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<EndUserLicenseAgreementResponse> {
  const result = await api.v1.endUserLicenseAgreementsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/endUserLicenseAgreements/{id}
 */
export async function deleteV1EndUserLicenseAgreementsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.endUserLicenseAgreementsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/endUserLicenseAgreements/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1EndUserLicenseAgreementsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type endUserLicenseAgreements */
    "fields[endUserLicenseAgreements]"?: (
      | "agreementText"
      | "app"
      | "territories"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("app" | "territories")[];
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** maximum number of related territories returned (when they are included) */
    "limit[territories]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<EndUserLicenseAgreementResponse> {
  const result = await api.v1.endUserLicenseAgreementsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/endUserLicenseAgreements/{id}
 * @allowrelaxedtypes
 */
export async function patchV1EndUserLicenseAgreementsUpdateInstance(
  id: string,
  /** Request body */
  data: EndUserLicenseAgreementUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<EndUserLicenseAgreementResponse> {
  const result = await api.v1.endUserLicenseAgreementsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/endUserLicenseAgreements/{id}/territories
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1EndUserLicenseAgreementsTerritoriesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<TerritoriesResponse> {
  const result =
    await api.v1.endUserLicenseAgreementsTerritoriesGetToManyRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/financeReports
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1FinanceReportsGetCollection(
  query: {
    /** filter by attribute 'regionCode' */
    "filter[regionCode]": string[];
    /** filter by attribute 'reportDate' */
    "filter[reportDate]": string[];
    /** filter by attribute 'reportType' */
    "filter[reportType]": ("FINANCIAL" | "FINANCE_DETAIL")[];
    /** filter by attribute 'vendorNumber' */
    "filter[vendorNumber]": string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<File> {
  const result = await api.v1.financeReportsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/gameCenterEnabledVersions/{id}/compatibleVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'versionString' */
    "filter[versionString]"?: string[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("versionString" | "-versionString")[];
    /** the fields to include for returned resources of type gameCenterEnabledVersions */
    "fields[gameCenterEnabledVersions]"?: (
      | "app"
      | "compatibleVersions"
      | "iconAsset"
      | "platform"
      | "versionString"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "compatibleVersions")[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<GameCenterEnabledVersionsResponse> {
  const result =
    await api.v1.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelated({
      id: id,
      query: query,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
 * @allowrelaxedtypes
 */
export async function deleteV1GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.gameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(
      {
        id: id,
        data: data,
        params: {
          headers: (headers?.value as Record<string, string>) ?? undefined,
        },
      },
    );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<GameCenterEnabledVersionCompatibleVersionsLinkagesResponse> {
  const result =
    await api.v1.gameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(
      {
        id: id,
        query: query,
        params: {
          headers: (headers?.value as Record<string, string>) ?? undefined,
        },
      },
    );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
 * @allowrelaxedtypes
 */
export async function patchV1GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(
  id: string,
  /** Request body */
  data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.gameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(
      {
        id: id,
        data: data,
        params: {
          headers: (headers?.value as Record<string, string>) ?? undefined,
        },
      },
    );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions
 * @allowrelaxedtypes
 */
export async function postV1GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.v1.gameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(
      {
        id: id,
        data: data,
        params: {
          headers: (headers?.value as Record<string, string>) ?? undefined,
        },
      },
    );
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/idfaDeclarations
 * @allowrelaxedtypes
 */
export async function postV1IdfaDeclarationsCreateInstance(
  /** Request body */
  data: IdfaDeclarationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<IdfaDeclarationResponse> {
  const result = await api.v1.idfaDeclarationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/idfaDeclarations/{id}
 */
export async function deleteV1IdfaDeclarationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.idfaDeclarationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/idfaDeclarations/{id}
 * @allowrelaxedtypes
 */
export async function patchV1IdfaDeclarationsUpdateInstance(
  id: string,
  /** Request body */
  data: IdfaDeclarationUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<IdfaDeclarationResponse> {
  const result = await api.v1.idfaDeclarationsUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/inAppPurchases/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1InAppPurchasesGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type inAppPurchases */
    "fields[inAppPurchases]"?: (
      | "apps"
      | "inAppPurchaseType"
      | "productId"
      | "referenceName"
      | "state"
    )[];
    /** comma-separated list of relationships to include */
    include?: "apps"[];
    /** maximum number of related apps returned (when they are included) */
    "limit[apps]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<InAppPurchaseResponse> {
  const result = await api.v1.inAppPurchasesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/preReleaseVersions
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1PreReleaseVersionsGetCollection(
  query: {
    /** filter by attribute 'builds.expired' */
    filterBuildsExpired?: string[];
    /** filter by attribute 'builds.processingState' */
    filterBuildsProcessingState?: (
      | "PROCESSING"
      | "FAILED"
      | "INVALID"
      | "VALID"
    )[];
    /** filter by attribute 'platform' */
    "filter[platform]"?: ("IOS" | "MAC_OS" | "TV_OS")[];
    /** filter by attribute 'version' */
    "filter[version]"?: string[];
    /** filter by id(s) of related 'app' */
    "filter[app]"?: string[];
    /** filter by id(s) of related 'builds' */
    "filter[builds]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("version" | "-version")[];
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("app" | "builds")[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PreReleaseVersionsResponse> {
  const result = await api.v1.preReleaseVersionsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/preReleaseVersions/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1PreReleaseVersionsGetInstance(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type preReleaseVersions */
    "fields[preReleaseVersions]"?: (
      | "app"
      | "builds"
      | "platform"
      | "version"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("app" | "builds")[];
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related builds returned (when they are included) */
    "limit[builds]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PrereleaseVersionResponse> {
  const result = await api.v1.preReleaseVersionsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/preReleaseVersions/{id}/app
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1PreReleaseVersionsAppGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppResponse> {
  const result = await api.v1.preReleaseVersionsAppGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/preReleaseVersions/{id}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1PreReleaseVersionsBuildsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type builds */
    "fields[builds]"?: (
      | "app"
      | "appEncryptionDeclaration"
      | "appStoreVersion"
      | "betaAppReviewSubmission"
      | "betaBuildLocalizations"
      | "betaGroups"
      | "buildBetaDetail"
      | "diagnosticSignatures"
      | "expirationDate"
      | "expired"
      | "iconAssetToken"
      | "icons"
      | "individualTesters"
      | "minOsVersion"
      | "perfPowerMetrics"
      | "preReleaseVersion"
      | "processingState"
      | "uploadedDate"
      | "usesNonExemptEncryption"
      | "version"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BuildsResponse> {
  const result = await api.v1.preReleaseVersionsBuildsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/profiles
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1ProfilesGetCollection(
  query: {
    /** filter by attribute 'name' */
    "filter[name]"?: string[];
    /** filter by attribute 'profileState' */
    "filter[profileState]"?: ("ACTIVE" | "INVALID")[];
    /** filter by attribute 'profileType' */
    "filter[profileType]"?: (
      | "IOS_APP_DEVELOPMENT"
      | "IOS_APP_STORE"
      | "IOS_APP_ADHOC"
      | "IOS_APP_INHOUSE"
      | "MAC_APP_DEVELOPMENT"
      | "MAC_APP_STORE"
      | "MAC_APP_DIRECT"
      | "TVOS_APP_DEVELOPMENT"
      | "TVOS_APP_STORE"
      | "TVOS_APP_ADHOC"
      | "TVOS_APP_INHOUSE"
      | "MAC_CATALYST_APP_DEVELOPMENT"
      | "MAC_CATALYST_APP_STORE"
      | "MAC_CATALYST_APP_DIRECT"
    )[];
    /** filter by id(s) */
    "filter[id]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: (
      | "id"
      | "-id"
      | "name"
      | "-name"
      | "profileState"
      | "-profileState"
      | "profileType"
      | "-profileType"
    )[];
    /** the fields to include for returned resources of type profiles */
    "fields[profiles]"?: (
      | "bundleId"
      | "certificates"
      | "createdDate"
      | "devices"
      | "expirationDate"
      | "name"
      | "platform"
      | "profileContent"
      | "profileState"
      | "profileType"
      | "uuid"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: ("bundleId" | "certificates" | "devices")[];
    /** the fields to include for returned resources of type certificates */
    "fields[certificates]"?: (
      | "certificateContent"
      | "certificateType"
      | "csrContent"
      | "displayName"
      | "expirationDate"
      | "name"
      | "platform"
      | "serialNumber"
    )[];
    /** the fields to include for returned resources of type devices */
    "fields[devices]"?: (
      | "addedDate"
      | "deviceClass"
      | "model"
      | "name"
      | "platform"
      | "status"
      | "udid"
    )[];
    /** the fields to include for returned resources of type bundleIds */
    "fields[bundleIds]"?: (
      | "app"
      | "bundleIdCapabilities"
      | "identifier"
      | "name"
      | "platform"
      | "profiles"
      | "seedId"
    )[];
    /** maximum number of related certificates returned (when they are included) */
    "limit[certificates]"?: number;
    /** maximum number of related devices returned (when they are included) */
    "limit[devices]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ProfilesResponse> {
  const result = await api.v1.profilesGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/profiles
 * @allowrelaxedtypes
 */
export async function postV1ProfilesCreateInstance(
  /** Request body */
  data: ProfileCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<ProfileResponse> {
  const result = await api.v1.profilesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/profiles/{id}
 */
export async function deleteV1ProfilesDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.profilesDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/profiles/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1ProfilesGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type profiles */
    "fields[profiles]"?: (
      | "bundleId"
      | "certificates"
      | "createdDate"
      | "devices"
      | "expirationDate"
      | "name"
      | "platform"
      | "profileContent"
      | "profileState"
      | "profileType"
      | "uuid"
    )[];
    /** comma-separated list of relationships to include */
    include?: ("bundleId" | "certificates" | "devices")[];
    /** the fields to include for returned resources of type certificates */
    "fields[certificates]"?: (
      | "certificateContent"
      | "certificateType"
      | "csrContent"
      | "displayName"
      | "expirationDate"
      | "name"
      | "platform"
      | "serialNumber"
    )[];
    /** the fields to include for returned resources of type devices */
    "fields[devices]"?: (
      | "addedDate"
      | "deviceClass"
      | "model"
      | "name"
      | "platform"
      | "status"
      | "udid"
    )[];
    /** the fields to include for returned resources of type bundleIds */
    "fields[bundleIds]"?: (
      | "app"
      | "bundleIdCapabilities"
      | "identifier"
      | "name"
      | "platform"
      | "profiles"
      | "seedId"
    )[];
    /** maximum number of related certificates returned (when they are included) */
    "limit[certificates]"?: number;
    /** maximum number of related devices returned (when they are included) */
    "limit[devices]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ProfileResponse> {
  const result = await api.v1.profilesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/profiles/{id}/bundleId
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1ProfilesBundleIdGetToOneRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type bundleIds */
    "fields[bundleIds]"?: (
      | "app"
      | "bundleIdCapabilities"
      | "identifier"
      | "name"
      | "platform"
      | "profiles"
      | "seedId"
    )[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<BundleIdResponse> {
  const result = await api.v1.profilesBundleIdGetToOneRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/profiles/{id}/certificates
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1ProfilesCertificatesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type certificates */
    "fields[certificates]"?: (
      | "certificateContent"
      | "certificateType"
      | "csrContent"
      | "displayName"
      | "expirationDate"
      | "name"
      | "platform"
      | "serialNumber"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<CertificatesResponse> {
  const result = await api.v1.profilesCertificatesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/profiles/{id}/devices
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1ProfilesDevicesGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type devices */
    "fields[devices]"?: (
      | "addedDate"
      | "deviceClass"
      | "model"
      | "name"
      | "platform"
      | "status"
      | "udid"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DevicesResponse> {
  const result = await api.v1.profilesDevicesGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/routingAppCoverages
 * @allowrelaxedtypes
 */
export async function postV1RoutingAppCoveragesCreateInstance(
  /** Request body */
  data: RoutingAppCoverageCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<RoutingAppCoverageResponse> {
  const result = await api.v1.routingAppCoveragesCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/routingAppCoverages/{id}
 */
export async function deleteV1RoutingAppCoveragesDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.routingAppCoveragesDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/routingAppCoverages/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1RoutingAppCoveragesGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type routingAppCoverages */
    "fields[routingAppCoverages]"?: (
      | "appStoreVersion"
      | "assetDeliveryState"
      | "fileName"
      | "fileSize"
      | "sourceFileChecksum"
      | "uploadOperations"
      | "uploaded"
    )[];
    /** comma-separated list of relationships to include */
    include?: "appStoreVersion"[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<RoutingAppCoverageResponse> {
  const result = await api.v1.routingAppCoveragesGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/routingAppCoverages/{id}
 * @allowrelaxedtypes
 */
export async function patchV1RoutingAppCoveragesUpdateInstance(
  id: string,
  /** Request body */
  data: RoutingAppCoverageUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<RoutingAppCoverageResponse> {
  const result = await api.v1.routingAppCoveragesUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/salesReports
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1SalesReportsGetCollection(
  query: {
    /** filter by attribute 'frequency' */
    "filter[frequency]": ("DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY")[];
    /** filter by attribute 'reportDate' */
    "filter[reportDate]"?: string[];
    /** filter by attribute 'reportSubType' */
    "filter[reportSubType]": ("SUMMARY" | "DETAILED" | "OPT_IN")[];
    /** filter by attribute 'reportType' */
    "filter[reportType]": (
      | "SALES"
      | "PRE_ORDER"
      | "NEWSSTAND"
      | "SUBSCRIPTION"
      | "SUBSCRIPTION_EVENT"
      | "SUBSCRIBER"
    )[];
    /** filter by attribute 'vendorNumber' */
    "filter[vendorNumber]": string[];
    /** filter by attribute 'version' */
    "filter[version]"?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<File> {
  const result = await api.v1.salesReportsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/territories
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1TerritoriesGetCollection(
  query: {
    /** the fields to include for returned resources of type territories */
    "fields[territories]"?: "currency"[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<TerritoriesResponse> {
  const result = await api.v1.territoriesGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/userInvitations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UserInvitationsGetCollection(
  query: {
    /** filter by attribute 'email' */
    "filter[email]"?: string[];
    /** filter by attribute 'roles' */
    "filter[roles]"?: (
      | "ADMIN"
      | "FINANCE"
      | "TECHNICAL"
      | "ACCOUNT_HOLDER"
      | "READ_ONLY"
      | "SALES"
      | "MARKETING"
      | "APP_MANAGER"
      | "DEVELOPER"
      | "ACCESS_TO_REPORTS"
      | "CUSTOMER_SUPPORT"
      | "CREATE_APPS"
      | "CLOUD_MANAGED_DEVELOPER_ID"
      | "CLOUD_MANAGED_APP_DISTRIBUTION"
    )[];
    /** filter by id(s) of related 'visibleApps' */
    "filter[visibleApps]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("email" | "-email" | "lastName" | "-lastName")[];
    /** the fields to include for returned resources of type userInvitations */
    "fields[userInvitations]"?: (
      | "allAppsVisible"
      | "email"
      | "expirationDate"
      | "firstName"
      | "lastName"
      | "provisioningAllowed"
      | "roles"
      | "visibleApps"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "visibleApps"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related visibleApps returned (when they are included) */
    "limit[visibleApps]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UserInvitationsResponse> {
  const result = await api.v1.userInvitationsGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/userInvitations
 * @allowrelaxedtypes
 */
export async function postV1UserInvitationsCreateInstance(
  /** Request body */
  data: UserInvitationCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<UserInvitationResponse> {
  const result = await api.v1.userInvitationsCreateInstance({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/userInvitations/{id}
 */
export async function deleteV1UserInvitationsDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.userInvitationsDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/userInvitations/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UserInvitationsGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type userInvitations */
    "fields[userInvitations]"?: (
      | "allAppsVisible"
      | "email"
      | "expirationDate"
      | "firstName"
      | "lastName"
      | "provisioningAllowed"
      | "roles"
      | "visibleApps"
    )[];
    /** comma-separated list of relationships to include */
    include?: "visibleApps"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related visibleApps returned (when they are included) */
    "limit[visibleApps]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UserInvitationResponse> {
  const result = await api.v1.userInvitationsGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/userInvitations/{id}/visibleApps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UserInvitationsVisibleAppsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppsResponse> {
  const result = await api.v1.userInvitationsVisibleAppsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/users
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UsersGetCollection(
  query: {
    /** filter by attribute 'roles' */
    "filter[roles]"?: (
      | "ADMIN"
      | "FINANCE"
      | "TECHNICAL"
      | "ACCOUNT_HOLDER"
      | "READ_ONLY"
      | "SALES"
      | "MARKETING"
      | "APP_MANAGER"
      | "DEVELOPER"
      | "ACCESS_TO_REPORTS"
      | "CUSTOMER_SUPPORT"
      | "CREATE_APPS"
      | "CLOUD_MANAGED_DEVELOPER_ID"
      | "CLOUD_MANAGED_APP_DISTRIBUTION"
    )[];
    /** filter by attribute 'username' */
    "filter[username]"?: string[];
    /** filter by id(s) of related 'visibleApps' */
    "filter[visibleApps]"?: string[];
    /** comma-separated list of sort expressions; resources will be sorted as specified */
    sort?: ("lastName" | "-lastName" | "username" | "-username")[];
    /** the fields to include for returned resources of type users */
    "fields[users]"?: (
      | "allAppsVisible"
      | "firstName"
      | "lastName"
      | "provisioningAllowed"
      | "roles"
      | "username"
      | "visibleApps"
    )[];
    /** maximum resources per page */
    limit?: number;
    /** comma-separated list of relationships to include */
    include?: "visibleApps"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related visibleApps returned (when they are included) */
    "limit[visibleApps]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UsersResponse> {
  const result = await api.v1.usersGetCollection({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/users/{id}
 */
export async function deleteV1UsersDeleteInstance(
  /** the id of the requested resource */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.usersDeleteInstance({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/users/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UsersGetInstance(
  id: string,
  query: {
    /** the fields to include for returned resources of type users */
    "fields[users]"?: (
      | "allAppsVisible"
      | "firstName"
      | "lastName"
      | "provisioningAllowed"
      | "roles"
      | "username"
      | "visibleApps"
    )[];
    /** comma-separated list of relationships to include */
    include?: "visibleApps"[];
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum number of related visibleApps returned (when they are included) */
    "limit[visibleApps]"?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UserResponse> {
  const result = await api.v1.usersGetInstance({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/users/{id}
 * @allowrelaxedtypes
 */
export async function patchV1UsersUpdateInstance(
  id: string,
  /** Request body */
  data: UserUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<UserResponse> {
  const result = await api.v1.usersUpdateInstance({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request DELETE :/v1/users/{id}/relationships/visibleApps
 * @allowrelaxedtypes
 */
export async function deleteV1UsersVisibleAppsDeleteToManyRelationship(
  /** the id of the requested resource */
  id: string,
  /** Request body */
  data: UserVisibleAppsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.usersVisibleAppsDeleteToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/users/{id}/relationships/visibleApps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UsersVisibleAppsGetToManyRelationship(
  id: string,
  query: {
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UserVisibleAppsLinkagesResponse> {
  const result = await api.v1.usersVisibleAppsGetToManyRelationship({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request PATCH :/v1/users/{id}/relationships/visibleApps
 * @allowrelaxedtypes
 */
export async function patchV1UsersVisibleAppsReplaceToManyRelationship(
  id: string,
  /** Request body */
  data: UserVisibleAppsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.usersVisibleAppsReplaceToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request POST :/v1/users/{id}/relationships/visibleApps
 * @allowrelaxedtypes
 */
export async function postV1UsersVisibleAppsCreateToManyRelationship(
  id: string,
  /** Request body */
  data: UserVisibleAppsLinkagesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v1.usersVisibleAppsCreateToManyRelationship({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * @request GET :/v1/users/{id}/visibleApps
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV1UsersVisibleAppsGetToManyRelated(
  /** the id of the requested resource */
  id: string,
  query: {
    /** the fields to include for returned resources of type apps */
    "fields[apps]"?: (
      | "appInfos"
      | "appStoreVersions"
      | "availableInNewTerritories"
      | "availableTerritories"
      | "betaAppLocalizations"
      | "betaAppReviewDetail"
      | "betaGroups"
      | "betaLicenseAgreement"
      | "betaTesters"
      | "builds"
      | "bundleId"
      | "contentRightsDeclaration"
      | "endUserLicenseAgreement"
      | "gameCenterEnabledVersions"
      | "inAppPurchases"
      | "isOrEverWasMadeForKids"
      | "name"
      | "perfPowerMetrics"
      | "preOrder"
      | "preReleaseVersions"
      | "prices"
      | "primaryLocale"
      | "sku"
    )[];
    /** maximum resources per page */
    limit?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AppsResponse> {
  const result = await api.v1.usersVisibleAppsGetToManyRelated({
    id: id,
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}
