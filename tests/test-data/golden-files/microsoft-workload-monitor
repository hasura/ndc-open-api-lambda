import * as hasuraSdk from "@hasura/ndc-lambda-sdk";
import {
  Api,
  Component,
  ComponentsCollection,
  Monitor,
  MonitorInstance,
  MonitorInstancesCollection,
  MonitorsCollection,
  NotificationSetting,
  NotificationSettingsCollection,
  OperationListResult,
} from "./api";

const api = new Api({
  baseUrl: "",
});

/**
 * Gets the details of all operations possible on the resource provider.
 * @request GET :/providers/Microsoft.WorkloadMonitor/operations
 * @allowrelaxedtypes
 * @readonly
 */
export async function getProvidersOperationsList(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<OperationListResult> {
  const result = await api.providers.operationsList({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get subscription wide details of components.
 * @request GET :/subscriptions/{subscriptionId}/providers/Microsoft.WorkloadMonitor/componentsSummary
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsComponentsSummaryList(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Filter to be applied on the operation.
     */
    $filter?: string;
    /**
     * Apply aggregation.
     */
    $apply?: string;
    /**
     * Sort the result on one or more properties.
     */
    $orderby?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
    /**
     * Limit the result to the specified number of rows.
     */
    $top?: string;
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ComponentsCollection> {
  const result = await api.subscriptions.componentsSummaryList({
    query: query,
    subscriptionId: subscriptionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get subscription wide health instances.
 * @request GET :/subscriptions/{subscriptionId}/providers/Microsoft.WorkloadMonitor/monitorInstancesSummary
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsMonitorInstancesSummaryList(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Filter to be applied on the operation.
     */
    $filter?: string;
    /**
     * Apply aggregation.
     */
    $apply?: string;
    /**
     * Sort the result on one or more properties.
     */
    $orderby?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
    /**
     * Limit the result to the specified number of rows.
     */
    $top?: string;
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<MonitorInstancesCollection> {
  const result = await api.subscriptions.monitorInstancesSummaryList({
    query: query,
    subscriptionId: subscriptionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get list of components for a resource.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/components
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsComponentsListByResource(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Filter to be applied on the operation.
     */
    $filter?: string;
    /**
     * Apply aggregation.
     */
    $apply?: string;
    /**
     * Sort the result on one or more properties.
     */
    $orderby?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
    /**
     * Limit the result to the specified number of rows.
     */
    $top?: string;
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ComponentsCollection> {
  const result = await api.subscriptions.componentsListByResource({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get details of a component.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/components/{componentId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsComponentsGet(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  /**
   * Component Id.
   */
  componentId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Component> {
  const result = await api.subscriptions.componentsGet({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    componentId: componentId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get list of monitor instances for a resource.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/monitorInstances
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsMonitorInstancesListByResource(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Filter to be applied on the operation.
     */
    $filter?: string;
    /**
     * Apply aggregation.
     */
    $apply?: string;
    /**
     * Sort the result on one or more properties.
     */
    $orderby?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
    /**
     * Limit the result to the specified number of rows.
     */
    $top?: string;
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  headers?: hasuraSdk.JSONValue,
): Promise<MonitorInstancesCollection> {
  const result = await api.subscriptions.monitorInstancesListByResource({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get details of a monitorInstance.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/monitorInstances/{monitorInstanceId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsMonitorInstancesGet(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Properties to be returned in the response.
     */
    $select?: string;
    /**
     * Include properties inline in the response.
     */
    $expand?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  /**
   * MonitorInstance Id.
   */
  monitorInstanceId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<MonitorInstance> {
  const result = await api.subscriptions.monitorInstancesGet({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    monitorInstanceId: monitorInstanceId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get list of a monitors of a resource.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/monitors
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsMonitorsListByResource(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * Filter to be applied on the operation.
     */
    $filter?: string;
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  headers?: hasuraSdk.JSONValue,
): Promise<MonitorsCollection> {
  const result = await api.subscriptions.monitorsListByResource({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get details of a single monitor.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/monitors/{monitorId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsMonitorsGet(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  /**
   * Monitor Id.
   */
  monitorId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Monitor> {
  const result = await api.subscriptions.monitorsGet({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    monitorId: monitorId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update a Monitor's configuration.
 * @request PATCH :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/monitors/{monitorId}
 * @allowrelaxedtypes
 */
export async function patchSubscriptionsMonitorsUpdate(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  /**
   * Monitor Id.
   */
  monitorId: string,
  /** Request body */
  body: Monitor,
  headers?: hasuraSdk.JSONValue,
): Promise<Monitor> {
  const result = await api.subscriptions.monitorsUpdate({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    monitorId: monitorId,
    body: body,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get list of notification settings for a resource.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/notificationSettings
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsNotificationSettingsListByResource(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
    /**
     * The page-continuation token to use with a paged version of this API.
     */
    $skiptoken?: string;
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationSettingsCollection> {
  const result = await api.subscriptions.notificationSettingsListByResource({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get a of notification setting for a resource.
 * @request GET :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/notificationSettings/{notificationSettingName}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getSubscriptionsNotificationSettingsGet(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  /**
   * Default string modeled as parameter for URL to work correctly.
   */
  notificationSettingName: "default",
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationSetting> {
  const result = await api.subscriptions.notificationSettingsGet({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    notificationSettingName: notificationSettingName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update notification settings for a resource.
 * @request PUT :/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.WorkloadMonitor/notificationSettings/{notificationSettingName}
 * @allowrelaxedtypes
 */
export async function putSubscriptionsNotificationSettingsUpdate(
  query: {
    /**
     * The API version to use for this operation.
     */
    "api-version": "2018-08-31-preview";
  },
  /**
   * The ID of the target subscription.
   */
  subscriptionId: string,
  /**
   * The name of the resource group. The name is case insensitive.
   */
  resourceGroupName: string,
  /**
   * The Namespace of the resource.
   */
  resourceNamespace: string,
  /**
   * The type of the resource.
   */
  resourceType: string,
  /**
   * Name of the resource.
   */
  resourceName: string,
  notificationSettingName: "default",
  /** Request body */
  body: NotificationSetting,
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationSetting> {
  const result = await api.subscriptions.notificationSettingsUpdate({
    query: query,
    subscriptionId: subscriptionId,
    resourceGroupName: resourceGroupName,
    resourceNamespace: resourceNamespace,
    resourceType: resourceType,
    resourceName: resourceName,
    notificationSettingName: notificationSettingName,
    body: body,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}
