import { Api, ApplicationSetting, TemplatesList, Template, Group, GroupDetail, AccessRequester, Member, Issue, NotificationSetting, Project, Hook, SSHKeyWithUser, RepoLicense, Namespace, GlobalNotificationSetting, BasicProjectDetails, ProjectWithAccess, TriggerRequest, Board, List, Build, SSHKey, Deployment, Environment, Event, ProjectHook, AwardEmoji, Todo, Note, Label, MergeRequest, MergeRequestChanges, MRNote, RepoCommit, MergeRequestDiff, MergeRequestDiffFull, Milestone, Pipeline, RepoBranch, RepoCommitDetail, CommitNote, CommitStatus, Compare, Contributor, RepoTag, Release, RepoTreeObject, Runner, ProjectService, ProjectGroupLink, ProjectSnippet, Trigger, UserBasic, Variable, RunnerDetails, UserWithPrivateToken, PersonalSnippet, UserPublic, Email } from './api';
import * as hasuraSdk from "@hasura/ndc-lambda-sdk"

const api = new Api({
  baseUrl: '',
});

/**
 * Get the current application settings
 * @request GET :/v3/application/settings
 * @readonly
 */
export async function getV3GetV3ApplicationSettings(): Promise<ApplicationSetting> {
  const result = await api.v3.getV3ApplicationSettings({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Modify application settings
 * @request PUT :/v3/application/settings
 * @allowrelaxedtypes
 */
export async function putV3PutV3ApplicationSettings(
  /** Request body */
  data: {
  /**
   * Determine if developers can push to master
   * @format int32
   */
    default_branch_protection?: 0 | 1 | 2,
  /**
   * The default project visibility
   * @format int32
   */
    default_project_visibility?: 0 | 10 | 20,
  /**
   * The default snippet visibility
   * @format int32
   */
    default_snippet_visibility?: 0 | 10 | 20,
  /**
   * The default group visibility
   * @format int32
   */
    default_group_visibility?: 0 | 10 | 20,
  /** Selected levels cannot be used by non-admin users for projects or snippets. If the public level is restricted, user profiles are only visible to logged in users. */
    restricted_visibility_levels?: (string)[],
  /** Enabled sources for code import during project creation. OmniAuth must be configured for GitHub, Bitbucket, and GitLab.com */
    import_sources?: "github" | "bitbucket" | "gitlab" | "google_code" | "fogbugz" | "git" | "gitlab_project",
  /** Disable certain OAuth sign-in sources */
    disabled_oauth_sign_in_sources?: (string)[],
  /** Allow only the selected protocols to be used for Git access. */
    enabled_git_access_protocol?: "ssh" | "http" | "nil",
  /** Flag indicating if the Gravatar service is enabled */
    gravatar_enabled?: boolean,
  /**
   * The maximum number of personal projects
   * @format int32
   */
    default_projects_limit?: number,
  /**
   * Maximum attachment size in MB
   * @format int32
   */
    max_attachment_size?: number,
  /**
   * Session duration in minutes. GitLab restart is required to apply changes.
   * @format int32
   */
    session_expire_delay?: number,
  /** Allow users to register any application to use GitLab as an OAuth provider */
    user_oauth_applications?: boolean,
  /** Newly registered users will by default be external */
    user_default_external?: boolean,
  /** Flag indicating if sign up is enabled */
    signup_enabled?: boolean,
  /** Send confirmation email on sign-up */
    send_user_confirmation_email?: boolean,
  /** ONLY users with e-mail addresses that match these domain(s) will be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com */
    domain_whitelist?: string,
  /** Enable domain blacklist for sign ups */
    domain_blacklist_enabled?: boolean,
  /** Users with e-mail addresses that match these domain(s) will NOT be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com */
    domain_blacklist: string,
  /** Text shown after sign up */
    after_sign_up_text?: string,
  /** Flag indicating if sign in is enabled */
    signin_enabled?: boolean,
  /** Require all users to setup Two-factor authentication */
    require_two_factor_authentication?: boolean,
  /**
   * Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication
   * @format int32
   */
    two_factor_grace_period: number,
  /** We will redirect non-logged in users to this page */
    home_page_url?: string,
  /** We will redirect users to this page after they sign out */
    after_sign_out_path?: string,
  /** The sign in text of the GitLab application */
    sign_in_text?: string,
  /** Custom text displayed on the help page */
    help_page_text?: string,
  /** Enable shared runners for new projects */
    shared_runners_enabled?: boolean,
  /** Shared runners text  */
    shared_runners_text: string,
  /**
   * Set the maximum file size each build's artifacts can have
   * @format int32
   */
    max_artifacts_size?: number,
  /**
   * Authorization token duration (minutes)
   * @format int32
   */
    container_registry_token_expire_delay?: number,
  /** Enable the InfluxDB metrics */
    metrics_enabled?: boolean,
  /** The InfluxDB host */
    metrics_host: string,
  /**
   * The UDP port to use for connecting to InfluxDB
   * @format int32
   */
    metrics_port: number,
  /**
   * The amount of InfluxDB connections to open
   * @format int32
   */
    metrics_pool_size: number,
  /**
   * The amount of seconds after which an InfluxDB connection will time out
   * @format int32
   */
    metrics_timeout: number,
  /**
   * A method call is only tracked when it takes longer to complete than the given amount of milliseconds.
   * @format int32
   */
    metrics_method_call_threshold: number,
  /**
   * The sampling interval in seconds
   * @format int32
   */
    metrics_sample_interval: number,
  /**
   * The amount of points to store in a single UDP packet
   * @format int32
   */
    metrics_packet_size: number,
  /** Enable Sidekiq Job Throttling */
    sidekiq_throttling_enabled?: boolean,
  /** Choose which queues you wish to throttle */
    sidekiq_throttling_queus: (string)[],
  /**
   * The factor by which the queues should be throttled. A value between 0.0 and 1.0, exclusive.
   * @format float
   */
    sidekiq_throttling_factor: number,
  /** Helps prevent bots from creating accounts */
    recaptcha_enabled?: boolean,
  /** Generate site key at http://www.google.com/recaptcha */
    recaptcha_site_key: string,
  /** Generate private key at http://www.google.com/recaptcha */
    recaptcha_private_key: string,
  /** Helps prevent bots from creating issues */
    akismet_enabled?: boolean,
  /** Generate API key at http://www.akismet.com */
    akismet_api_key: string,
  /** Abuse reports will be sent to this address if it is set. Abuse reports are always available in the admin area. */
    admin_notification_email?: string,
  /** Sentry is an error reporting and logging tool which is currently not shipped with GitLab, get it here: https://getsentry.com */
    sentry_enabled?: boolean,
  /** Sentry Data Source Name */
    sentry_dsn: string,
  /** Storage paths for new projects */
    repository_storage?: string,
  /** GitLab will periodically run 'git fsck' in all project and wiki repositories to look for silent disk corruption issues. */
    repository_checks_enabled?: boolean,
  /** Enable Koding */
    koding_enabled?: boolean,
  /** The Koding team URL */
    koding_url: string,
  /** Enable PlantUML */
    plantuml_enabled?: boolean,
  /** The PlantUML server URL */
    plantuml_url: string,
  /** Let GitLab inform you when an update is available. */
    version_check_enabled?: boolean,
  /** Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead. */
    email_author_in_body?: boolean,
  /** By default GitLab sends emails in HTML and plain text formats so mail clients can choose what format to use. Disable this option if you only want to send emails in plain text format. */
    html_emails_enabled?: boolean,
  /** Enable automatic repository housekeeping (git repack, git gc) */
    housekeeping_enabled?: boolean,
  /** Creating pack file bitmaps makes housekeeping take a little longer but bitmaps should accelerate 'git clone' performance. */
    housekeeping_bitmaps_enabled: boolean,
  /**
   * Number of Git pushes after which an incremental 'git repack' is run.
   * @format int32
   */
    housekeeping_incremental_repack_period: number,
  /**
   * Number of Git pushes after which a full 'git repack' is run.
   * @format int32
   */
    housekeeping_full_repack_period: number,
  /**
   * Number of Git pushes after which 'git gc' is run.
   * @format int32
   */
    housekeeping_gc_period: number,

},      
): Promise<ApplicationSetting> {
  const result = await api.v3.putV3ApplicationSettings({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Validation of .gitlab-ci.yml content
 * @request POST :/v3/ci/lint
 * @allowrelaxedtypes
 */
export async function postV3PostV3CiLint(
  /** Request body */
  data: {
  /** Content of .gitlab-ci.yml */
    content: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3CiLint({
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request GET :/v3/deploy_keys
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3DeployKeys(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3DeployKeys({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/dockerfiles
 * @readonly
 */
export async function getV3GetV3Dockerfiles(): Promise<TemplatesList> {
  const result = await api.v3.getV3Dockerfiles({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/dockerfiles/{name}
 * @readonly
 */
export async function getV3GetV3DockerfilesName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3DockerfilesName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/gitignores
 * @readonly
 */
export async function getV3GetV3Gitignores(): Promise<TemplatesList> {
  const result = await api.v3.getV3Gitignores({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/gitignores/{name}
 * @readonly
 */
export async function getV3GetV3GitignoresName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3GitignoresName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/gitlab_ci_ymls
 * @readonly
 */
export async function getV3GetV3GitlabCiYmls(): Promise<TemplatesList> {
  const result = await api.v3.getV3GitlabCiYmls({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/gitlab_ci_ymls/{name}
 * @readonly
 */
export async function getV3GetV3GitlabCiYmlsName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3GitlabCiYmlsName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a groups list
 * @request GET :/v3/groups
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3Groups(
  /** Request body */
  data: {
  /** Array of group ids to exclude from list */
    skip_groups?: (number)[],

},      
  /** Include project statistics */
  statistics?: boolean,      
  /** Show all group that you have access to */
  all_available?: boolean,      
  /** Search for a specific group */
  search?: string,      
  /** Order by name or path */
  order_by?: "name" | "path",      
  /** Sort by asc (ascending) or desc (descending) */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Group> {
  const result = await api.v3.getV3Groups({
    query: {
      statistics: statistics,
      all_available: all_available,
      search: search,
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a group. Available only for users who can create groups.
 * @request POST :/v3/groups
 */
export async function postV3PostV3Groups(
  /** Request body */
  data: {
  /** The name of the group */
    name: string,
  /** The path of the group */
    path: string,
  /** The description of the group */
    description?: string,
  /**
   * The visibility level of the group
   * @format int32
   */
    visibility_level?: number,
  /** Enable/disable LFS for the projects in this group */
    lfs_enabled?: boolean,
  /** Allow users to request member access */
    request_access_enabled?: boolean,

},      
): Promise<Group> {
  const result = await api.v3.postV3Groups({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get list of owned groups for authenticated user
 * @request GET :/v3/groups/owned
 * @readonly
 */
export async function getV3GetV3GroupsOwned(
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Include project statistics */
  statistics?: boolean,      
): Promise<Group> {
  const result = await api.v3.getV3GroupsOwned({
    query: {
      page: page,
      per_page: per_page,
      statistics: statistics,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Remove a group.
 * @request DELETE :/v3/groups/{id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3GroupsId(
  /** The ID of a group */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3GroupsId({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single group, with containing projects.
 * @request GET :/v3/groups/{id}
 * @readonly
 */
export async function getV3GetV3GroupsId(
  /** The ID of a group */
  id: string,      
): Promise<GroupDetail> {
  const result = await api.v3.getV3GroupsId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update a group. Available only for users who can administrate groups.
 * @request PUT :/v3/groups/{id}
 */
export async function putV3PutV3GroupsId(
  /** The ID of a group */
  id: string,      
  /** Request body */
  data: {
  /** The name of the group */
    name?: string,
  /** The path of the group */
    path?: string,
  /** The description of the group */
    description?: string,
  /**
   * The visibility level of the group
   * @format int32
   */
    visibility_level?: number,
  /** Enable/disable LFS for the projects in this group */
    lfs_enabled?: boolean,
  /** Allow users to request member access */
    request_access_enabled?: boolean,

},      
): Promise<Group> {
  const result = await api.v3.putV3GroupsId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a list of access requests for a group.
 * @request GET :/v3/groups/{id}/access_requests
 * @readonly
 */
export async function getV3GetV3GroupsIdAccessRequests(
  /** The group ID */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AccessRequester> {
  const result = await api.v3.getV3GroupsIdAccessRequests({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Requests access for the authenticated user to a group.
 * @request POST :/v3/groups/{id}/access_requests
 */
export async function postV3PostV3GroupsIdAccessRequests(
  /** The group ID */
  id: string,      
): Promise<AccessRequester> {
  const result = await api.v3.postV3GroupsIdAccessRequests({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Denies an access request for the given user.
 * @request DELETE :/v3/groups/{id}/access_requests/{user_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3GroupsIdAccessRequestsUserId(
  /** The group ID */
  id: string,      
  /** The user ID of the access requester */
  userId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3GroupsIdAccessRequestsUserId({
    id: id,
    userId: userId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Approves an access request for the given user.
 * @request PUT :/v3/groups/{id}/access_requests/{user_id}/approve
 */
export async function putV3PutV3GroupsIdAccessRequestsUserIdApprove(
  /** The group ID */
  id: string,      
  /** The user ID of the access requester */
  userId: number,      
  /** Request body */
  data: {
  /**
   * A valid access level (defaults: `30`, developer access level)
   * @format int32
   */
    access_level?: number,

},      
): Promise<Member> {
  const result = await api.v3.putV3GroupsIdAccessRequestsUserIdApprove({
    id: id,
    userId: userId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of group issues
 * @request GET :/v3/groups/{id}/issues
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3GroupsIdIssues(
  /** The ID of a group */
  id: string,      
  /** Return opened, closed, or all issues */
  state?: "opened" | "closed" | "all",      
  /** Comma-separated list of label names */
  labels?: string,      
  /** Return issues for a specific milestone */
  milestone?: string,      
  /** Return issues ordered by `created_at` or `updated_at` fields. */
  order_by?: "created_at" | "updated_at",      
  /** Return issues sorted in `asc` or `desc` order. */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Issue> {
  const result = await api.v3.getV3GroupsIdIssues({
    query: {
      state: state,
      labels: labels,
      milestone: milestone,
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a list of group or project members viewable by the authenticated user.
 * @request GET :/v3/groups/{id}/members
 * @readonly
 */
export async function getV3GetV3GroupsIdMembers(
  /** The group ID */
  id: string,      
  /** A query string to search for members */
  query?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Member> {
  const result = await api.v3.getV3GroupsIdMembers({
    query: {
      query: query,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Adds a member to a group or project.
 * @request POST :/v3/groups/{id}/members
 */
export async function postV3PostV3GroupsIdMembers(
  /** The group ID */
  id: string,      
  /** Request body */
  data: {
  /**
   * The user ID of the new member
   * @format int32
   */
    user_id: number,
  /**
   * A valid access level (defaults: `30`, developer access level)
   * @format int32
   */
    access_level: number,
  /**
   * Date string in the format YEAR-MONTH-DAY
   * @format date-time
   */
    expires_at?: string,

},      
): Promise<Member> {
  const result = await api.v3.postV3GroupsIdMembers({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Removes a user from a group or project.
 * @request DELETE :/v3/groups/{id}/members/{user_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3GroupsIdMembersUserId(
  /** The group ID */
  id: string,      
  /** The user ID of the member */
  userId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3GroupsIdMembersUserId({
    id: id,
    userId: userId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Gets a member of a group or project.
 * @request GET :/v3/groups/{id}/members/{user_id}
 * @readonly
 */
export async function getV3GetV3GroupsIdMembersUserId(
  /** The group ID */
  id: string,      
  /** The user ID of the member */
  userId: number,      
): Promise<Member> {
  const result = await api.v3.getV3GroupsIdMembersUserId({
    id: id,
    userId: userId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Updates a member of a group or project.
 * @request PUT :/v3/groups/{id}/members/{user_id}
 */
export async function putV3PutV3GroupsIdMembersUserId(
  /** The group ID */
  id: string,      
  /** The user ID of the new member */
  userId: number,      
  /** Request body */
  data: {
  /**
   * A valid access level
   * @format int32
   */
    access_level: number,
  /**
   * Date string in the format YEAR-MONTH-DAY
   * @format date-time
   */
    expires_at?: string,

},      
): Promise<Member> {
  const result = await api.v3.putV3GroupsIdMembersUserId({
    id: id,
    userId: userId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get group level notification level settings, defaults to Global
 * @request GET :/v3/groups/{id}/notification_settings
 * @readonly
 */
export async function getV3GetV3GroupsIdNotificationSettings(
  /** The group ID or project ID or project NAMESPACE/PROJECT_NAME */
  id: string,      
): Promise<NotificationSetting> {
  const result = await api.v3.getV3GroupsIdNotificationSettings({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update group level notification level settings, defaults to Global
 * @request PUT :/v3/groups/{id}/notification_settings
 */
export async function putV3PutV3GroupsIdNotificationSettings(
  /** The group ID or project ID or project NAMESPACE/PROJECT_NAME */
  id: string,      
  /** Request body */
  data: {
  /** The group notification level */
    level?: string,
  /** Enable/disable this notification */
    new_note?: boolean,
  /** Enable/disable this notification */
    new_issue?: boolean,
  /** Enable/disable this notification */
    reopen_issue?: boolean,
  /** Enable/disable this notification */
    close_issue?: boolean,
  /** Enable/disable this notification */
    reassign_issue?: boolean,
  /** Enable/disable this notification */
    new_merge_request?: boolean,
  /** Enable/disable this notification */
    reopen_merge_request?: boolean,
  /** Enable/disable this notification */
    close_merge_request?: boolean,
  /** Enable/disable this notification */
    reassign_merge_request?: boolean,
  /** Enable/disable this notification */
    merge_merge_request?: boolean,
  /** Enable/disable this notification */
    failed_pipeline?: boolean,
  /** Enable/disable this notification */
    success_pipeline?: boolean,

},      
): Promise<NotificationSetting> {
  const result = await api.v3.putV3GroupsIdNotificationSettings({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of projects in this group.
 * @request GET :/v3/groups/{id}/projects
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3GroupsIdProjects(
  /** The ID of a group */
  id: string,      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Project> {
  const result = await api.v3.getV3GroupsIdProjects({
    query: {
      archived: archived,
      visibility: visibility,
      search: search,
      order_by: order_by,
      sort: sort,
      simple: simple,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Transfer a project to the group namespace. Available only for admin.
 * @request POST :/v3/groups/{id}/projects/{project_id}
 */
export async function postV3PostV3GroupsIdProjectsProjectId(
  /** The ID of a group */
  id: string,      
  /** The ID or path of the project */
  projectId: string,      
): Promise<GroupDetail> {
  const result = await api.v3.postV3GroupsIdProjectsProjectId({
    id: id,
    projectId: projectId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of system hooks
 * @request GET :/v3/hooks
 * @readonly
 */
export async function getV3GetV3Hooks(): Promise<Hook> {
  const result = await api.v3.getV3Hooks({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new system hook
 * @request POST :/v3/hooks
 */
export async function postV3PostV3Hooks(
  /** Request body */
  data: {
  /** The URL to send the request to */
    url: string,
  /** The token used to validate payloads */
    token?: string,
  /** Trigger hook on push events */
    push_events?: boolean,
  /** Trigger hook on tag push events */
    tag_push_events?: boolean,
  /** Do SSL verification when triggering the hook */
    enable_ssl_verification?: boolean,

},      
): Promise<Hook> {
  const result = await api.v3.postV3Hooks({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a hook
 * @request DELETE :/v3/hooks/{id}
 */
export async function deleteV3DeleteV3HooksId(
  /** The ID of the system hook */
  id: number,      
): Promise<Hook> {
  const result = await api.v3.deleteV3HooksId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Test a hook
 * @request GET :/v3/hooks/{id}
 * @readonly
 */
export async function getV3GetV3HooksId(
  /** The ID of the system hook */
  id: number,      
): Promise<Hook> {
  const result = await api.v3.getV3HooksId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * undefined
 * @request POST :/v3/internal/allowed
 * @allowrelaxedtypes
 */
export async function postV3PostV3InternalAllowed(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3InternalAllowed({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request GET :/v3/internal/broadcast_message
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3InternalBroadcastMessage(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3InternalBroadcastMessage({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request GET :/v3/internal/check
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3InternalCheck(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3InternalCheck({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request GET :/v3/internal/discover
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3InternalDiscover(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3InternalDiscover({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request POST :/v3/internal/lfs_authenticate
 * @allowrelaxedtypes
 */
export async function postV3PostV3InternalLfsAuthenticate(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3InternalLfsAuthenticate({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request GET :/v3/internal/merge_request_urls
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3InternalMergeRequestUrls(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3InternalMergeRequestUrls({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request POST :/v3/internal/two_factor_recovery_codes
 * @allowrelaxedtypes
 */
export async function postV3PostV3InternalTwoFactorRecoveryCodes(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3InternalTwoFactorRecoveryCodes({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get currently authenticated user's issues
 * @request GET :/v3/issues
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3Issues(
  /** Return opened, closed, or all issues */
  state?: "opened" | "closed" | "all",      
  /** Comma-separated list of label names */
  labels?: string,      
  /** Return issues for a specific milestone */
  milestone?: string,      
  /** Return issues ordered by `created_at` or `updated_at` fields. */
  order_by?: "created_at" | "updated_at",      
  /** Return issues sorted in `asc` or `desc` order. */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Issue> {
  const result = await api.v3.getV3Issues({
    query: {
      state: state,
      labels: labels,
      milestone: milestone,
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get single ssh key by id. Only available to admin users
 * @request GET :/v3/keys/{id}
 * @readonly
 */
export async function getV3GetV3KeysId(
  /** undefined */
  id: number,      
): Promise<SSHKeyWithUser> {
  const result = await api.v3.getV3KeysId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available license template
 * @request GET :/v3/licenses
 * @readonly
 */
export async function getV3GetV3Licenses(
  /** If passed, returns only popular licenses */
  popular?: boolean,      
): Promise<RepoLicense> {
  const result = await api.v3.getV3Licenses({
    query: {
      popular: popular,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific license
 * @request GET :/v3/licenses/{name}
 * @readonly
 */
export async function getV3GetV3LicensesName(
  /** The name of the template */
  name: string,      
): Promise<RepoLicense> {
  const result = await api.v3.getV3LicensesName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a namespaces list
 * @request GET :/v3/namespaces
 * @readonly
 */
export async function getV3GetV3Namespaces(
  /** Search query for namespaces */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Namespace> {
  const result = await api.v3.getV3Namespaces({
    query: {
      search: search,
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get global notification level settings and email, defaults to Participate
 * @request GET :/v3/notification_settings
 * @readonly
 */
export async function getV3GetV3NotificationSettings(): Promise<GlobalNotificationSetting> {
  const result = await api.v3.getV3NotificationSettings({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update global notification level settings and email, defaults to Participate
 * @request PUT :/v3/notification_settings
 */
export async function putV3PutV3NotificationSettings(
  /** Request body */
  data: {
  /** The global notification level */
    level?: string,
  /** The email address to send notifications */
    notification_email?: string,
  /** Enable/disable this notification */
    new_note?: boolean,
  /** Enable/disable this notification */
    new_issue?: boolean,
  /** Enable/disable this notification */
    reopen_issue?: boolean,
  /** Enable/disable this notification */
    close_issue?: boolean,
  /** Enable/disable this notification */
    reassign_issue?: boolean,
  /** Enable/disable this notification */
    new_merge_request?: boolean,
  /** Enable/disable this notification */
    reopen_merge_request?: boolean,
  /** Enable/disable this notification */
    close_merge_request?: boolean,
  /** Enable/disable this notification */
    reassign_merge_request?: boolean,
  /** Enable/disable this notification */
    merge_merge_request?: boolean,
  /** Enable/disable this notification */
    failed_pipeline?: boolean,
  /** Enable/disable this notification */
    success_pipeline?: boolean,

},      
): Promise<GlobalNotificationSetting> {
  const result = await api.v3.putV3NotificationSettings({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a projects list for authenticated user
 * @request GET :/v3/projects
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3Projects(
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
): Promise<BasicProjectDetails> {
  const result = await api.v3.getV3Projects({
    query: {
      order_by: order_by,
      sort: sort,
      archived: archived,
      visibility: visibility,
      search: search,
      page: page,
      per_page: per_page,
      simple: simple,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create new project
 * @request POST :/v3/projects
 * @allowrelaxedtypes
 */
export async function postV3PostV3Projects(
  /** Request body */
  data: {
  /** The name of the project */
    name: string,
  /** The path of the repository */
    path?: string,
  /** The description of the project */
    description?: string,
  /** Flag indication if the issue tracker is enabled */
    issues_enabled?: boolean,
  /** Flag indication if merge requests are enabled */
    merge_requests_enabled?: boolean,
  /** Flag indication if the wiki is enabled */
    wiki_enabled?: boolean,
  /** Flag indication if builds are enabled */
    builds_enabled?: boolean,
  /** Flag indication if snippets are enabled */
    snippets_enabled?: boolean,
  /** Flag indication if shared runners are enabled for that project */
    shared_runners_enabled?: boolean,
  /** Flag indication if the container registry is enabled for that project */
    container_registry_enabled?: boolean,
  /** Flag indication if Git LFS is enabled for that project */
    lfs_enabled?: boolean,
  /** Create a public project. The same as visibility_level = 20. */
    public?: boolean,
  /**
   * Create a public project. The same as visibility_level = 20.
   * @format int32
   */
    visibility_level?: 0 | 10 | 20,
  /** Perform public builds */
    public_builds?: boolean,
  /** Allow users to request member access */
    request_access_enabled?: boolean,
  /** Only allow to merge if builds succeed */
    only_allow_merge_if_build_succeeds?: boolean,
  /** Only allow to merge if all discussions are resolved */
    only_allow_merge_if_all_discussions_are_resolved?: boolean,
  /**
   * Namespace ID for the new project. Default to the user namespace.
   * @format int32
   */
    namespace_id?: number,
  /** URL from which the project is imported */
    import_url?: string,

},      
): Promise<Project> {
  const result = await api.v3.postV3Projects({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all projects for admin user
 * @request GET :/v3/projects/all
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsAll(
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
  /** Include project statistics */
  statistics?: boolean,      
): Promise<BasicProjectDetails> {
  const result = await api.v3.getV3ProjectsAll({
    query: {
      order_by: order_by,
      sort: sort,
      archived: archived,
      visibility: visibility,
      search: search,
      page: page,
      per_page: per_page,
      simple: simple,
      statistics: statistics,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Fork new project for the current user or provided namespace.
 * @request POST :/v3/projects/fork/{id}
 */
export async function postV3PostV3ProjectsForkId(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The ID or name of the namespace that the project will be forked into */
    namespace?: string,

},      
): Promise<Project> {
  const result = await api.v3.postV3ProjectsForkId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get an owned projects list for authenticated user
 * @request GET :/v3/projects/owned
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsOwned(
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
  /** Include project statistics */
  statistics?: boolean,      
): Promise<BasicProjectDetails> {
  const result = await api.v3.getV3ProjectsOwned({
    query: {
      order_by: order_by,
      sort: sort,
      archived: archived,
      visibility: visibility,
      search: search,
      page: page,
      per_page: per_page,
      simple: simple,
      statistics: statistics,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Search for projects the current user has access to
 * @request GET :/v3/projects/search/{query}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsSearchQuery(
  /** The project name to be searched */
  query: string,      
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Project> {
  const result = await api.v3.getV3ProjectsSearchQuery({
    queryParams: {
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
    query: query,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets starred project for the authenticated user
 * @request GET :/v3/projects/starred
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsStarred(
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
): Promise<BasicProjectDetails> {
  const result = await api.v3.getV3ProjectsStarred({
    query: {
      order_by: order_by,
      sort: sort,
      archived: archived,
      visibility: visibility,
      search: search,
      page: page,
      per_page: per_page,
      simple: simple,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create new project for a specified user. Only available to admin users.
 * @request POST :/v3/projects/user/{user_id}
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsUserUserId(
  /** The ID of a user */
  userId: number,      
  /** Request body */
  data: {
  /** The name of the project */
    name: string,
  /** The default branch of the project */
    default_branch?: string,
  /** The description of the project */
    description?: string,
  /** Flag indication if the issue tracker is enabled */
    issues_enabled?: boolean,
  /** Flag indication if merge requests are enabled */
    merge_requests_enabled?: boolean,
  /** Flag indication if the wiki is enabled */
    wiki_enabled?: boolean,
  /** Flag indication if builds are enabled */
    builds_enabled?: boolean,
  /** Flag indication if snippets are enabled */
    snippets_enabled?: boolean,
  /** Flag indication if shared runners are enabled for that project */
    shared_runners_enabled?: boolean,
  /** Flag indication if the container registry is enabled for that project */
    container_registry_enabled?: boolean,
  /** Flag indication if Git LFS is enabled for that project */
    lfs_enabled?: boolean,
  /** Create a public project. The same as visibility_level = 20. */
    public?: boolean,
  /**
   * Create a public project. The same as visibility_level = 20.
   * @format int32
   */
    visibility_level?: 0 | 10 | 20,
  /** Perform public builds */
    public_builds?: boolean,
  /** Allow users to request member access */
    request_access_enabled?: boolean,
  /** Only allow to merge if builds succeed */
    only_allow_merge_if_build_succeeds?: boolean,
  /** Only allow to merge if all discussions are resolved */
    only_allow_merge_if_all_discussions_are_resolved?: boolean,
  /**
   * Namespace ID for the new project. Default to the user namespace.
   * @format int32
   */
    namespace_id?: number,
  /** URL from which the project is imported */
    import_url?: string,

},      
): Promise<Project> {
  const result = await api.v3.postV3ProjectsUserUserId({
    userId: userId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of visible projects for authenticated user
 * @request GET :/v3/projects/visible
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsVisible(
  /** Return projects ordered by field */
  order_by?: "id" | "name" | "path" | "created_at" | "updated_at" | "last_activity_at",      
  /** Return projects sorted in ascending and descending order */
  sort?: "asc" | "desc",      
  /** Limit by archived status */
  archived?: boolean,      
  /** Limit by visibility */
  visibility?: "public" | "internal" | "private",      
  /** Return list of authorized projects matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Return only the ID, URL, name, and path of each project */
  simple?: boolean,      
): Promise<BasicProjectDetails> {
  const result = await api.v3.getV3ProjectsVisible({
    query: {
      order_by: order_by,
      sort: sort,
      archived: archived,
      visibility: visibility,
      search: search,
      page: page,
      per_page: per_page,
      simple: simple,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Remove a project
 * @request DELETE :/v3/projects/{id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsId(
  /** The ID of a project */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsId({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single project
 * @request GET :/v3/projects/{id}
 * @readonly
 */
export async function getV3GetV3ProjectsId(
  /** The ID of a project */
  id: string,      
): Promise<ProjectWithAccess> {
  const result = await api.v3.getV3ProjectsId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing project
 * @request PUT :/v3/projects/{id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsId(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of the project */
    name?: string,
  /** The default branch of the project */
    default_branch?: string,
  /** The path of the repository */
    path?: string,
  /** The description of the project */
    description?: string,
  /** Flag indication if the issue tracker is enabled */
    issues_enabled?: boolean,
  /** Flag indication if merge requests are enabled */
    merge_requests_enabled?: boolean,
  /** Flag indication if the wiki is enabled */
    wiki_enabled?: boolean,
  /** Flag indication if builds are enabled */
    builds_enabled?: boolean,
  /** Flag indication if snippets are enabled */
    snippets_enabled?: boolean,
  /** Flag indication if shared runners are enabled for that project */
    shared_runners_enabled?: boolean,
  /** Flag indication if the container registry is enabled for that project */
    container_registry_enabled?: boolean,
  /** Flag indication if Git LFS is enabled for that project */
    lfs_enabled?: boolean,
  /** Create a public project. The same as visibility_level = 20. */
    public?: boolean,
  /**
   * Create a public project. The same as visibility_level = 20.
   * @format int32
   */
    visibility_level?: 0 | 10 | 20,
  /** Perform public builds */
    public_builds?: boolean,
  /** Allow users to request member access */
    request_access_enabled?: boolean,
  /** Only allow to merge if builds succeed */
    only_allow_merge_if_build_succeeds?: boolean,
  /** Only allow to merge if all discussions are resolved */
    only_allow_merge_if_all_discussions_are_resolved?: boolean,

},      
): Promise<Project> {
  const result = await api.v3.putV3ProjectsId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Trigger a GitLab project build
 * @request POST :/v3/projects/{id}/(ref/{ref}/)trigger/builds
 */
export async function postV3PostV3ProjectsIdRefRefTriggerBuilds(
  /** The ID of a project */
  id: string,      
  /** The commit sha or name of a branch or tag */
  ref: string,      
  /** Request body */
  data: {
  /** The unique token of trigger */
    token: string,

},      
): Promise<TriggerRequest> {
  const result = await api.v3.postV3ProjectsIdRefRefTriggerBuilds({
    id: id,
    ref: ref,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a list of access requests for a project.
 * @request GET :/v3/projects/{id}/access_requests
 * @readonly
 */
export async function getV3GetV3ProjectsIdAccessRequests(
  /** The project ID */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AccessRequester> {
  const result = await api.v3.getV3ProjectsIdAccessRequests({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Requests access for the authenticated user to a project.
 * @request POST :/v3/projects/{id}/access_requests
 */
export async function postV3PostV3ProjectsIdAccessRequests(
  /** The project ID */
  id: string,      
): Promise<AccessRequester> {
  const result = await api.v3.postV3ProjectsIdAccessRequests({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Denies an access request for the given user.
 * @request DELETE :/v3/projects/{id}/access_requests/{user_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdAccessRequestsUserId(
  /** The project ID */
  id: string,      
  /** The user ID of the access requester */
  userId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdAccessRequestsUserId({
    id: id,
    userId: userId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Approves an access request for the given user.
 * @request PUT :/v3/projects/{id}/access_requests/{user_id}/approve
 */
export async function putV3PutV3ProjectsIdAccessRequestsUserIdApprove(
  /** The project ID */
  id: string,      
  /** The user ID of the access requester */
  userId: number,      
  /** Request body */
  data: {
  /**
   * A valid access level (defaults: `30`, developer access level)
   * @format int32
   */
    access_level?: number,

},      
): Promise<Member> {
  const result = await api.v3.putV3ProjectsIdAccessRequestsUserIdApprove({
    id: id,
    userId: userId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Archive a project
 * @request POST :/v3/projects/{id}/archive
 */
export async function postV3PostV3ProjectsIdArchive(
  /** The ID of a project */
  id: string,      
): Promise<Project> {
  const result = await api.v3.postV3ProjectsIdArchive({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all project boards
 * @request GET :/v3/projects/{id}/boards
 * @readonly
 */
export async function getV3GetV3ProjectsIdBoards(
  /** The ID of a project */
  id: string,      
): Promise<Board> {
  const result = await api.v3.getV3ProjectsIdBoards({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the lists of a project board
 * @request GET :/v3/projects/{id}/boards/{board_id}/lists
 * @readonly
 */
export async function getV3GetV3ProjectsIdBoardsBoardIdLists(
  /** The ID of a project */
  id: string,      
  /** The ID of a board */
  boardId: number,      
): Promise<List> {
  const result = await api.v3.getV3ProjectsIdBoardsBoardIdLists({
    id: id,
    boardId: boardId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new board list
 * @request POST :/v3/projects/{id}/boards/{board_id}/lists
 */
export async function postV3PostV3ProjectsIdBoardsBoardIdLists(
  /** The ID of a project */
  id: string,      
  /** The ID of a board */
  boardId: number,      
  /** Request body */
  data: {
  /**
   * The ID of an existing label
   * @format int32
   */
    label_id: number,

},      
): Promise<List> {
  const result = await api.v3.postV3ProjectsIdBoardsBoardIdLists({
    id: id,
    boardId: boardId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a board list
 * @request DELETE :/v3/projects/{id}/boards/{board_id}/lists/{list_id}
 */
export async function deleteV3DeleteV3ProjectsIdBoardsBoardIdListsListId(
  /** The ID of a project */
  id: string,      
  /** The ID of a board */
  boardId: number,      
  /** The ID of a board list */
  listId: number,      
): Promise<List> {
  const result = await api.v3.deleteV3ProjectsIdBoardsBoardIdListsListId({
    id: id,
    boardId: boardId,
    listId: listId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of a project board
 * @request GET :/v3/projects/{id}/boards/{board_id}/lists/{list_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdBoardsBoardIdListsListId(
  /** The ID of a project */
  id: string,      
  /** The ID of a board */
  boardId: number,      
  /** The ID of a list */
  listId: number,      
): Promise<List> {
  const result = await api.v3.getV3ProjectsIdBoardsBoardIdListsListId({
    id: id,
    boardId: boardId,
    listId: listId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Moves a board list to a new position
 * @request PUT :/v3/projects/{id}/boards/{board_id}/lists/{list_id}
 */
export async function putV3PutV3ProjectsIdBoardsBoardIdListsListId(
  /** The ID of a project */
  id: string,      
  /** The ID of a board */
  boardId: number,      
  /** The ID of a list */
  listId: number,      
  /** Request body */
  data: {
  /**
   * The position of the list
   * @format int32
   */
    position: number,

},      
): Promise<List> {
  const result = await api.v3.putV3ProjectsIdBoardsBoardIdListsListId({
    id: id,
    boardId: boardId,
    listId: listId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a project builds
 * @request GET :/v3/projects/{id}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdBuilds(
  /** The ID of a project */
  id: string,      
  /** The scope of builds to show */
  scope?: "pending" | "running" | "failed" | "success" | "canceled",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Build> {
  const result = await api.v3.getV3ProjectsIdBuilds({
    query: {
      scope: scope,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Download the artifacts file from build
 * @request GET :/v3/projects/{id}/builds/artifacts/{ref_name}/download
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdBuildsArtifactsRefNameDownload(
  /** The name for the build */
  job: string,      
  /** The ID of a project */
  id: string,      
  /** The ref from repository */
  refName: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdBuildsArtifactsRefNameDownload({
    query: {
      job: job,
    },
    id: id,
    refName: refName,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a specific build of a project
 * @request GET :/v3/projects/{id}/builds/{build_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdBuildsBuildId(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.getV3ProjectsIdBuildsBuildId({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Download the artifacts file from build
 * @request GET :/v3/projects/{id}/builds/{build_id}/artifacts
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdBuildsBuildIdArtifacts(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdBuildsBuildIdArtifacts({
    id: id,
    buildId: buildId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Keep the artifacts to prevent them from being deleted
 * @request POST :/v3/projects/{id}/builds/{build_id}/artifacts/keep
 */
export async function postV3PostV3ProjectsIdBuildsBuildIdArtifactsKeep(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.postV3ProjectsIdBuildsBuildIdArtifactsKeep({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Cancel a specific build of a project
 * @request POST :/v3/projects/{id}/builds/{build_id}/cancel
 */
export async function postV3PostV3ProjectsIdBuildsBuildIdCancel(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.postV3ProjectsIdBuildsBuildIdCancel({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Erase build (remove artifacts and build trace)
 * @request POST :/v3/projects/{id}/builds/{build_id}/erase
 */
export async function postV3PostV3ProjectsIdBuildsBuildIdErase(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.postV3ProjectsIdBuildsBuildIdErase({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Trigger a manual build
 * @request POST :/v3/projects/{id}/builds/{build_id}/play
 */
export async function postV3PostV3ProjectsIdBuildsBuildIdPlay(
  /** The ID of a project */
  id: string,      
  /** The ID of a Build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.postV3ProjectsIdBuildsBuildIdPlay({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Retry a specific build of a project
 * @request POST :/v3/projects/{id}/builds/{build_id}/retry
 */
export async function postV3PostV3ProjectsIdBuildsBuildIdRetry(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<Build> {
  const result = await api.v3.postV3ProjectsIdBuildsBuildIdRetry({
    id: id,
    buildId: buildId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a trace of a specific build of a project
 * @request GET :/v3/projects/{id}/builds/{build_id}/trace
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdBuildsBuildIdTrace(
  /** The ID of a project */
  id: string,      
  /** The ID of a build */
  buildId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdBuildsBuildIdTrace({
    id: id,
    buildId: buildId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a specific project's deploy keys
 * @request GET :/v3/projects/{id}/deploy_keys
 * @readonly
 */
export async function getV3GetV3ProjectsIdDeployKeys(
  /** The ID of the project */
  id: string,      
): Promise<SSHKey> {
  const result = await api.v3.getV3ProjectsIdDeployKeys({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add new deploy key to currently authenticated user
 * @request POST :/v3/projects/{id}/deploy_keys
 */
export async function postV3PostV3ProjectsIdDeployKeys(
  /** The ID of the project */
  id: string,      
  /** Request body */
  data: {
  /** The new deploy key */
    key: string,
  /** The name of the deploy key */
    title: string,

},      
): Promise<SSHKey> {
  const result = await api.v3.postV3ProjectsIdDeployKeys({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete deploy key for a project
 * @request DELETE :/v3/projects/{id}/deploy_keys/{key_id}
 */
export async function deleteV3DeleteV3ProjectsIdDeployKeysKeyId(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3ProjectsIdDeployKeysKeyId({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get single deploy key
 * @request GET :/v3/projects/{id}/deploy_keys/{key_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdDeployKeysKeyId(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.getV3ProjectsIdDeployKeysKeyId({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Disable a deploy key for a project
 * @request DELETE :/v3/projects/{id}/deploy_keys/{key_id}/disable
 */
export async function deleteV3DeleteV3ProjectsIdDeployKeysKeyIdDisable(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3ProjectsIdDeployKeysKeyIdDisable({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Enable a deploy key for a project
 * @request POST :/v3/projects/{id}/deploy_keys/{key_id}/enable
 */
export async function postV3PostV3ProjectsIdDeployKeysKeyIdEnable(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.postV3ProjectsIdDeployKeysKeyIdEnable({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all deployments of the project
 * @request GET :/v3/projects/{id}/deployments
 * @readonly
 */
export async function getV3GetV3ProjectsIdDeployments(
  /** The project ID */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Deployment> {
  const result = await api.v3.getV3ProjectsIdDeployments({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a specific deployment
 * @request GET :/v3/projects/{id}/deployments/{deployment_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdDeploymentsDeploymentId(
  /** The project ID */
  id: string,      
  /** The deployment ID */
  deploymentId: number,      
): Promise<Deployment> {
  const result = await api.v3.getV3ProjectsIdDeploymentsDeploymentId({
    id: id,
    deploymentId: deploymentId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all environments of the project
 * @request GET :/v3/projects/{id}/environments
 * @readonly
 */
export async function getV3GetV3ProjectsIdEnvironments(
  /** The project ID */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Environment> {
  const result = await api.v3.getV3ProjectsIdEnvironments({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Creates a new environment
 * @request POST :/v3/projects/{id}/environments
 */
export async function postV3PostV3ProjectsIdEnvironments(
  /** The project ID */
  id: string,      
  /** Request body */
  data: {
  /** The name of the environment to be created */
    name: string,
  /** URL on which this deployment is viewable */
    external_url?: string,
    slug?: string,

},      
): Promise<Environment> {
  const result = await api.v3.postV3ProjectsIdEnvironments({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Deletes an existing environment
 * @request DELETE :/v3/projects/{id}/environments/{environment_id}
 */
export async function deleteV3DeleteV3ProjectsIdEnvironmentsEnvironmentId(
  /** The project ID */
  id: string,      
  /** The environment ID */
  environmentId: number,      
): Promise<Environment> {
  const result = await api.v3.deleteV3ProjectsIdEnvironmentsEnvironmentId({
    id: id,
    environmentId: environmentId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Updates an existing environment
 * @request PUT :/v3/projects/{id}/environments/{environment_id}
 */
export async function putV3PutV3ProjectsIdEnvironmentsEnvironmentId(
  /** The project ID */
  id: string,      
  /** The environment ID */
  environmentId: number,      
  /** Request body */
  data: {
  /** The new environment name */
    name?: string,
  /** The new URL on which this deployment is viewable */
    external_url?: string,
    slug?: string,

},      
): Promise<Environment> {
  const result = await api.v3.putV3ProjectsIdEnvironmentsEnvironmentId({
    id: id,
    environmentId: environmentId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get events for a single project
 * @request GET :/v3/projects/{id}/events
 * @readonly
 */
export async function getV3GetV3ProjectsIdEvents(
  /** The ID of a project */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Event> {
  const result = await api.v3.getV3ProjectsIdEvents({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Remove a forked_from relationship
 * @request DELETE :/v3/projects/{id}/fork
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdFork(
  /** The ID of a project */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdFork({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Mark this project as forked from another
 * @request POST :/v3/projects/{id}/fork/{forked_from_id}
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdForkForkedFromId(
  /** The ID of a project */
  id: string,      
  /** The ID of the project it was forked from */
  forkedFromId: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdForkForkedFromId({
    id: id,
    forkedFromId: forkedFromId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get project hooks
 * @request GET :/v3/projects/{id}/hooks
 * @readonly
 */
export async function getV3GetV3ProjectsIdHooks(
  /** The ID of a project */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<ProjectHook> {
  const result = await api.v3.getV3ProjectsIdHooks({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add hook to project
 * @request POST :/v3/projects/{id}/hooks
 */
export async function postV3PostV3ProjectsIdHooks(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The URL to send the request to */
    url: string,
  /** Trigger hook on push events */
    push_events?: boolean,
  /** Trigger hook on issues events */
    issues_events?: boolean,
  /** Trigger hook on merge request events */
    merge_requests_events?: boolean,
  /** Trigger hook on tag push events */
    tag_push_events?: boolean,
  /** Trigger hook on note(comment) events */
    note_events?: boolean,
  /** Trigger hook on build events */
    build_events?: boolean,
  /** Trigger hook on pipeline events */
    pipeline_events?: boolean,
  /** Trigger hook on wiki events */
    wiki_page_events?: boolean,
  /** Do SSL verification when triggering the hook */
    enable_ssl_verification?: boolean,
  /** Secret token to validate received payloads; this will not be returned in the response */
    token?: string,

},      
): Promise<ProjectHook> {
  const result = await api.v3.postV3ProjectsIdHooks({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Deletes project hook
 * @request DELETE :/v3/projects/{id}/hooks/{hook_id}
 */
export async function deleteV3DeleteV3ProjectsIdHooksHookId(
  /** The ID of a project */
  id: string,      
  /** The ID of the hook to delete */
  hookId: number,      
): Promise<ProjectHook> {
  const result = await api.v3.deleteV3ProjectsIdHooksHookId({
    id: id,
    hookId: hookId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a project hook
 * @request GET :/v3/projects/{id}/hooks/{hook_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdHooksHookId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project hook */
  hookId: number,      
): Promise<ProjectHook> {
  const result = await api.v3.getV3ProjectsIdHooksHookId({
    id: id,
    hookId: hookId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing project hook
 * @request PUT :/v3/projects/{id}/hooks/{hook_id}
 */
export async function putV3PutV3ProjectsIdHooksHookId(
  /** The ID of a project */
  id: string,      
  /** The ID of the hook to update */
  hookId: number,      
  /** Request body */
  data: {
  /** The URL to send the request to */
    url: string,
  /** Trigger hook on push events */
    push_events?: boolean,
  /** Trigger hook on issues events */
    issues_events?: boolean,
  /** Trigger hook on merge request events */
    merge_requests_events?: boolean,
  /** Trigger hook on tag push events */
    tag_push_events?: boolean,
  /** Trigger hook on note(comment) events */
    note_events?: boolean,
  /** Trigger hook on build events */
    build_events?: boolean,
  /** Trigger hook on pipeline events */
    pipeline_events?: boolean,
  /** Trigger hook on wiki events */
    wiki_page_events?: boolean,
  /** Do SSL verification when triggering the hook */
    enable_ssl_verification?: boolean,
  /** Secret token to validate received payloads; this will not be returned in the response */
    token?: string,

},      
): Promise<ProjectHook> {
  const result = await api.v3.putV3ProjectsIdHooksHookId({
    id: id,
    hookId: hookId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project issues
 * @request GET :/v3/projects/{id}/issues
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssues(
  /** The ID of a project */
  id: string,      
  /** Return opened, closed, or all issues */
  state?: "opened" | "closed" | "all",      
  /** Return the issue having the given `iid` */
  iid?: number,      
  /** Comma-separated list of label names */
  labels?: string,      
  /** Return issues for a specific milestone */
  milestone?: string,      
  /** Return issues ordered by `created_at` or `updated_at` fields. */
  order_by?: "created_at" | "updated_at",      
  /** Return issues sorted in `asc` or `desc` order. */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Issue> {
  const result = await api.v3.getV3ProjectsIdIssues({
    query: {
      state: state,
      iid: iid,
      labels: labels,
      milestone: milestone,
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new project issue
 * @request POST :/v3/projects/{id}/issues
 */
export async function postV3PostV3ProjectsIdIssues(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The title of an issue */
    title: string,
  /**
   * Date time when the issue was created. Available only for admins and project owners.
   * @format date-time
   */
    created_at?: string,
  /**
   * The IID of a merge request for which to resolve discussions
   * @format int32
   */
    merge_request_for_resolving_discussions?: number,
  /** The description of an issue */
    description?: string,
  /**
   * The ID of a user to assign issue
   * @format int32
   */
    assignee_id?: number,
  /**
   * The ID of a milestone to assign issue
   * @format int32
   */
    milestone_id?: number,
  /** Comma-separated list of label names */
    labels?: string,
  /** Date time string in the format YEAR-MONTH-DAY */
    due_date?: string,
  /** Boolean parameter if the issue should be confidential */
    confidential?: boolean,

},      
): Promise<Issue> {
  const result = await api.v3.postV3ProjectsIdIssues({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a project issue
 * @request DELETE :/v3/projects/{id}/issues/{issue_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdIssuesIssueId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdIssuesIssueId({
    id: id,
    issueId: issueId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single project issue
 * @request GET :/v3/projects/{id}/issues/{issue_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
): Promise<Issue> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueId({
    id: id,
    issueId: issueId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing issue
 * @request PUT :/v3/projects/{id}/issues/{issue_id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdIssuesIssueId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
  /** Request body */
  data: {
  /** The title of an issue */
    title?: string,
  /**
   * Date time when the issue was updated. Available only for admins and project owners.
   * @format date-time
   */
    updated_at?: string,
  /** State of the issue */
    state_event?: "reopen" | "close",
  /** The description of an issue */
    description?: string,
  /**
   * The ID of a user to assign issue
   * @format int32
   */
    assignee_id?: number,
  /**
   * The ID of a milestone to assign issue
   * @format int32
   */
    milestone_id?: number,
  /** Comma-separated list of label names */
    labels?: string,
  /** Date time string in the format YEAR-MONTH-DAY */
    due_date?: string,
  /** Boolean parameter if the issue should be confidential */
    confidential?: boolean,
    created_at?: string,

},      
): Promise<Issue> {
  const result = await api.v3.putV3ProjectsIdIssuesIssueId({
    id: id,
    issueId: issueId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add spent time for a project issue
 * @request POST :/v3/projects/{id}/issues/{issue_id}/add_spent_time
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdAddSpentTime(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
  /** Request body */
  data: {
  /** The duration to be parsed */
    duration: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdAddSpentTime({
    id: id,
    issueId: issueId,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/issues/{issue_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueIdAwardEmoji(
  /** The ID of a project */
  id: string,      
  /** The ID of an Issue, Merge Request or Snippet */
  issueId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    issueId: issueId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/issues/{issue_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdAwardEmoji({
    id: id,
    issueId: issueId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/issues/{issue_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    issueId: issueId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/issues/{issue_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    issueId: issueId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Move an existing issue
 * @request POST :/v3/projects/{id}/issues/{issue_id}/move
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdMove(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
  /** Request body */
  data: {
  /**
   * The ID of the new project
   * @format int32
   */
    to_project_id: number,

},      
): Promise<Issue> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdMove({
    id: id,
    issueId: issueId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
  /** undefined */
  noteId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    issueId: issueId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
  /** undefined */
  noteId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji({
    id: id,
    issueId: issueId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    issueId: issueId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  issueId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    issueId: issueId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset spent time for a project issue
 * @request POST :/v3/projects/{id}/issues/{issue_id}/reset_spent_time
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdResetSpentTime(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdResetSpentTime({
    id: id,
    issueId: issueId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Reset the time estimate for a project issue
 * @request POST :/v3/projects/{id}/issues/{issue_id}/reset_time_estimate
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdResetTimeEstimate(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdResetTimeEstimate({
    id: id,
    issueId: issueId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set a time estimate for a project issue
 * @request POST :/v3/projects/{id}/issues/{issue_id}/time_estimate
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdTimeEstimate(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
  /** Request body */
  data: {
  /** The duration to be parsed */
    duration: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdTimeEstimate({
    id: id,
    issueId: issueId,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Show time stats for a project issue
 * @request GET :/v3/projects/{id}/issues/{issue_id}/time_stats
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesIssueIdTimeStats(
  /** The ID of a project */
  id: string,      
  /** The ID of a project issue */
  issueId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdIssuesIssueIdTimeStats({
    id: id,
    issueId: issueId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Create a todo on an issuable
 * @request POST :/v3/projects/{id}/issues/{issue_id}/todo
 */
export async function postV3PostV3ProjectsIdIssuesIssueIdTodo(
  /** The ID of a project */
  id: string,      
  /** The ID of an issuable */
  issueId: number,      
): Promise<Todo> {
  const result = await api.v3.postV3ProjectsIdIssuesIssueIdTodo({
    id: id,
    issueId: issueId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +noteable+ notes
 * @request GET :/v3/projects/{id}/issues/{noteable_id}/notes
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdIssuesNoteableIdNotes({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new +noteable+ note
 * @request POST :/v3/projects/{id}/issues/{noteable_id}/notes
 */
export async function postV3PostV3ProjectsIdIssuesNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,
  /** The creation date of the note */
    created_at?: string,

},      
): Promise<Note> {
  const result = await api.v3.postV3ProjectsIdIssuesNoteableIdNotes({
    id: id,
    noteableId: noteableId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +noteable+ note
 * @request DELETE :/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}
 */
export async function deleteV3DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
): Promise<Note> {
  const result = await api.v3.deleteV3ProjectsIdIssuesNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single +noteable+ note
 * @request GET :/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdIssuesNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of a note */
  noteId: number,      
  /** The ID of the noteable */
  noteableId: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdIssuesNoteableIdNotesNoteId({
    id: id,
    noteId: noteId,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing +noteable+ note
 * @request PUT :/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}
 */
export async function putV3PutV3ProjectsIdIssuesNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,

},      
): Promise<Note> {
  const result = await api.v3.putV3ProjectsIdIssuesNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unsubscribe from a resource
 * @request DELETE :/v3/projects/{id}/issues/{subscribable_id}/subscription
 */
export async function deleteV3DeleteV3ProjectsIdIssuesSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<Issue> {
  const result = await api.v3.deleteV3ProjectsIdIssuesSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Subscribe to a resource
 * @request POST :/v3/projects/{id}/issues/{subscribable_id}/subscription
 */
export async function postV3PostV3ProjectsIdIssuesSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<Issue> {
  const result = await api.v3.postV3ProjectsIdIssuesSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific project's deploy keys
 * @request GET :/v3/projects/{id}/keys
 * @readonly
 */
export async function getV3GetV3ProjectsIdKeys(
  /** The ID of the project */
  id: string,      
): Promise<SSHKey> {
  const result = await api.v3.getV3ProjectsIdKeys({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add new deploy key to currently authenticated user
 * @request POST :/v3/projects/{id}/keys
 */
export async function postV3PostV3ProjectsIdKeys(
  /** The ID of the project */
  id: string,      
  /** Request body */
  data: {
  /** The new deploy key */
    key: string,
  /** The name of the deploy key */
    title: string,

},      
): Promise<SSHKey> {
  const result = await api.v3.postV3ProjectsIdKeys({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete deploy key for a project
 * @request DELETE :/v3/projects/{id}/keys/{key_id}
 */
export async function deleteV3DeleteV3ProjectsIdKeysKeyId(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3ProjectsIdKeysKeyId({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get single deploy key
 * @request GET :/v3/projects/{id}/keys/{key_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdKeysKeyId(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.getV3ProjectsIdKeysKeyId({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Disable a deploy key for a project
 * @request DELETE :/v3/projects/{id}/keys/{key_id}/disable
 */
export async function deleteV3DeleteV3ProjectsIdKeysKeyIdDisable(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3ProjectsIdKeysKeyIdDisable({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Enable a deploy key for a project
 * @request POST :/v3/projects/{id}/keys/{key_id}/enable
 */
export async function postV3PostV3ProjectsIdKeysKeyIdEnable(
  /** The ID of the project */
  id: string,      
  /** The ID of the deploy key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.postV3ProjectsIdKeysKeyIdEnable({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an existing label
 * @request DELETE :/v3/projects/{id}/labels
 */
export async function deleteV3DeleteV3ProjectsIdLabels(
  /** The name of the label to be deleted */
  name: string,      
  /** The ID of a project */
  id: string,      
): Promise<Label> {
  const result = await api.v3.deleteV3ProjectsIdLabels({
    query: {
      name: name,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all labels of the project
 * @request GET :/v3/projects/{id}/labels
 * @readonly
 */
export async function getV3GetV3ProjectsIdLabels(
  /** The ID of a project */
  id: string,      
): Promise<Label> {
  const result = await api.v3.getV3ProjectsIdLabels({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new label
 * @request POST :/v3/projects/{id}/labels
 */
export async function postV3PostV3ProjectsIdLabels(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of the label to be created */
    name: string,
  /** The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) */
    color: string,
  /** The description of label to be created */
    description?: string,
  /**
   * The priority of the label
   * @format int32
   */
    priority?: number,

},      
): Promise<Label> {
  const result = await api.v3.postV3ProjectsIdLabels({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing label. At least one optional parameter is required.
 * @request PUT :/v3/projects/{id}/labels
 */
export async function putV3PutV3ProjectsIdLabels(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of the label to be updated */
    name: string,
  /** The new name of the label */
    new_name?: string,
  /** The new color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) */
    color?: string,
  /** The new description of label */
    description?: string,
  /**
   * The priority of the label
   * @format int32
   */
    priority?: number,

},      
): Promise<Label> {
  const result = await api.v3.putV3ProjectsIdLabels({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unsubscribe from a resource
 * @request DELETE :/v3/projects/{id}/labels/{subscribable_id}/subscription
 */
export async function deleteV3DeleteV3ProjectsIdLabelsSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<Label> {
  const result = await api.v3.deleteV3ProjectsIdLabelsSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Subscribe to a resource
 * @request POST :/v3/projects/{id}/labels/{subscribable_id}/subscription
 */
export async function postV3PostV3ProjectsIdLabelsSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<Label> {
  const result = await api.v3.postV3ProjectsIdLabelsSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a list of group or project members viewable by the authenticated user.
 * @request GET :/v3/projects/{id}/members
 * @readonly
 */
export async function getV3GetV3ProjectsIdMembers(
  /** The project ID */
  id: string,      
  /** A query string to search for members */
  query?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Member> {
  const result = await api.v3.getV3ProjectsIdMembers({
    query: {
      query: query,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Adds a member to a group or project.
 * @request POST :/v3/projects/{id}/members
 */
export async function postV3PostV3ProjectsIdMembers(
  /** The project ID */
  id: string,      
  /** Request body */
  data: {
  /**
   * The user ID of the new member
   * @format int32
   */
    user_id: number,
  /**
   * A valid access level (defaults: `30`, developer access level)
   * @format int32
   */
    access_level: number,
  /**
   * Date string in the format YEAR-MONTH-DAY
   * @format date-time
   */
    expires_at?: string,

},      
): Promise<Member> {
  const result = await api.v3.postV3ProjectsIdMembers({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Removes a user from a group or project.
 * @request DELETE :/v3/projects/{id}/members/{user_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdMembersUserId(
  /** The project ID */
  id: string,      
  /** The user ID of the member */
  userId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdMembersUserId({
    id: id,
    userId: userId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Gets a member of a group or project.
 * @request GET :/v3/projects/{id}/members/{user_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMembersUserId(
  /** The project ID */
  id: string,      
  /** The user ID of the member */
  userId: number,      
): Promise<Member> {
  const result = await api.v3.getV3ProjectsIdMembersUserId({
    id: id,
    userId: userId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Updates a member of a group or project.
 * @request PUT :/v3/projects/{id}/members/{user_id}
 */
export async function putV3PutV3ProjectsIdMembersUserId(
  /** The project ID */
  id: string,      
  /** The user ID of the new member */
  userId: number,      
  /** Request body */
  data: {
  /**
   * A valid access level
   * @format int32
   */
    access_level: number,
  /**
   * Date string in the format YEAR-MONTH-DAY
   * @format date-time
   */
    expires_at?: string,

},      
): Promise<Member> {
  const result = await api.v3.putV3ProjectsIdMembersUserId({
    id: id,
    userId: userId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single merge request
 * @request GET :/v3/projects/{id}/merge_request/{merge_request_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestMergeRequestId(
  /** The ID of a project */
  id: string,      
  /** The ID of a merge request */
  mergeRequestId: number,      
): Promise<MergeRequest> {
  const result = await api.v3.getV3ProjectsIdMergeRequestMergeRequestId({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update a merge request
 * @request PUT :/v3/projects/{id}/merge_request/{merge_request_id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdMergeRequestMergeRequestId(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The title of the merge request */
    title?: string,
  /** The target branch */
    target_branch?: string,
  /** Status of the merge request */
    state_event?: "close" | "reopen" | "merge",
  /** The description of the merge request */
    description?: string,
  /**
   * The ID of a user to assign the merge request
   * @format int32
   */
    assignee_id?: number,
  /**
   * The ID of a milestone to assign the merge request
   * @format int32
   */
    milestone_id?: number,
  /** Comma-separated list of label names */
    labels?: string,
  /** Remove source branch when merging */
    remove_source_branch?: boolean,

},      
): Promise<MergeRequest> {
  const result = await api.v3.putV3ProjectsIdMergeRequestMergeRequestId({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Cancel merge if "Merge When Pipeline Succeeds" is enabled
 * @request POST :/v3/projects/{id}/merge_request/{merge_request_id}/cancel_merge_when_build_succeeds
 */
export async function postV3PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<MergeRequest> {
  const result = await api.v3.postV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Show the merge request changes
 * @request GET :/v3/projects/{id}/merge_request/{merge_request_id}/changes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestMergeRequestIdChanges(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<MergeRequestChanges> {
  const result = await api.v3.getV3ProjectsIdMergeRequestMergeRequestIdChanges({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * List issues that will be closed on merge
 * @request GET :/v3/projects/{id}/merge_request/{merge_request_id}/closes_issues
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<MRNote> {
  const result = await api.v3.getV3ProjectsIdMergeRequestMergeRequestIdClosesIssues({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the comments of a merge request
 * @request GET :/v3/projects/{id}/merge_request/{merge_request_id}/comments
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestMergeRequestIdComments(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<MRNote> {
  const result = await api.v3.getV3ProjectsIdMergeRequestMergeRequestIdComments({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Post a comment to a merge request
 * @request POST :/v3/projects/{id}/merge_request/{merge_request_id}/comments
 */
export async function postV3PostV3ProjectsIdMergeRequestMergeRequestIdComments(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The text of the comment */
    note: string,

},      
): Promise<MRNote> {
  const result = await api.v3.postV3ProjectsIdMergeRequestMergeRequestIdComments({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the commits of a merge request
 * @request GET :/v3/projects/{id}/merge_request/{merge_request_id}/commits
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestMergeRequestIdCommits(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<RepoCommit> {
  const result = await api.v3.getV3ProjectsIdMergeRequestMergeRequestIdCommits({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Merge a merge request
 * @request PUT :/v3/projects/{id}/merge_request/{merge_request_id}/merge
 */
export async function putV3PutV3ProjectsIdMergeRequestMergeRequestIdMerge(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** Custom merge commit message */
    merge_commit_message?: string,
  /** When true, the source branch will be deleted if possible */
    should_remove_source_branch?: boolean,
  /** When true, this merge request will be merged when the pipeline succeeds */
    merge_when_build_succeeds?: boolean,
  /** When present, must have the HEAD SHA of the source branch */
    sha?: string,

},      
): Promise<MergeRequest> {
  const result = await api.v3.putV3ProjectsIdMergeRequestMergeRequestIdMerge({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unsubscribe from a resource
 * @request DELETE :/v3/projects/{id}/merge_request/{subscribable_id}/subscription
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<MergeRequest> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Subscribe to a resource
 * @request POST :/v3/projects/{id}/merge_request/{subscribable_id}/subscription
 */
export async function postV3PostV3ProjectsIdMergeRequestSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<MergeRequest> {
  const result = await api.v3.postV3ProjectsIdMergeRequestSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * List merge requests
 * @request GET :/v3/projects/{id}/merge_requests
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequests(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The IID of the merge requests */
    iid?: (number)[],

},      
  /** Return opened, closed, merged, or all merge requests */
  state?: "opened" | "closed" | "merged" | "all",      
  /** Return merge requests ordered by `created_at` or `updated_at` fields. */
  order_by?: "created_at" | "updated_at",      
  /** Return merge requests sorted in `asc` or `desc` order. */
  sort?: "asc" | "desc",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<MergeRequest> {
  const result = await api.v3.getV3ProjectsIdMergeRequests({
    query: {
      state: state,
      order_by: order_by,
      sort: sort,
      page: page,
      per_page: per_page,
    },
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a merge request
 * @request POST :/v3/projects/{id}/merge_requests
 */
export async function postV3PostV3ProjectsIdMergeRequests(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The title of the merge request */
    title: string,
  /** The source branch */
    source_branch: string,
  /** The target branch */
    target_branch: string,
  /**
   * The target project of the merge request defaults to the :id of the project
   * @format int32
   */
    target_project_id?: number,
  /** The description of the merge request */
    description?: string,
  /**
   * The ID of a user to assign the merge request
   * @format int32
   */
    assignee_id?: number,
  /**
   * The ID of a milestone to assign the merge request
   * @format int32
   */
    milestone_id?: number,
  /** Comma-separated list of label names */
    labels?: string,
  /** Remove source branch when merging */
    remove_source_branch?: boolean,

},      
): Promise<MergeRequest> {
  const result = await api.v3.postV3ProjectsIdMergeRequests({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a merge request
 * @request DELETE :/v3/projects/{id}/merge_requests/{merge_request_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestsMergeRequestId(
  /** The ID of a project */
  id: string,      
  /** The ID of a merge request */
  mergeRequestId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestsMergeRequestId({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single merge request
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestId(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<MergeRequest> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestId({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update a merge request
 * @request PUT :/v3/projects/{id}/merge_requests/{merge_request_id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdMergeRequestsMergeRequestId(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The title of the merge request */
    title?: string,
  /** The target branch */
    target_branch?: string,
  /** Status of the merge request */
    state_event?: "close" | "reopen" | "merge",
  /** The description of the merge request */
    description?: string,
  /**
   * The ID of a user to assign the merge request
   * @format int32
   */
    assignee_id?: number,
  /**
   * The ID of a milestone to assign the merge request
   * @format int32
   */
    milestone_id?: number,
  /** Comma-separated list of label names */
    labels?: string,
  /** Remove source branch when merging */
    remove_source_branch?: boolean,

},      
): Promise<MergeRequest> {
  const result = await api.v3.putV3ProjectsIdMergeRequestsMergeRequestId({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add spent time for a project merge_request
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/add_spent_time
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime(
  /** The ID of a project */
  id: string,      
  /** The ID of a project merge_request */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The duration to be parsed */
    duration: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji(
  /** The ID of a project */
  id: string,      
  /** The ID of an Issue, Merge Request or Snippet */
  mergeRequestId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Cancel merge if "Merge When Pipeline Succeeds" is enabled
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/cancel_merge_when_build_succeeds
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<MergeRequest> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Show the merge request changes
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/changes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdChanges(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<MergeRequestChanges> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdChanges({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * List issues that will be closed on merge
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/closes_issues
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<MRNote> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the comments of a merge request
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/comments
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdComments(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<MRNote> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdComments({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Post a comment to a merge request
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/comments
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdComments(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The text of the comment */
    note: string,

},      
): Promise<MRNote> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdComments({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the commits of a merge request
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/commits
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdCommits(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
): Promise<RepoCommit> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdCommits({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Merge a merge request
 * @request PUT :/v3/projects/{id}/merge_requests/{merge_request_id}/merge
 */
export async function putV3PutV3ProjectsIdMergeRequestsMergeRequestIdMerge(
  /** The ID of a project */
  id: string,      
  /** undefined */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** Custom merge commit message */
    merge_commit_message?: string,
  /** When true, the source branch will be deleted if possible */
    should_remove_source_branch?: boolean,
  /** When true, this merge request will be merged when the pipeline succeeds */
    merge_when_build_succeeds?: boolean,
  /** When present, must have the HEAD SHA of the source branch */
    sha?: string,

},      
): Promise<MergeRequest> {
  const result = await api.v3.putV3ProjectsIdMergeRequestsMergeRequestIdMerge({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
  /** undefined */
  noteId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    mergeRequestId: mergeRequestId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
  /** undefined */
  noteId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji({
    id: id,
    mergeRequestId: mergeRequestId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    mergeRequestId: mergeRequestId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  mergeRequestId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    mergeRequestId: mergeRequestId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Reset spent time for a project merge_request
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/reset_spent_time
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime(
  /** The ID of a project */
  id: string,      
  /** The ID of a project merge_request */
  mergeRequestId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Reset the time estimate for a project merge_request
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/reset_time_estimate
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate(
  /** The ID of a project */
  id: string,      
  /** The ID of a project merge_request */
  mergeRequestId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set a time estimate for a project merge_request
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/time_estimate
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate(
  /** The ID of a project */
  id: string,      
  /** The ID of a project merge_request */
  mergeRequestId: number,      
  /** Request body */
  data: {
  /** The duration to be parsed */
    duration: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate({
    id: id,
    mergeRequestId: mergeRequestId,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Show time stats for a project merge_request
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/time_stats
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats(
  /** The ID of a project */
  id: string,      
  /** The ID of a project merge_request */
  mergeRequestId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdTimeStats({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Create a todo on an issuable
 * @request POST :/v3/projects/{id}/merge_requests/{merge_request_id}/todo
 */
export async function postV3PostV3ProjectsIdMergeRequestsMergeRequestIdTodo(
  /** The ID of a project */
  id: string,      
  /** The ID of an issuable */
  mergeRequestId: number,      
): Promise<Todo> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsMergeRequestIdTodo({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of merge request diff versions
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/versions
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdVersions(
  /** The ID of a project */
  id: string,      
  /** The ID of a merge request */
  mergeRequestId: number,      
): Promise<MergeRequestDiff> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdVersions({
    id: id,
    mergeRequestId: mergeRequestId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single merge request diff version
 * @request GET :/v3/projects/{id}/merge_requests/{merge_request_id}/versions/{version_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId(
  /** The ID of a project */
  id: string,      
  /** The ID of a merge request */
  mergeRequestId: number,      
  /** The ID of a merge request diff version */
  versionId: number,      
): Promise<MergeRequestDiffFull> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId({
    id: id,
    mergeRequestId: mergeRequestId,
    versionId: versionId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +noteable+ notes
 * @request GET :/v3/projects/{id}/merge_requests/{noteable_id}/notes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsNoteableIdNotes({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new +noteable+ note
 * @request POST :/v3/projects/{id}/merge_requests/{noteable_id}/notes
 */
export async function postV3PostV3ProjectsIdMergeRequestsNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,
  /** The creation date of the note */
    created_at?: string,

},      
): Promise<Note> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsNoteableIdNotes({
    id: id,
    noteableId: noteableId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +noteable+ note
 * @request DELETE :/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
): Promise<Note> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single +noteable+ note
 * @request GET :/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of a note */
  noteId: number,      
  /** The ID of the noteable */
  noteableId: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdMergeRequestsNoteableIdNotesNoteId({
    id: id,
    noteId: noteId,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing +noteable+ note
 * @request PUT :/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}
 */
export async function putV3PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,

},      
): Promise<Note> {
  const result = await api.v3.putV3ProjectsIdMergeRequestsNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unsubscribe from a resource
 * @request DELETE :/v3/projects/{id}/merge_requests/{subscribable_id}/subscription
 */
export async function deleteV3DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<MergeRequest> {
  const result = await api.v3.deleteV3ProjectsIdMergeRequestsSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Subscribe to a resource
 * @request POST :/v3/projects/{id}/merge_requests/{subscribable_id}/subscription
 */
export async function postV3PostV3ProjectsIdMergeRequestsSubscribableIdSubscription(
  /** The ID of a project */
  id: string,      
  /** The ID of a resource */
  subscribableId: string,      
): Promise<MergeRequest> {
  const result = await api.v3.postV3ProjectsIdMergeRequestsSubscribableIdSubscription({
    id: id,
    subscribableId: subscribableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project milestones
 * @request GET :/v3/projects/{id}/milestones
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdMilestones(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The IID of the milestone */
    iid?: (number)[],

},      
  /** Return "active", "closed", or "all" milestones */
  state?: "active" | "closed" | "all",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Milestone> {
  const result = await api.v3.getV3ProjectsIdMilestones({
    query: {
      state: state,
      page: page,
      per_page: per_page,
    },
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new project milestone
 * @request POST :/v3/projects/{id}/milestones
 */
export async function postV3PostV3ProjectsIdMilestones(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The title of the milestone */
    title: string,
  /** The description of the milestone */
    description?: string,
  /** The due date of the milestone. The ISO 8601 date format (%Y-%m-%d) */
    due_date?: string,
  /** The start date of the milestone. The ISO 8601 date format (%Y-%m-%d) */
    start_date?: string,

},      
): Promise<Milestone> {
  const result = await api.v3.postV3ProjectsIdMilestones({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single project milestone
 * @request GET :/v3/projects/{id}/milestones/{milestone_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdMilestonesMilestoneId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project milestone */
  milestoneId: number,      
): Promise<Milestone> {
  const result = await api.v3.getV3ProjectsIdMilestonesMilestoneId({
    id: id,
    milestoneId: milestoneId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing project milestone
 * @request PUT :/v3/projects/{id}/milestones/{milestone_id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdMilestonesMilestoneId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project milestone */
  milestoneId: number,      
  /** Request body */
  data: {
  /** The title of the milestone */
    title?: string,
  /** The state event of the milestone  */
    state_event?: "close" | "activate",
  /** The description of the milestone */
    description?: string,
  /** The due date of the milestone. The ISO 8601 date format (%Y-%m-%d) */
    due_date?: string,
  /** The start date of the milestone. The ISO 8601 date format (%Y-%m-%d) */
    start_date?: string,

},      
): Promise<Milestone> {
  const result = await api.v3.putV3ProjectsIdMilestonesMilestoneId({
    id: id,
    milestoneId: milestoneId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all issues for a single project milestone
 * @request GET :/v3/projects/{id}/milestones/{milestone_id}/issues
 * @readonly
 */
export async function getV3GetV3ProjectsIdMilestonesMilestoneIdIssues(
  /** The ID of a project */
  id: string,      
  /** The ID of a project milestone */
  milestoneId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Issue> {
  const result = await api.v3.getV3ProjectsIdMilestonesMilestoneIdIssues({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    milestoneId: milestoneId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get project level notification level settings, defaults to Global
 * @request GET :/v3/projects/{id}/notification_settings
 * @readonly
 */
export async function getV3GetV3ProjectsIdNotificationSettings(
  /** The group ID or project ID or project NAMESPACE/PROJECT_NAME */
  id: string,      
): Promise<NotificationSetting> {
  const result = await api.v3.getV3ProjectsIdNotificationSettings({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update project level notification level settings, defaults to Global
 * @request PUT :/v3/projects/{id}/notification_settings
 */
export async function putV3PutV3ProjectsIdNotificationSettings(
  /** The group ID or project ID or project NAMESPACE/PROJECT_NAME */
  id: string,      
  /** Request body */
  data: {
  /** The project notification level */
    level?: string,
  /** Enable/disable this notification */
    new_note?: boolean,
  /** Enable/disable this notification */
    new_issue?: boolean,
  /** Enable/disable this notification */
    reopen_issue?: boolean,
  /** Enable/disable this notification */
    close_issue?: boolean,
  /** Enable/disable this notification */
    reassign_issue?: boolean,
  /** Enable/disable this notification */
    new_merge_request?: boolean,
  /** Enable/disable this notification */
    reopen_merge_request?: boolean,
  /** Enable/disable this notification */
    close_merge_request?: boolean,
  /** Enable/disable this notification */
    reassign_merge_request?: boolean,
  /** Enable/disable this notification */
    merge_merge_request?: boolean,
  /** Enable/disable this notification */
    failed_pipeline?: boolean,
  /** Enable/disable this notification */
    success_pipeline?: boolean,

},      
): Promise<NotificationSetting> {
  const result = await api.v3.putV3ProjectsIdNotificationSettings({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new pipeline
 * @request POST :/v3/projects/{id}/pipeline
 */
export async function postV3PostV3ProjectsIdPipeline(
  /** The project ID */
  id: string,      
  /** Request body */
  data: {
  /** Reference */
    ref: string,

},      
): Promise<Pipeline> {
  const result = await api.v3.postV3ProjectsIdPipeline({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all Pipelines of the project
 * @request GET :/v3/projects/{id}/pipelines
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdPipelines(
  /** The project ID */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
  /** Either running, branches, or tags */
  scope?: "running" | "branches" | "tags",      
): Promise<Pipeline> {
  const result = await api.v3.getV3ProjectsIdPipelines({
    query: {
      page: page,
      per_page: per_page,
      scope: scope,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Gets a specific pipeline for the project
 * @request GET :/v3/projects/{id}/pipelines/{pipeline_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdPipelinesPipelineId(
  /** The project ID */
  id: string,      
  /** The pipeline ID */
  pipelineId: number,      
): Promise<Pipeline> {
  const result = await api.v3.getV3ProjectsIdPipelinesPipelineId({
    id: id,
    pipelineId: pipelineId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Cancel all builds in the pipeline
 * @request POST :/v3/projects/{id}/pipelines/{pipeline_id}/cancel
 */
export async function postV3PostV3ProjectsIdPipelinesPipelineIdCancel(
  /** The project ID */
  id: string,      
  /** The pipeline ID */
  pipelineId: number,      
): Promise<Pipeline> {
  const result = await api.v3.postV3ProjectsIdPipelinesPipelineIdCancel({
    id: id,
    pipelineId: pipelineId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Retry failed builds in the pipeline
 * @request POST :/v3/projects/{id}/pipelines/{pipeline_id}/retry
 */
export async function postV3PostV3ProjectsIdPipelinesPipelineIdRetry(
  /** The project ID */
  id: string,      
  /** The pipeline ID */
  pipelineId: number,      
): Promise<Pipeline> {
  const result = await api.v3.postV3ProjectsIdPipelinesPipelineIdRetry({
    id: id,
    pipelineId: pipelineId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get an archive of the repository
 * @request GET :/v3/projects/{id}/repository/archive
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryArchive(
  /** The ID of a project */
  id: string,      
  /** The commit sha of the archive to be downloaded */
  sha?: string,      
  /** The archive format */
  format?: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryArchive({
    query: {
      sha: sha,
      format: format,
    },
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a raw file contents
 * @request GET :/v3/projects/{id}/repository/blobs/{sha}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryBlobsSha(
  /** The path to the file to display */
  filepath: string,      
  /** The ID of a project */
  id: string,      
  /** The commit, branch name, or tag name */
  sha: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryBlobsSha({
    query: {
      filepath: filepath,
    },
    id: id,
    sha: sha,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a project repository branches
 * @request GET :/v3/projects/{id}/repository/branches
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryBranches(
  /** The ID of a project */
  id: string,      
): Promise<RepoBranch> {
  const result = await api.v3.getV3ProjectsIdRepositoryBranches({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create branch
 * @request POST :/v3/projects/{id}/repository/branches
 */
export async function postV3PostV3ProjectsIdRepositoryBranches(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of the branch */
    branch_name: string,
  /** Create branch from commit sha or existing branch */
    ref: string,

},      
): Promise<RepoBranch> {
  const result = await api.v3.postV3ProjectsIdRepositoryBranches({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a branch
 * @request DELETE :/v3/projects/{id}/repository/branches/{branch}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdRepositoryBranchesBranch(
  /** The ID of a project */
  id: string,      
  /** The name of the branch */
  branch: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdRepositoryBranchesBranch({
    id: id,
    branch: branch,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single branch
 * @request GET :/v3/projects/{id}/repository/branches/{branch}
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryBranchesBranch(
  /** The ID of a project */
  id: string,      
  /** The name of the branch */
  branch: string,      
): Promise<RepoBranch> {
  const result = await api.v3.getV3ProjectsIdRepositoryBranchesBranch({
    id: id,
    branch: branch,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Protect a single branch
 * @request PUT :/v3/projects/{id}/repository/branches/{branch}/protect
 */
export async function putV3PutV3ProjectsIdRepositoryBranchesBranchProtect(
  /** The ID of a project */
  id: string,      
  /** The name of the branch */
  branch: string,      
  /** Request body */
  data: {
  /** Flag if developers can push to that branch */
    developers_can_push?: boolean,
  /** Flag if developers can merge to that branch */
    developers_can_merge?: boolean,

},      
): Promise<RepoBranch> {
  const result = await api.v3.putV3ProjectsIdRepositoryBranchesBranchProtect({
    id: id,
    branch: branch,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unprotect a single branch
 * @request PUT :/v3/projects/{id}/repository/branches/{branch}/unprotect
 */
export async function putV3PutV3ProjectsIdRepositoryBranchesBranchUnprotect(
  /** The ID of a project */
  id: string,      
  /** The name of the branch */
  branch: string,      
): Promise<RepoBranch> {
  const result = await api.v3.putV3ProjectsIdRepositoryBranchesBranchUnprotect({
    id: id,
    branch: branch,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a project repository commits
 * @request GET :/v3/projects/{id}/repository/commits
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommits(
  /** The ID of a project */
  id: string,      
  /** The name of a repository branch or tag, if not given the default branch is used */
  ref_name?: string,      
  /** Only commits after or in this date will be returned */
  since?: string,      
  /** Only commits before or in this date will be returned */
  until?: string,      
  /** The page for pagination */
  page?: number,      
  /** The number of results per page */
  per_page?: number,      
  /** The file path */
  path?: string,      
): Promise<RepoCommit> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommits({
    query: {
      ref_name: ref_name,
      since: since,
      until: until,
      page: page,
      per_page: per_page,
      path: path,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Commit multiple file changes as one commit
 * @request POST :/v3/projects/{id}/repository/commits
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdRepositoryCommits(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of branch */
    branch_name: string,
  /** Commit message */
    commit_message: string,
  /** Actions to perform in commit */
    actions: (any)[],
  /** Author email for commit */
    author_email?: string,
  /** Author name for commit */
    author_name?: string,

},      
): Promise<RepoCommitDetail> {
  const result = await api.v3.postV3ProjectsIdRepositoryCommits({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific commit of a project
 * @request GET :/v3/projects/{id}/repository/commits/{sha}
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsSha(
  /** The ID of a project */
  id: string,      
  /** A commit sha, or the name of a branch or tag */
  sha: string,      
): Promise<RepoCommitDetail> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsSha({
    id: id,
    sha: sha,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a raw file contents
 * @request GET :/v3/projects/{id}/repository/commits/{sha}/blob
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsShaBlob(
  /** The path to the file to display */
  filepath: string,      
  /** The ID of a project */
  id: string,      
  /** The commit, branch name, or tag name */
  sha: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsShaBlob({
    query: {
      filepath: filepath,
    },
    id: id,
    sha: sha,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get builds for a specific commit of a project
 * @request GET :/v3/projects/{id}/repository/commits/{sha}/builds
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsShaBuilds(
  /** The ID of a project */
  id: string,      
  /** The SHA id of a commit */
  sha: string,      
  /** The scope of builds to show */
  scope?: "pending" | "running" | "failed" | "success" | "canceled",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Build> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsShaBuilds({
    query: {
      scope: scope,
      page: page,
      per_page: per_page,
    },
    id: id,
    sha: sha,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Cherry pick commit into a branch
 * @request POST :/v3/projects/{id}/repository/commits/{sha}/cherry_pick
 */
export async function postV3PostV3ProjectsIdRepositoryCommitsShaCherryPick(
  /** The ID of a project */
  id: string,      
  /** A commit sha to be cherry picked */
  sha: string,      
  /** Request body */
  data: {
  /** The name of the branch */
    branch: string,

},      
): Promise<RepoCommit> {
  const result = await api.v3.postV3ProjectsIdRepositoryCommitsShaCherryPick({
    id: id,
    sha: sha,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a commit's comments
 * @request GET :/v3/projects/{id}/repository/commits/{sha}/comments
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsShaComments(
  /** The ID of a project */
  id: string,      
  /** A commit sha, or the name of a branch or tag */
  sha: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<CommitNote> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsShaComments({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    sha: sha,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Post comment to commit
 * @request POST :/v3/projects/{id}/repository/commits/{sha}/comments
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdRepositoryCommitsShaComments(
  /** The ID of a project */
  id: string,      
  /** The commit's SHA */
  sha: string,      
  /** Request body */
  data: {
  /** The text of the comment */
    note: string,
  /** The file path */
    path?: string,
  /**
   * The line number
   * @format int32
   */
    line: number,
  /**
   * The type of the line
   * @default "new"
   */
    line_type: "new" | "old",

},      
): Promise<CommitNote> {
  const result = await api.v3.postV3ProjectsIdRepositoryCommitsShaComments({
    id: id,
    sha: sha,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the diff for a specific commit of a project
 * @request GET :/v3/projects/{id}/repository/commits/{sha}/diff
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsShaDiff(
  /** The ID of a project */
  id: string,      
  /** A commit sha, or the name of a branch or tag */
  sha: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsShaDiff({
    id: id,
    sha: sha,
  });
  return new  hasuraSdk.JSONValue(result);
  // if (result.error) {
  //   throw (result.error)
  // } else {
  //   return new hasuraSdk.JSONValue(result.data);
  // }
}

/**
 * Get a commit's statuses
 * @request GET :/v3/projects/{id}/repository/commits/{sha}/statuses
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCommitsShaStatuses(
  /** The ID of a project */
  id: string,      
  /** The commit hash */
  sha: string,      
  /** The ref */
  ref?: string,      
  /** The stage */
  stage?: string,      
  /** The name */
  name?: string,      
  /** Show all statuses, default: false */
  all?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<CommitStatus> {
  const result = await api.v3.getV3ProjectsIdRepositoryCommitsShaStatuses({
    query: {
      ref: ref,
      stage: stage,
      name: name,
      all: all,
      page: page,
      per_page: per_page,
    },
    id: id,
    sha: sha,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Compare two branches, tags, or commits
 * @request GET :/v3/projects/{id}/repository/compare
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryCompare(
  /** The commit, branch name, or tag name to start comparison */
  from: string,      
  /** The commit, branch name, or tag name to stop comparison */
  to: string,      
  /** The ID of a project */
  id: string,      
): Promise<Compare> {
  const result = await api.v3.getV3ProjectsIdRepositoryCompare({
    query: {
      from: from,
      to: to,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get repository contributors
 * @request GET :/v3/projects/{id}/repository/contributors
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryContributors(
  /** The ID of a project */
  id: string,      
): Promise<Contributor> {
  const result = await api.v3.getV3ProjectsIdRepositoryContributors({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an existing file in repository
 * @request DELETE :/v3/projects/{id}/repository/files
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdRepositoryFiles(
  /** The path to new file. Ex. lib/class.rb */
  file_path: string,      
  /** The name of branch */
  branch_name: string,      
  /** Commit Message */
  commit_message: string,      
  /** The project ID */
  id: string,      
  /** The email of the author */
  author_email?: string,      
  /** The name of the author */
  author_name?: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdRepositoryFiles({
    query: {
      file_path: file_path,
      branch_name: branch_name,
      commit_message: commit_message,
      author_email: author_email,
      author_name: author_name,
    },
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a file from repository
 * @request GET :/v3/projects/{id}/repository/files
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryFiles(
  /** The path to the file. Ex. lib/class.rb */
  file_path: string,      
  /** The name of branch, tag, or commit */
  ref: string,      
  /** The project ID */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryFiles({
    query: {
      file_path: file_path,
      ref: ref,
    },
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Create new file in repository
 * @request POST :/v3/projects/{id}/repository/files
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdRepositoryFiles(
  /** The project ID */
  id: string,      
  /** Request body */
  data: {
  /** The path to new file. Ex. lib/class.rb */
    file_path: string,
  /** The name of branch */
    branch_name: string,
  /** Commit Message */
    commit_message: string,
  /** The email of the author */
    author_email?: string,
  /** The name of the author */
    author_name?: string,
  /** File content */
    content: string,
  /** File encoding */
    encoding?: "base64",

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdRepositoryFiles({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Update existing file in repository
 * @request PUT :/v3/projects/{id}/repository/files
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdRepositoryFiles(
  /** The project ID */
  id: string,      
  /** Request body */
  data: {
  /** The path to new file. Ex. lib/class.rb */
    file_path: string,
  /** The name of branch */
    branch_name: string,
  /** Commit Message */
    commit_message: string,
  /** The email of the author */
    author_email?: string,
  /** The name of the author */
    author_name?: string,
  /** File content */
    content: string,
  /** File encoding */
    encoding?: "base64",

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdRepositoryFiles({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * undefined
 * @request DELETE :/v3/projects/{id}/repository/merged_branches
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdRepositoryMergedBranches(
  /** The ID of a project */
  id: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdRepositoryMergedBranches({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a raw blob contents by blob sha
 * @request GET :/v3/projects/{id}/repository/raw_blobs/{sha}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryRawBlobsSha(
  /** The ID of a project */
  id: string,      
  /** The commit, branch name, or tag name */
  sha: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdRepositoryRawBlobsSha({
    id: id,
    sha: sha,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a project repository tags
 * @request GET :/v3/projects/{id}/repository/tags
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryTags(
  /** The ID of a project */
  id: string,      
): Promise<RepoTag> {
  const result = await api.v3.getV3ProjectsIdRepositoryTags({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new repository tag
 * @request POST :/v3/projects/{id}/repository/tags
 */
export async function postV3PostV3ProjectsIdRepositoryTags(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The name of the tag */
    tag_name: string,
  /** The commit sha or branch name */
    ref: string,
  /** Specifying a message creates an annotated tag */
    message?: string,
  /** Specifying release notes stored in the GitLab database */
    release_description?: string,

},      
): Promise<RepoTag> {
  const result = await api.v3.postV3ProjectsIdRepositoryTags({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a repository tag
 * @request DELETE :/v3/projects/{id}/repository/tags/{tag_name}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdRepositoryTagsTagName(
  /** The ID of a project */
  id: string,      
  /** The name of the tag */
  tagName: string,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdRepositoryTagsTagName({
    id: id,
    tagName: tagName,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single repository tag
 * @request GET :/v3/projects/{id}/repository/tags/{tag_name}
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryTagsTagName(
  /** The ID of a project */
  id: string,      
  /** The name of the tag */
  tagName: string,      
): Promise<RepoTag> {
  const result = await api.v3.getV3ProjectsIdRepositoryTagsTagName({
    id: id,
    tagName: tagName,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add a release note to a tag
 * @request POST :/v3/projects/{id}/repository/tags/{tag_name}/release
 */
export async function postV3PostV3ProjectsIdRepositoryTagsTagNameRelease(
  /** The ID of a project */
  id: string,      
  /** The name of the tag */
  tagName: string,      
  /** Request body */
  data: {
  /** Release notes with markdown support */
    description: string,

},      
): Promise<Release> {
  const result = await api.v3.postV3ProjectsIdRepositoryTagsTagNameRelease({
    id: id,
    tagName: tagName,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update a tag's release note
 * @request PUT :/v3/projects/{id}/repository/tags/{tag_name}/release
 */
export async function putV3PutV3ProjectsIdRepositoryTagsTagNameRelease(
  /** The ID of a project */
  id: string,      
  /** The name of the tag */
  tagName: string,      
  /** Request body */
  data: {
  /** Release notes with markdown support */
    description: string,

},      
): Promise<Release> {
  const result = await api.v3.putV3ProjectsIdRepositoryTagsTagNameRelease({
    id: id,
    tagName: tagName,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a project repository tree
 * @request GET :/v3/projects/{id}/repository/tree
 * @readonly
 */
export async function getV3GetV3ProjectsIdRepositoryTree(
  /** The ID of a project */
  id: string,      
  /** The name of a repository branch or tag, if not given the default branch is used */
  ref_name?: string,      
  /** The path of the tree */
  path?: string,      
  /** Used to get a recursive tree */
  recursive?: boolean,      
): Promise<RepoTreeObject> {
  const result = await api.v3.getV3ProjectsIdRepositoryTree({
    query: {
      ref_name: ref_name,
      path: path,
      recursive: recursive,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get runners available for project
 * @request GET :/v3/projects/{id}/runners
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdRunners(
  /** The ID of a project */
  id: string,      
  /** The scope of specific runners to show */
  scope?: "active" | "paused" | "online" | "specific" | "shared",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Runner> {
  const result = await api.v3.getV3ProjectsIdRunners({
    query: {
      scope: scope,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Enable a runner for a project
 * @request POST :/v3/projects/{id}/runners
 */
export async function postV3PostV3ProjectsIdRunners(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /**
   * The ID of the runner
   * @format int32
   */
    runner_id: number,

},      
): Promise<Runner> {
  const result = await api.v3.postV3ProjectsIdRunners({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Disable project's runner
 * @request DELETE :/v3/projects/{id}/runners/{runner_id}
 */
export async function deleteV3DeleteV3ProjectsIdRunnersRunnerId(
  /** The ID of a project */
  id: string,      
  /** The ID of the runner */
  runnerId: number,      
): Promise<Runner> {
  const result = await api.v3.deleteV3ProjectsIdRunnersRunnerId({
    id: id,
    runnerId: runnerId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Set asana service for project
 * @request PUT :/v3/projects/{id}/services/asana
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesAsana(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** User API token */
    api_key: string,
  /** Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches */
    restrict_to_branch?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesAsana({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set assembla service for project
 * @request PUT :/v3/projects/{id}/services/assembla
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesAssembla(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The authentication token */
    token: string,
  /** Subdomain setting */
    subdomain?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesAssembla({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set bamboo service for project
 * @request PUT :/v3/projects/{id}/services/bamboo
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesBamboo(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Bamboo root URL like https://bamboo.example.com */
    bamboo_url: string,
  /** Bamboo build plan key like */
    build_key: string,
  /** A user with API access, if applicable */
    username: string,
  /** Passord of the user */
    password: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesBamboo({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set bugzilla service for project
 * @request PUT :/v3/projects/{id}/services/bugzilla
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesBugzilla(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** New issue URL */
    new_issue_url: string,
  /** Issues URL */
    issues_url: string,
  /** Project URL */
    project_url: string,
  /** Description */
    description?: string,
  /** Title */
    title?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesBugzilla({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set buildkite service for project
 * @request PUT :/v3/projects/{id}/services/buildkite
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesBuildkite(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Buildkite project GitLab token */
    token: string,
  /** The buildkite project URL */
    project_url: string,
  /** Enable SSL verification for communication */
    enable_ssl_verification?: boolean,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesBuildkite({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set builds-email service for project
 * @request PUT :/v3/projects/{id}/services/builds-email
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesBuildsEmail(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Comma-separated list of recipient email addresses */
    recipients: string,
  /** Add pusher to recipients list */
    add_pusher?: boolean,
  /** Notify only broken builds */
    notify_only_broken_builds?: boolean,
  /** Event will be triggered when a build status changes */
    build_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesBuildsEmail({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set campfire service for project
 * @request PUT :/v3/projects/{id}/services/campfire
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesCampfire(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Campfire token */
    token: string,
  /** Campfire subdomain */
    subdomain?: string,
  /** Campfire room */
    room?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesCampfire({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set custom-issue-tracker service for project
 * @request PUT :/v3/projects/{id}/services/custom-issue-tracker
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesCustomIssueTracker(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** New issue URL */
    new_issue_url: string,
  /** Issues URL */
    issues_url: string,
  /** Project URL */
    project_url: string,
  /** Description */
    description?: string,
  /** Title */
    title?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesCustomIssueTracker({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set drone-ci service for project
 * @request PUT :/v3/projects/{id}/services/drone-ci
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesDroneCi(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Drone CI token */
    token: string,
  /** Drone CI URL */
    drone_url: string,
  /** Enable SSL verification for communication */
    enable_ssl_verification?: boolean,
  /** Event will be triggered by a push to the repository */
    push_events?: string,
  /** Event will be triggered when a merge request is created/updated/merged */
    merge_request_events?: string,
  /** Event will be triggered when a new tag is pushed to the repository */
    tag_push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesDroneCi({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set emails-on-push service for project
 * @request PUT :/v3/projects/{id}/services/emails-on-push
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesEmailsOnPush(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Comma-separated list of recipient email addresses */
    recipients: string,
  /** Disable code diffs */
    disable_diffs?: boolean,
  /** Send from committer */
    send_from_committer_email?: boolean,
  /** Event will be triggered by a push to the repository */
    push_events?: string,
  /** Event will be triggered when a new tag is pushed to the repository */
    tag_push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesEmailsOnPush({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set external-wiki service for project
 * @request PUT :/v3/projects/{id}/services/external-wiki
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesExternalWiki(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The URL of the external Wiki */
    external_wiki_url: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesExternalWiki({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set flowdock service for project
 * @request PUT :/v3/projects/{id}/services/flowdock
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesFlowdock(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Flowdock token */
    token: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesFlowdock({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set gemnasium service for project
 * @request PUT :/v3/projects/{id}/services/gemnasium
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesGemnasium(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Your personal API key on gemnasium.com */
    api_key: string,
  /** The project's slug on gemnasium.com */
    token: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesGemnasium({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set hipchat service for project
 * @request PUT :/v3/projects/{id}/services/hipchat
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesHipchat(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The room token */
    token: string,
  /** The room name or ID */
    room?: string,
  /** The room color */
    color?: string,
  /** Enable notifications */
    notify?: boolean,
  /** Leave blank for default (v2) */
    api_version?: string,
  /** Leave blank for default. https://hipchat.example.com */
    server?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,
  /** Event will be triggered when an issue is created/updated/closed */
    issue_events?: string,
  /** Event will be triggered when a confidential issue is created/updated/closed */
    confidential_issue_events?: string,
  /** Event will be triggered when a merge request is created/updated/merged */
    merge_request_events?: string,
  /** Event will be triggered when someone adds a comment */
    note_events?: string,
  /** Event will be triggered when a new tag is pushed to the repository */
    tag_push_events?: string,
  /** Event will be triggered when a build status changes */
    build_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesHipchat({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set irker service for project
 * @request PUT :/v3/projects/{id}/services/irker
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesIrker(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Recipients/channels separated by whitespaces */
    recipients: string,
  /** Default: irc://irc.network.net:6697 */
    default_irc_uri?: string,
  /** Server host. Default localhost */
    server_host?: string,
  /**
   * Server port. Default 6659
   * @format int32
   */
    server_port?: number,
  /** Colorize messages */
    colorize_messages?: boolean,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesIrker({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set jira service for project
 * @request PUT :/v3/projects/{id}/services/jira
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesJira(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The URL to the JIRA project which is being linked to this GitLab project, e.g., https://jira.example.com */
    url: string,
  /** The short identifier for your JIRA project, all uppercase, e.g., PROJ */
    project_key: string,
  /** The username of the user created to be used with GitLab/JIRA */
    username?: string,
  /** The password of the user created to be used with GitLab/JIRA */
    password?: string,
  /**
   * The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (**Administration > Issues > Workflows**) by selecting **View** under **Operations** of the desired workflow of your project. The ID of each state can be found inside the parenthesis of each transition name under the **Transitions (id)** column ([see screenshot][trans]). By default, this ID is set to `2`
   * @format int32
   */
    jira_issue_transition_id?: number,
  /** Event will be triggered when a commit is created/updated */
    commit_events?: string,
  /** Event will be triggered when a merge request is created/updated/merged */
    merge_request_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesJira({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set kubernetes service for project
 * @request PUT :/v3/projects/{id}/services/kubernetes
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesKubernetes(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Kubernetes namespace to use */
    namespace: string,
  /** The URL to the Kubernetes cluster API, e.g., https://kubernetes.example.com */
    api_url: string,
  /** The service token to authenticate against the Kubernetes cluster with */
    token: string,
  /** A custom certificate authority bundle to verify the Kubernetes cluster with (PEM format) */
    ca_pem?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesKubernetes({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set mattermost service for project
 * @request PUT :/v3/projects/{id}/services/mattermost
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesMattermost(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Mattermost webhook. e.g. http://mattermost_host/hooks/... */
    webhook: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,
  /** Event will be triggered when an issue is created/updated/closed */
    issue_events?: string,
  /** Event will be triggered when a confidential issue is created/updated/closed */
    confidential_issue_events?: string,
  /** Event will be triggered when a merge request is created/updated/merged */
    merge_request_events?: string,
  /** Event will be triggered when someone adds a comment */
    note_events?: string,
  /** Event will be triggered when a new tag is pushed to the repository */
    tag_push_events?: string,
  /** Event will be triggered when a build status changes */
    build_events?: string,
    pipeline_events?: string,
  /** Event will be triggered when a wiki page is created/updated */
    wiki_page_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesMattermost({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set mattermost-slash-commands service for project
 * @request PUT :/v3/projects/{id}/services/mattermost-slash-commands
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesMattermostSlashCommands(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Mattermost token */
    token: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesMattermostSlashCommands({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Trigger a slash command for mattermost-slash-commands
 * @request POST :/v3/projects/{id}/services/mattermost_slash_commands/trigger
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdServicesMattermostSlashCommandsTrigger(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The Mattermost token */
    token: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdServicesMattermostSlashCommandsTrigger({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set pipelines-email service for project
 * @request PUT :/v3/projects/{id}/services/pipelines-email
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesPipelinesEmail(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** Comma-separated list of recipient email addresses */
    recipients: string,
  /** Notify only broken builds */
    notify_only_broken_builds?: boolean,
    pipeline_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesPipelinesEmail({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set pivotaltracker service for project
 * @request PUT :/v3/projects/{id}/services/pivotaltracker
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesPivotaltracker(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Pivotaltracker token */
    token: string,
  /** Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches. */
    restrict_to_branch?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesPivotaltracker({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set pushover service for project
 * @request PUT :/v3/projects/{id}/services/pushover
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesPushover(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The application key */
    api_key: string,
  /** The user key */
    user_key: string,
  /** The priority */
    priority: string,
  /** Leave blank for all active devices */
    device: string,
  /** The sound of the notification */
    sound: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesPushover({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set redmine service for project
 * @request PUT :/v3/projects/{id}/services/redmine
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesRedmine(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The new issue URL */
    new_issue_url: string,
  /** The project URL */
    project_url: string,
  /** The issues URL */
    issues_url: string,
  /** The description of the tracker */
    description?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesRedmine({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set slack service for project
 * @request PUT :/v3/projects/{id}/services/slack
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesSlack(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Slack webhook. e.g. https://hooks.slack.com/services/... */
    webhook: string,
  /** The user name */
    new_issue_url?: string,
  /** The channel name */
    channel?: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,
  /** Event will be triggered when an issue is created/updated/closed */
    issue_events?: string,
  /** Event will be triggered when a confidential issue is created/updated/closed */
    confidential_issue_events?: string,
  /** Event will be triggered when a merge request is created/updated/merged */
    merge_request_events?: string,
  /** Event will be triggered when someone adds a comment */
    note_events?: string,
  /** Event will be triggered when a new tag is pushed to the repository */
    tag_push_events?: string,
  /** Event will be triggered when a build status changes */
    build_events?: string,
    pipeline_events?: string,
  /** Event will be triggered when a wiki page is created/updated */
    wiki_page_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesSlack({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set slack-slash-commands service for project
 * @request PUT :/v3/projects/{id}/services/slack-slash-commands
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesSlackSlashCommands(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** The Slack token */
    token: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesSlackSlashCommands({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Trigger a slash command for slack-slash-commands
 * @request POST :/v3/projects/{id}/services/slack_slash_commands/trigger
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdServicesSlackSlashCommandsTrigger(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The Slack token */
    token: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdServicesSlackSlashCommandsTrigger({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Set teamcity service for project
 * @request PUT :/v3/projects/{id}/services/teamcity
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdServicesTeamcity(
  /** undefined */
  id: number,      
  /** Request body */
  data: {
  /** TeamCity root URL like https://teamcity.example.com */
    teamcity_url: string,
  /** Build configuration ID */
    build_type: string,
  /** A user with permissions to trigger a manual build */
    username: string,
  /** The password of the user */
    password: string,
  /** Event will be triggered by a push to the repository */
    push_events?: string,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3ProjectsIdServicesTeamcity({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Delete a service for project
 * @request DELETE :/v3/projects/{id}/services/{service_slug}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdServicesServiceSlug(
  /** The name of the service */
  serviceSlug: "asana" | "assembla" | "bamboo" | "bugzilla" | "buildkite" | "builds-email" | "campfire" | "custom-issue-tracker" | "drone-ci" | "emails-on-push" | "external-wiki" | "flowdock" | "gemnasium" | "hipchat" | "irker" | "jira" | "kubernetes" | "mattermost-slash-commands" | "slack-slash-commands" | "pipelines-email" | "pivotaltracker" | "pushover" | "redmine" | "slack" | "mattermost" | "teamcity",      
  /** undefined */
  id: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdServicesServiceSlug({
    serviceSlug: serviceSlug,
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the service settings for project
 * @request GET :/v3/projects/{id}/services/{service_slug}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdServicesServiceSlug(
  /** The name of the service */
  serviceSlug: "asana" | "assembla" | "bamboo" | "bugzilla" | "buildkite" | "builds-email" | "campfire" | "custom-issue-tracker" | "drone-ci" | "emails-on-push" | "external-wiki" | "flowdock" | "gemnasium" | "hipchat" | "irker" | "jira" | "kubernetes" | "mattermost-slash-commands" | "slack-slash-commands" | "pipelines-email" | "pivotaltracker" | "pushover" | "redmine" | "slack" | "mattermost" | "teamcity",      
  /** undefined */
  id: number,      
): Promise<ProjectService> {
  const result = await api.v3.getV3ProjectsIdServicesServiceSlug({
    serviceSlug: serviceSlug,
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Share the project with a group
 * @request POST :/v3/projects/{id}/share
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdShare(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /**
   * The ID of a group
   * @format int32
   */
    group_id: number,
  /**
   * The group access level
   * @format int32
   */
    group_access: 10 | 20 | 30 | 40,
  /**
   * Share expiration date
   * @format date
   */
    expires_at?: string,

},      
): Promise<ProjectGroupLink> {
  const result = await api.v3.postV3ProjectsIdShare({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * undefined
 * @request DELETE :/v3/projects/{id}/share/{group_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdShareGroupId(
  /** The ID of a project */
  id: string,      
  /** The ID of the group */
  groupId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdShareGroupId({
    id: id,
    groupId: groupId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get all project snippets
 * @request GET :/v3/projects/{id}/snippets
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippets(
  /** The ID of a project */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<ProjectSnippet> {
  const result = await api.v3.getV3ProjectsIdSnippets({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new project snippet
 * @request POST :/v3/projects/{id}/snippets
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdSnippets(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The title of the snippet */
    title: string,
  /** The file name of the snippet */
    file_name: string,
  /** The content of the snippet */
    code: string,
  /**
   * The visibility level of the snippet
   * @format int32
   */
    visibility_level: 0 | 10 | 20,

},      
): Promise<ProjectSnippet> {
  const result = await api.v3.postV3ProjectsIdSnippets({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +noteable+ notes
 * @request GET :/v3/projects/{id}/snippets/{noteable_id}/notes
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdSnippetsNoteableIdNotes({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new +noteable+ note
 * @request POST :/v3/projects/{id}/snippets/{noteable_id}/notes
 */
export async function postV3PostV3ProjectsIdSnippetsNoteableIdNotes(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,
  /** The creation date of the note */
    created_at?: string,

},      
): Promise<Note> {
  const result = await api.v3.postV3ProjectsIdSnippetsNoteableIdNotes({
    id: id,
    noteableId: noteableId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +noteable+ note
 * @request DELETE :/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}
 */
export async function deleteV3DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
): Promise<Note> {
  const result = await api.v3.deleteV3ProjectsIdSnippetsNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single +noteable+ note
 * @request GET :/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of a note */
  noteId: number,      
  /** The ID of the noteable */
  noteableId: number,      
): Promise<Note> {
  const result = await api.v3.getV3ProjectsIdSnippetsNoteableIdNotesNoteId({
    id: id,
    noteId: noteId,
    noteableId: noteableId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing +noteable+ note
 * @request PUT :/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}
 */
export async function putV3PutV3ProjectsIdSnippetsNoteableIdNotesNoteId(
  /** The ID of a project */
  id: string,      
  /** The ID of the noteable */
  noteableId: number,      
  /** The ID of a note */
  noteId: number,      
  /** Request body */
  data: {
  /** The content of a note */
    body: string,

},      
): Promise<Note> {
  const result = await api.v3.putV3ProjectsIdSnippetsNoteableIdNotesNoteId({
    id: id,
    noteableId: noteableId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a project snippet
 * @request DELETE :/v3/projects/{id}/snippets/{snippet_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3ProjectsIdSnippetsSnippetId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project snippet */
  snippetId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3ProjectsIdSnippetsSnippetId({
    id: id,
    snippetId: snippetId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single project snippet
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project snippet */
  snippetId: number,      
): Promise<ProjectSnippet> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetId({
    id: id,
    snippetId: snippetId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing project snippet
 * @request PUT :/v3/projects/{id}/snippets/{snippet_id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3ProjectsIdSnippetsSnippetId(
  /** The ID of a project */
  id: string,      
  /** The ID of a project snippet */
  snippetId: number,      
  /** Request body */
  data: {
  /** The title of the snippet */
    title?: string,
  /** The file name of the snippet */
    file_name?: string,
  /** The content of the snippet */
    code?: string,
  /**
   * The visibility level of the snippet
   * @format int32
   */
    visibility_level?: 0 | 10 | 20,

},      
): Promise<ProjectSnippet> {
  const result = await api.v3.putV3ProjectsIdSnippetsSnippetId({
    id: id,
    snippetId: snippetId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetIdAwardEmoji(
  /** The ID of a project */
  id: string,      
  /** The ID of an Issue, Merge Request or Snippet */
  snippetId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    snippetId: snippetId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/snippets/{snippet_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdSnippetsSnippetIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdSnippetsSnippetIdAwardEmoji({
    id: id,
    snippetId: snippetId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/snippets/{snippet_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    snippetId: snippetId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    snippetId: snippetId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a list of project +awardable+ award emoji
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
  /** undefined */
  noteId: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
    snippetId: snippetId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Award a new Emoji
 * @request POST :/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji
 */
export async function postV3PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji(
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
  /** undefined */
  noteId: number,      
  /** Request body */
  data: {
  /** The name of a award_emoji (without colons) */
    name: string,

},      
): Promise<AwardEmoji> {
  const result = await api.v3.postV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji({
    id: id,
    snippetId: snippetId,
    noteId: noteId,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a +awardables+ award emoji
 * @request DELETE :/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji/{award_id}
 */
export async function deleteV3DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of an award emoji */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.deleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    snippetId: snippetId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific award emoji
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji/{award_id}
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId(
  /** The ID of the award */
  awardId: number,      
  /** undefined */
  id: number,      
  /** undefined */
  snippetId: number,      
  /** undefined */
  noteId: number,      
): Promise<AwardEmoji> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId({
    awardId: awardId,
    id: id,
    snippetId: snippetId,
    noteId: noteId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a raw project snippet
 * @request GET :/v3/projects/{id}/snippets/{snippet_id}/raw
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3ProjectsIdSnippetsSnippetIdRaw(
  /** The ID of a project */
  id: string,      
  /** The ID of a project snippet */
  snippetId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3ProjectsIdSnippetsSnippetIdRaw({
    id: id,
    snippetId: snippetId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Unstar a project
 * @request DELETE :/v3/projects/{id}/star
 */
export async function deleteV3DeleteV3ProjectsIdStar(
  /** The ID of a project */
  id: string,      
): Promise<Project> {
  const result = await api.v3.deleteV3ProjectsIdStar({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Star a project
 * @request POST :/v3/projects/{id}/star
 */
export async function postV3PostV3ProjectsIdStar(
  /** The ID of a project */
  id: string,      
): Promise<Project> {
  const result = await api.v3.postV3ProjectsIdStar({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Post status to a commit
 * @request POST :/v3/projects/{id}/statuses/{sha}
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdStatusesSha(
  /** The ID of a project */
  id: string,      
  /** The commit hash */
  sha: string,      
  /** Request body */
  data: {
  /** The state of the status */
    state: "pending" | "running" | "success" | "failed" | "canceled",
  /** The ref */
    ref?: string,
  /** The target URL to associate with this status */
    target_url?: string,
  /** A short description of the status */
    description?: string,
  /** A string label to differentiate this status from the status of other systems. Default: "default" */
    name?: string,
  /** A string label to differentiate this status from the status of other systems. Default: "default" */
    context?: string,

},      
): Promise<CommitStatus> {
  const result = await api.v3.postV3ProjectsIdStatusesSha({
    id: id,
    sha: sha,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get triggers list
 * @request GET :/v3/projects/{id}/triggers
 * @readonly
 */
export async function getV3GetV3ProjectsIdTriggers(
  /** The ID of a project */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Trigger> {
  const result = await api.v3.getV3ProjectsIdTriggers({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a trigger
 * @request POST :/v3/projects/{id}/triggers
 */
export async function postV3PostV3ProjectsIdTriggers(
  /** The ID of a project */
  id: string,      
): Promise<Trigger> {
  const result = await api.v3.postV3ProjectsIdTriggers({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a trigger
 * @request DELETE :/v3/projects/{id}/triggers/{token}
 */
export async function deleteV3DeleteV3ProjectsIdTriggersToken(
  /** The ID of a project */
  id: string,      
  /** The unique token of trigger */
  token: string,      
): Promise<Trigger> {
  const result = await api.v3.deleteV3ProjectsIdTriggersToken({
    id: id,
    token: token,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get specific trigger of a project
 * @request GET :/v3/projects/{id}/triggers/{token}
 * @readonly
 */
export async function getV3GetV3ProjectsIdTriggersToken(
  /** The ID of a project */
  id: string,      
  /** The unique token of trigger */
  token: string,      
): Promise<Trigger> {
  const result = await api.v3.getV3ProjectsIdTriggersToken({
    id: id,
    token: token,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unarchive a project
 * @request POST :/v3/projects/{id}/unarchive
 */
export async function postV3PostV3ProjectsIdUnarchive(
  /** The ID of a project */
  id: string,      
): Promise<Project> {
  const result = await api.v3.postV3ProjectsIdUnarchive({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Upload a file
 * @request POST :/v3/projects/{id}/uploads
 * @allowrelaxedtypes
 */
export async function postV3PostV3ProjectsIdUploads(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The file to be uploaded */
    file: File,

},      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.postV3ProjectsIdUploads({
    id: id,
    data: data,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the users list of a project
 * @request GET :/v3/projects/{id}/users
 * @readonly
 */
export async function getV3GetV3ProjectsIdUsers(
  /** The ID of a project */
  id: string,      
  /** Return list of users matching the search criteria */
  search?: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<UserBasic> {
  const result = await api.v3.getV3ProjectsIdUsers({
    query: {
      search: search,
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get project variables
 * @request GET :/v3/projects/{id}/variables
 * @readonly
 */
export async function getV3GetV3ProjectsIdVariables(
  /** The ID of a project */
  id: string,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Variable> {
  const result = await api.v3.getV3ProjectsIdVariables({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a new variable in a project
 * @request POST :/v3/projects/{id}/variables
 */
export async function postV3PostV3ProjectsIdVariables(
  /** The ID of a project */
  id: string,      
  /** Request body */
  data: {
  /** The key of the variable */
    key: string,
  /** The value of the variable */
    value: string,

},      
): Promise<Variable> {
  const result = await api.v3.postV3ProjectsIdVariables({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an existing variable from a project
 * @request DELETE :/v3/projects/{id}/variables/{key}
 */
export async function deleteV3DeleteV3ProjectsIdVariablesKey(
  /** The ID of a project */
  id: string,      
  /** The key of the variable */
  key: string,      
): Promise<Variable> {
  const result = await api.v3.deleteV3ProjectsIdVariablesKey({
    id: id,
    key: key,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a specific variable from a project
 * @request GET :/v3/projects/{id}/variables/{key}
 * @readonly
 */
export async function getV3GetV3ProjectsIdVariablesKey(
  /** The ID of a project */
  id: string,      
  /** The key of the variable */
  key: string,      
): Promise<Variable> {
  const result = await api.v3.getV3ProjectsIdVariablesKey({
    id: id,
    key: key,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing variable from a project
 * @request PUT :/v3/projects/{id}/variables/{key}
 */
export async function putV3PutV3ProjectsIdVariablesKey(
  /** The ID of a project */
  id: string,      
  /** The key of the variable */
  key: string,      
  /** Request body */
  data: {
  /** The value of the variable */
    value?: string,

},      
): Promise<Variable> {
  const result = await api.v3.putV3ProjectsIdVariablesKey({
    id: id,
    key: key,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get runners available for user
 * @request GET :/v3/runners
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3Runners(
  /** The scope of specific runners to show */
  scope?: "active" | "paused" | "online",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Runner> {
  const result = await api.v3.getV3Runners({
    query: {
      scope: scope,
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get all runners - shared and specific
 * @request GET :/v3/runners/all
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3RunnersAll(
  /** The scope of specific runners to show */
  scope?: "active" | "paused" | "online" | "specific" | "shared",      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Runner> {
  const result = await api.v3.getV3RunnersAll({
    query: {
      scope: scope,
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Remove a runner
 * @request DELETE :/v3/runners/{id}
 */
export async function deleteV3DeleteV3RunnersId(
  /** The ID of the runner */
  id: number,      
): Promise<Runner> {
  const result = await api.v3.deleteV3RunnersId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get runner's details
 * @request GET :/v3/runners/{id}
 * @readonly
 */
export async function getV3GetV3RunnersId(
  /** The ID of the runner */
  id: number,      
): Promise<RunnerDetails> {
  const result = await api.v3.getV3RunnersId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update runner's details
 * @request PUT :/v3/runners/{id}
 */
export async function putV3PutV3RunnersId(
  /** The ID of the runner */
  id: number,      
  /** Request body */
  data: {
  /** The description of the runner */
    description?: string,
  /** The state of a runner */
    active?: boolean,
  /** The list of tags for a runner */
    tag_list?: (string)[],
  /** Flag indicating the runner can execute untagged jobs */
    run_untagged?: boolean,
  /** Flag indicating the runner is locked */
    locked?: boolean,

},      
): Promise<RunnerDetails> {
  const result = await api.v3.putV3RunnersId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Login to get token
 * @request POST :/v3/session
 */
export async function postV3PostV3Session(
  /** Request body */
  data: {
  /** The username */
    login?: string,
  /** The email of the user */
    email?: string,
  /** The password of the user */
    password: string,

},      
): Promise<UserWithPrivateToken> {
  const result = await api.v3.postV3Session({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the Sidekiq Compound metrics. Includes queue, process, and job statistics
 * @request GET :/v3/sidekiq/compound_metrics
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3SidekiqCompoundMetrics(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3SidekiqCompoundMetrics({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the Sidekiq job statistics
 * @request GET :/v3/sidekiq/job_stats
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3SidekiqJobStats(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3SidekiqJobStats({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the Sidekiq process metrics
 * @request GET :/v3/sidekiq/process_metrics
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3SidekiqProcessMetrics(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3SidekiqProcessMetrics({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the Sidekiq queue metrics
 * @request GET :/v3/sidekiq/queue_metrics
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3SidekiqQueueMetrics(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3SidekiqQueueMetrics({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a snippets list for authenticated user
 * @request GET :/v3/snippets
 * @readonly
 */
export async function getV3GetV3Snippets(
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<PersonalSnippet> {
  const result = await api.v3.getV3Snippets({
    query: {
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create new snippet
 * @request POST :/v3/snippets
 * @allowrelaxedtypes
 */
export async function postV3PostV3Snippets(
  /** Request body */
  data: {
  /** The title of a snippet */
    title: string,
  /** The name of a snippet file */
    file_name: string,
  /** The content of a snippet */
    content: string,
  /**
   * The visibility level of the snippet
   * @format int32
   * @default 10
   */
    visibility_level?: 0 | 10 | 20,

},      
): Promise<PersonalSnippet> {
  const result = await api.v3.postV3Snippets({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * List all public snippets current_user has access to
 * @request GET :/v3/snippets/public
 * @readonly
 */
export async function getV3GetV3SnippetsPublic(
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<PersonalSnippet> {
  const result = await api.v3.getV3SnippetsPublic({
    query: {
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Remove snippet
 * @request DELETE :/v3/snippets/{id}
 */
export async function deleteV3DeleteV3SnippetsId(
  /** The ID of a snippet */
  id: number,      
): Promise<PersonalSnippet> {
  const result = await api.v3.deleteV3SnippetsId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single snippet
 * @request GET :/v3/snippets/{id}
 * @readonly
 */
export async function getV3GetV3SnippetsId(
  /** The ID of a snippet */
  id: number,      
): Promise<PersonalSnippet> {
  const result = await api.v3.getV3SnippetsId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update an existing snippet
 * @request PUT :/v3/snippets/{id}
 * @allowrelaxedtypes
 */
export async function putV3PutV3SnippetsId(
  /** The ID of a snippet */
  id: number,      
  /** Request body */
  data: {
  /** The title of a snippet */
    title?: string,
  /** The name of a snippet file */
    file_name?: string,
  /** The content of a snippet */
    content?: string,
  /**
   * The visibility level of the snippet
   * @format int32
   */
    visibility_level?: 0 | 10 | 20,

},      
): Promise<PersonalSnippet> {
  const result = await api.v3.putV3SnippetsId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a raw snippet
 * @request GET :/v3/snippets/{id}/raw
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3SnippetsIdRaw(
  /** The ID of a snippet */
  id: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3SnippetsIdRaw({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/templates/dockerfiles
 * @readonly
 */
export async function getV3GetV3TemplatesDockerfiles(): Promise<TemplatesList> {
  const result = await api.v3.getV3TemplatesDockerfiles({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/templates/dockerfiles/{name}
 * @readonly
 */
export async function getV3GetV3TemplatesDockerfilesName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3TemplatesDockerfilesName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/templates/gitignores
 * @readonly
 */
export async function getV3GetV3TemplatesGitignores(): Promise<TemplatesList> {
  const result = await api.v3.getV3TemplatesGitignores({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/templates/gitignores/{name}
 * @readonly
 */
export async function getV3GetV3TemplatesGitignoresName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3TemplatesGitignoresName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available template
 * @request GET :/v3/templates/gitlab_ci_ymls
 * @readonly
 */
export async function getV3GetV3TemplatesGitlabCiYmls(): Promise<TemplatesList> {
  const result = await api.v3.getV3TemplatesGitlabCiYmls({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific template present in local filesystem
 * @request GET :/v3/templates/gitlab_ci_ymls/{name}
 * @readonly
 */
export async function getV3GetV3TemplatesGitlabCiYmlsName(
  /** The name of the template */
  name: string,      
): Promise<Template> {
  const result = await api.v3.getV3TemplatesGitlabCiYmlsName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of the available license template
 * @request GET :/v3/templates/licenses
 * @readonly
 */
export async function getV3GetV3TemplatesLicenses(
  /** If passed, returns only popular licenses */
  popular?: boolean,      
): Promise<RepoLicense> {
  const result = await api.v3.getV3TemplatesLicenses({
    query: {
      popular: popular,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the text for a specific license
 * @request GET :/v3/templates/licenses/{name}
 * @readonly
 */
export async function getV3GetV3TemplatesLicensesName(
  /** The name of the template */
  name: string,      
): Promise<RepoLicense> {
  const result = await api.v3.getV3TemplatesLicensesName({
    name: name,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Mark all todos as done
 * @request DELETE :/v3/todos
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3Todos(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3Todos({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a todo list
 * @request GET :/v3/todos
 * @readonly
 */
export async function getV3GetV3Todos(
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Todo> {
  const result = await api.v3.getV3Todos({
    query: {
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Mark a todo as done
 * @request DELETE :/v3/todos/{id}
 */
export async function deleteV3DeleteV3TodosId(
  /** The ID of the todo being marked as done */
  id: number,      
): Promise<Todo> {
  const result = await api.v3.deleteV3TodosId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the currently authenticated user
 * @request GET :/v3/user
 * @readonly
 */
export async function getV3GetV3User(): Promise<UserPublic> {
  const result = await api.v3.getV3User({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the currently authenticated user's email addresses
 * @request GET :/v3/user/emails
 * @readonly
 */
export async function getV3GetV3UserEmails(): Promise<Email> {
  const result = await api.v3.getV3UserEmails({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add new email address to the currently authenticated user
 * @request POST :/v3/user/emails
 */
export async function postV3PostV3UserEmails(
  /** Request body */
  data: {
  /** The new email */
    email: string,

},      
): Promise<Email> {
  const result = await api.v3.postV3UserEmails({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an email address from the currently authenticated user
 * @request DELETE :/v3/user/emails/{email_id}
 * @allowrelaxedtypes
 */
export async function deleteV3DeleteV3UserEmailsEmailId(
  /** The ID of the email */
  emailId: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.deleteV3UserEmailsEmailId({
    emailId: emailId,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get a single email address owned by the currently authenticated user
 * @request GET :/v3/user/emails/{email_id}
 * @readonly
 */
export async function getV3GetV3UserEmailsEmailId(
  /** The ID of the email */
  emailId: number,      
): Promise<Email> {
  const result = await api.v3.getV3UserEmailsEmailId({
    emailId: emailId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the currently authenticated user's SSH keys
 * @request GET :/v3/user/keys
 * @readonly
 */
export async function getV3GetV3UserKeys(): Promise<SSHKey> {
  const result = await api.v3.getV3UserKeys({});
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add a new SSH key to the currently authenticated user
 * @request POST :/v3/user/keys
 */
export async function postV3PostV3UserKeys(
  /** Request body */
  data: {
  /** The new SSH key */
    key: string,
  /** The title of the new SSH key */
    title: string,

},      
): Promise<SSHKey> {
  const result = await api.v3.postV3UserKeys({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an SSH key from the currently authenticated user
 * @request DELETE :/v3/user/keys/{key_id}
 */
export async function deleteV3DeleteV3UserKeysKeyId(
  /** The ID of the SSH key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3UserKeysKeyId({
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single key owned by currently authenticated user
 * @request GET :/v3/user/keys/{key_id}
 * @readonly
 */
export async function getV3GetV3UserKeysKeyId(
  /** The ID of the SSH key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.getV3UserKeysKeyId({
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the list of users
 * @request GET :/v3/users
 * @readonly
 */
export async function getV3GetV3Users(
  /** Get a single user with a specific username */
  username?: string,      
  /** Search for a username */
  search?: string,      
  /** Filters only active users */
  active?: boolean,      
  /** Filters only external users */
  external?: boolean,      
  /** Filters only blocked users */
  blocked?: boolean,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<UserBasic> {
  const result = await api.v3.getV3Users({
    query: {
      username: username,
      search: search,
      active: active,
      external: external,
      blocked: blocked,
      page: page,
      per_page: per_page,
    },
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Create a user. Available only for admins.
 * @request POST :/v3/users
 */
export async function postV3PostV3Users(
  /** Request body */
  data: {
  /** The email of the user */
    email: string,
  /** The password of the new user */
    password: string,
  /** The name of the user */
    name: string,
  /** The username of the user */
    username: string,
  /** The Skype username */
    skype?: string,
  /** The LinkedIn username */
    linkedin?: string,
  /** The Twitter username */
    twitter?: string,
  /** The website of the user */
    website_url?: string,
  /** The organization of the user */
    organization?: string,
  /**
   * The number of projects a user can create
   * @format int32
   */
    projects_limit?: number,
  /** The external authentication provider UID */
    extern_uid?: string,
  /** The external provider */
    provider?: string,
  /** The biography of the user */
    bio?: string,
  /** The location of the user */
    location?: string,
  /** Flag indicating the user is an administrator */
    admin?: boolean,
  /** Flag indicating the user can create groups */
    can_create_group?: boolean,
  /** Flag indicating the account needs to be confirmed */
    confirm?: boolean,
  /** Flag indicating the user is an external user */
    external?: boolean,

},      
): Promise<UserPublic> {
  const result = await api.v3.postV3Users({
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete a user. Available only for admins.
 * @request DELETE :/v3/users/{id}
 */
export async function deleteV3DeleteV3UsersId(
  /** The ID of the user */
  id: number,      
): Promise<Email> {
  const result = await api.v3.deleteV3UsersId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get a single user
 * @request GET :/v3/users/{id}
 * @readonly
 */
export async function getV3GetV3UsersId(
  /** The ID of the user */
  id: number,      
): Promise<UserBasic> {
  const result = await api.v3.getV3UsersId({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Update a user. Available only for admins.
 * @request PUT :/v3/users/{id}
 */
export async function putV3PutV3UsersId(
  /** The ID of the user */
  id: number,      
  /** Request body */
  data: {
  /** The email of the user */
    email?: string,
  /** The password of the new user */
    password?: string,
  /** The name of the user */
    name?: string,
  /** The username of the user */
    username?: string,
  /** The Skype username */
    skype?: string,
  /** The LinkedIn username */
    linkedin?: string,
  /** The Twitter username */
    twitter?: string,
  /** The website of the user */
    website_url?: string,
  /** The organization of the user */
    organization?: string,
  /**
   * The number of projects a user can create
   * @format int32
   */
    projects_limit?: number,
  /** The external authentication provider UID */
    extern_uid?: string,
  /** The external provider */
    provider?: string,
  /** The biography of the user */
    bio?: string,
  /** The location of the user */
    location?: string,
  /** Flag indicating the user is an administrator */
    admin?: boolean,
  /** Flag indicating the user can create groups */
    can_create_group?: boolean,
  /** Flag indicating the account needs to be confirmed */
    confirm?: boolean,
  /** Flag indicating the user is an external user */
    external?: boolean,

},      
): Promise<UserPublic> {
  const result = await api.v3.putV3UsersId({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Block a user. Available only for admins.
 * @request PUT :/v3/users/{id}/block
 * @allowrelaxedtypes
 */
export async function putV3PutV3UsersIdBlock(
  /** The ID of the user */
  id: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3UsersIdBlock({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the emails addresses of a specified user. Available only for admins.
 * @request GET :/v3/users/{id}/emails
 * @readonly
 */
export async function getV3GetV3UsersIdEmails(
  /** The ID of the user */
  id: number,      
): Promise<Email> {
  const result = await api.v3.getV3UsersIdEmails({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add an email address to a specified user. Available only for admins.
 * @request POST :/v3/users/{id}/emails
 */
export async function postV3PostV3UsersIdEmails(
  /** The ID of the user */
  id: number,      
  /** Request body */
  data: {
  /** The email of the user */
    email: string,

},      
): Promise<Email> {
  const result = await api.v3.postV3UsersIdEmails({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an email address of a specified user. Available only for admins.
 * @request DELETE :/v3/users/{id}/emails/{email_id}
 */
export async function deleteV3DeleteV3UsersIdEmailsEmailId(
  /** The ID of the user */
  id: number,      
  /** The ID of the email */
  emailId: number,      
): Promise<Email> {
  const result = await api.v3.deleteV3UsersIdEmailsEmailId({
    id: id,
    emailId: emailId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the contribution events of a specified user
 * @request GET :/v3/users/{id}/events
 * @readonly
 */
export async function getV3GetV3UsersIdEvents(
  /** The ID of the user */
  id: number,      
  /** Current page number */
  page?: number,      
  /** Number of items per page */
  per_page?: number,      
): Promise<Event> {
  const result = await api.v3.getV3UsersIdEvents({
    query: {
      page: page,
      per_page: per_page,
    },
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Get the SSH keys of a specified user. Available only for admins.
 * @request GET :/v3/users/{id}/keys
 * @readonly
 */
export async function getV3GetV3UsersIdKeys(
  /** The ID of the user */
  id: number,      
): Promise<SSHKey> {
  const result = await api.v3.getV3UsersIdKeys({
    id: id,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Add an SSH key to a specified user. Available only for admins.
 * @request POST :/v3/users/{id}/keys
 */
export async function postV3PostV3UsersIdKeys(
  /** The ID of the user */
  id: number,      
  /** Request body */
  data: {
  /** The new SSH key */
    key: string,
  /** The title of the new SSH key */
    title: string,

},      
): Promise<SSHKey> {
  const result = await api.v3.postV3UsersIdKeys({
    id: id,
    data: data,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Delete an existing SSH key from a specified user. Available only for admins.
 * @request DELETE :/v3/users/{id}/keys/{key_id}
 */
export async function deleteV3DeleteV3UsersIdKeysKeyId(
  /** The ID of the user */
  id: number,      
  /** The ID of the SSH key */
  keyId: number,      
): Promise<SSHKey> {
  const result = await api.v3.deleteV3UsersIdKeysKeyId({
    id: id,
    keyId: keyId,
  });
  if (result.data) {
    return result.data
  } else {
    throw (result.error)
  }
}

/**
 * Unblock a user. Available only for admins.
 * @request PUT :/v3/users/{id}/unblock
 * @allowrelaxedtypes
 */
export async function putV3PutV3UsersIdUnblock(
  /** The ID of the user */
  id: number,      
): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.putV3UsersIdUnblock({
    id: id,
  });
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get the version information of the GitLab instance.
 * @request GET :/v3/version
 * @allowrelaxedtypes
 * @readonly
 */
export async function getV3GetV3Version(): Promise<hasuraSdk.JSONValue> {
  const result = await api.v3.getV3Version({});
  if (result.error) {
    throw (result.error)
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}
