{
  "get__/devices/{serial}/camera/analytics/live": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/analytics/overview": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. */\n timespan?: number, \n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.objectType": {
        "rendered": "\n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/analytics/recent": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.objectType": {
        "rendered": "\n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/analytics/zones": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/analytics/zones/{zoneId}/history": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. */\n timespan?: number, \n/** The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. */\n resolution?: number, \n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.resolution": {
        "rendered": "\n/** The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. */\n resolution?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.objectType": {
        "rendered": "\n/** [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. */\n objectType?: \"person\" | \"vehicle\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".zoneId": {
        "rendered": " zoneId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/qualityAndRetentionSettings": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/devices/{serial}/camera/qualityAndRetentionSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera */\n    audioRecordingEnabled?: boolean,\n  /** Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera */\n    motionBasedRetentionEnabled?: boolean,\n  /** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */\n    motionDetectorVersion?: 1 | 2,\n  /** The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera. */\n    profileId?: string,\n  /** Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model. */\n    quality?: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model. */\n    resolution?: \"1080x1080\" | \"1280x720\" | \"1920x1080\" | \"2058x2058\",\n  /** Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera. This setting does not apply to MV2 cameras. */\n    restrictedBandwidthModeEnabled?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/camera/video/settings": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/devices/{serial}/camera/video/settings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Boolean indicating if external rtsp stream is exposed */\n    externalRtspEnabled?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/cellularGateway/settings": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/devices/{serial}/cellularGateway/settings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** list of all fixed IP assignments for a single MG */\n    fixedIpAssignments?: ({\n  /** The IP address you want to assign to a specific server or device */\n    ip: string,\n  /** The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address */\n    mac: string,\n  /** A descriptive name of the assignment */\n    name?: string,\n\n})[],\n  /** list of all reserved IP ranges for a single MG */\n    reservedIpRanges?: ({\n  /** Comment explaining the reserved IP range */\n    comment: string,\n  /** Ending IP included in the reserved range of IPs */\n    end: string,\n  /** Starting IP included in the reserved range of IPs */\n    start: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/cellularGateway/settings/portForwardingRules": {
    "query": {},
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/devices/{serial}/cellularGateway/settings/portForwardingRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An array of port forwarding params */\n    rules?: ({\n  /** `any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory. */\n    access: string,\n  /** An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges. */\n    allowedIps?: (string)[],\n  /** The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN */\n    lanIp: string,\n  /** A port or port ranges that will receive the forwarded traffic from the WAN */\n    localPort: string,\n  /** A descriptive name for the rule */\n    name?: string,\n  /** TCP or UDP */\n    protocol: string,\n  /** A port or port ranges that will be forwarded to the host on the LAN */\n    publicPort: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/clients": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/devices/{serial}/switch/ports/cycle": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8] */\n    ports: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/switchPortStatuses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/devices/{serial}/switchPortStatuses/packets": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 1 day from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 1 day from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/devices/{serial}/wireless/bluetooth/settings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n    major?: number,\n  /** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n    minor?: number,\n  /** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n    uuid?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n major?: number, \n/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n minor?: number, \n/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n uuid?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.major": {
        "rendered": "\n/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n major?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.minor": {
        "rendered": "\n/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n minor?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.uuid": {
        "rendered": "\n/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */\n uuid?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/networks/{networkId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */\n    disableMyMerakiCom?: boolean,\n  /** Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false */\n    disableRemoteStatusPage?: boolean,\n  /** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. */\n    enrollmentString?: string,\n  /** The name of the network */\n    name?: string,\n  /** A space-separated list of tags to be applied to the network */\n    tags?: string,\n  /** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */\n    timeZone?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/accessPolicies": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/airMarshal": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/alertSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/alertSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Alert-specific configuration for each type. Only alerts that pertain to the network can be updated. */\n    alerts?: ({\n  /** A hash of destinations for this specific alert */\n    alertDestinations?: {\n  /** If true, then all network admins will receive emails for this alert */\n    allAdmins?: boolean,\n  /** A list of emails that will receive information about the alert */\n    emails?: (string)[],\n  /** A list of HTTP server IDs to send a Webhook to for this alert */\n    httpServerIds?: (string)[],\n  /** If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network */\n    snmp?: boolean,\n\n},\n  /** A boolean depicting if the alert is turned on or off */\n    enabled?: boolean,\n  /** A hash of specific configuration data for the alert. Only filters specific to the alert will be updated. */\n    filters?: hasuraSdk.JSONValue,\n  /** The type of alert */\n    type: string,\n\n})[],\n  /** The network-wide destinations for all alerts on the network. */\n    defaultDestinations?: {\n  /** If true, then all network admins will receive emails. */\n    allAdmins?: boolean,\n  /** A list of emails that will recieve the alert(s). */\n    emails?: (string)[],\n  /** A list of HTTP server IDs to send a Webhook to */\n    httpServerIds?: (string)[],\n  /** If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network. */\n    snmp?: boolean,\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/appliance/firewall/inboundFirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/appliance/firewall/inboundFirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An ordered array of the firewall rules (not including the default rule) */\n    rules?: ({\n  /** Description of the rule (optional) */\n    comment?: string,\n  /** Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any' */\n    destCidr: string,\n  /** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */\n    destPort?: string,\n  /** 'allow' or 'deny' traffic specified by this rule */\n    policy: \"allow\" | \"deny\",\n  /** The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any') */\n    protocol: \"any\" | \"icmp\" | \"icmp6\" | \"tcp\" | \"udp\",\n  /** Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses) */\n    srcCidr: string,\n  /** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */\n    srcPort?: string,\n  /** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */\n    syslogEnabled?: boolean,\n\n})[],\n  /** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */\n    syslogDefaultRule?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/appliancePorts": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/appliancePorts/{appliancePortId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".appliancePortId": {
        "rendered": " appliancePortId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/appliancePorts/{appliancePortId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing. */\n    accessPolicy?: string,\n  /** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */\n    allowedVlans?: string,\n  /** Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true. */\n    dropUntaggedTraffic?: boolean,\n  /** The status of the port */\n    enabled?: boolean,\n  /** The type of the port: 'access' or 'trunk'. */\n    type?: string,\n  /** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */\n    vlan?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".appliancePortId": {
        "rendered": " appliancePortId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/bind": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model. */\n    autoBind?: boolean,\n  /** The ID of the template to which the network should be bound. */\n    configTemplateId: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/bluetoothClients": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 7 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, \n/** Include the connectivity history for this client */\n includeConnectivityHistory?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 7 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includeConnectivityHistory": {
        "rendered": "\n/** Include the connectivity history for this client */\n includeConnectivityHistory?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/bluetoothClients/{bluetoothClientId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Include the connectivity history for this client */\n includeConnectivityHistory?: boolean, \n/** The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. */\n connectivityHistoryTimespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includeConnectivityHistory": {
        "rendered": "\n/** Include the connectivity history for this client */\n includeConnectivityHistory?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.connectivityHistoryTimespan": {
        "rendered": "\n/** The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. */\n connectivityHistoryTimespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".bluetoothClientId": {
        "rendered": " bluetoothClientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/bluetoothSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Whether APs will advertise beacons. */\n advertisingEnabled?: boolean, \n/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n major?: number, \n/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */\n majorMinorAssignmentMode?: string, \n/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n minor?: number, \n/** Whether APs will scan for Bluetooth enabled clients. */\n scanningEnabled?: boolean, \n/** The UUID to be used in the beacon identifier. */\n uuid?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.advertisingEnabled": {
        "rendered": "\n/** Whether APs will advertise beacons. */\n advertisingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.major": {
        "rendered": "\n/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n major?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.majorMinorAssignmentMode": {
        "rendered": "\n/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */\n majorMinorAssignmentMode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.minor": {
        "rendered": "\n/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n minor?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.scanningEnabled": {
        "rendered": "\n/** Whether APs will scan for Bluetooth enabled clients. */\n scanningEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.uuid": {
        "rendered": "\n/** The UUID to be used in the beacon identifier. */\n uuid?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/networks/{networkId}/bluetoothSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Whether APs will advertise beacons. */\n    advertisingEnabled?: boolean,\n  /** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n    major?: number,\n  /** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */\n    majorMinorAssignmentMode?: \"Non-unique\" | \"Unique\",\n  /** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n    minor?: number,\n  /** Whether APs will scan for Bluetooth enabled clients. */\n    scanningEnabled?: boolean,\n  /** The UUID to be used in the beacon identifier. */\n    uuid?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Whether APs will advertise beacons. */\n advertisingEnabled?: boolean, \n/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n major?: number, \n/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */\n majorMinorAssignmentMode?: string, \n/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n minor?: number, \n/** Whether APs will scan for Bluetooth enabled clients. */\n scanningEnabled?: boolean, \n/** The UUID to be used in the beacon identifier. */\n uuid?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.advertisingEnabled": {
        "rendered": "\n/** Whether APs will advertise beacons. */\n advertisingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.major": {
        "rendered": "\n/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n major?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.majorMinorAssignmentMode": {
        "rendered": "\n/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */\n majorMinorAssignmentMode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.minor": {
        "rendered": "\n/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */\n minor?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.scanningEnabled": {
        "rendered": "\n/** Whether APs will scan for Bluetooth enabled clients. */\n scanningEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.uuid": {
        "rendered": "\n/** The UUID to be used in the beacon identifier. */\n uuid?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/camera/qualityRetentionProfiles": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/camera/qualityRetentionProfiles": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Whether or not to record audio. Can be either true or false. Defaults to false. */\n    audioRecordingEnabled?: boolean,\n  /** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */\n    cloudArchiveEnabled?: boolean,\n  /** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */\n    maxRetentionDays?: number,\n  /** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */\n    motionBasedRetentionEnabled?: boolean,\n  /** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */\n    motionDetectorVersion?: number,\n  /** The name of the new profile. Must be unique. This parameter is required. */\n    name: string,\n  /** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */\n    restrictedBandwidthModeEnabled?: boolean,\n  /** Schedule for which this camera will record video, or 'null' to always record. */\n    scheduleId?: string,\n  /** Video quality and resolution settings for all the camera models. */\n    videoSettings?: {\n  /** Quality and resolution for MV12/MV22/MV72 camera models. */\n    \"MV12/MV22/MV72\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720' or '1920x1080'. */\n    resolution: \"1280x720\" | \"1920x1080\",\n\n},\n  /** Quality and resolution for MV12WE camera models. */\n    \"MV12WE\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720' or '1920x1080'. */\n    resolution: \"1280x720\" | \"1920x1080\",\n\n},\n  /** Quality and resolution for MV13 camera models. */\n    \"MV13\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2688x1512'. */\n    resolution: \"1080x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV21/MV71 camera models. */\n    \"MV21/MV71\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720'. */\n    resolution: \"1280x720\",\n\n},\n  /** Quality and resolution for MV22X/MV72X camera models. */\n    \"MV22X/MV72X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'. */\n    resolution: \"1280x720\" | \"1920x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV32 camera models. */\n    \"MV32\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2058x2058'. */\n    resolution: \"1080x1080\" | \"2058x2058\",\n\n},\n  /** Quality and resolution for MV33 camera models. */\n    \"MV33\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2112x2112'. */\n    resolution: \"1080x1080\" | \"2112x2112\",\n\n},\n  /** Quality and resolution for MV52 camera models. */\n    \"MV52\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'. */\n    resolution: \"1280x720\" | \"1920x1080\" | \"2688x1512\" | \"3840x2160\",\n\n},\n  /** Quality and resolution for MV63 camera models. */\n    \"MV63\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1920x1080' or '2688x1512'. */\n    resolution: \"1920x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV63X camera models. */\n    \"MV63X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'. */\n    resolution: \"1920x1080\" | \"2688x1512\" | \"3840x2160\",\n\n},\n  /** Quality and resolution for MV93 camera models. */\n    \"MV93\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2112x2112'. */\n    resolution: \"1080x1080\" | \"2112x2112\",\n\n},\n  /** Quality and resolution for MV93X camera models. */\n    \"MV93X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'. */\n    resolution: \"1080x1080\" | \"2112x2112\" | \"2880x2880\",\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qualityRetentionProfileId": {
        "rendered": " qualityRetentionProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qualityRetentionProfileId": {
        "rendered": " qualityRetentionProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Whether or not to record audio. Can be either true or false. Defaults to false. */\n    audioRecordingEnabled?: boolean,\n  /** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */\n    cloudArchiveEnabled?: boolean,\n  /** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */\n    maxRetentionDays?: number,\n  /** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */\n    motionBasedRetentionEnabled?: boolean,\n  /** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */\n    motionDetectorVersion?: number,\n  /** The name of the new profile. Must be unique. */\n    name?: string,\n  /** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */\n    restrictedBandwidthModeEnabled?: boolean,\n  /** Schedule for which this camera will record video, or 'null' to always record. */\n    scheduleId?: string,\n  /** Video quality and resolution settings for all the camera models. */\n    videoSettings?: {\n  /** Quality and resolution for MV12/MV22/MV72 camera models. */\n    \"MV12/MV22/MV72\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720' or '1920x1080'. */\n    resolution: \"1280x720\" | \"1920x1080\",\n\n},\n  /** Quality and resolution for MV12WE camera models. */\n    \"MV12WE\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720' or '1920x1080'. */\n    resolution: \"1280x720\" | \"1920x1080\",\n\n},\n  /** Quality and resolution for MV13 camera models. */\n    \"MV13\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2688x1512'. */\n    resolution: \"1080x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV21/MV71 camera models. */\n    \"MV21/MV71\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720'. */\n    resolution: \"1280x720\",\n\n},\n  /** Quality and resolution for MV22X/MV72X camera models. */\n    \"MV22X/MV72X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'. */\n    resolution: \"1280x720\" | \"1920x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV32 camera models. */\n    \"MV32\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2058x2058'. */\n    resolution: \"1080x1080\" | \"2058x2058\",\n\n},\n  /** Quality and resolution for MV33 camera models. */\n    \"MV33\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2112x2112'. */\n    resolution: \"1080x1080\" | \"2112x2112\",\n\n},\n  /** Quality and resolution for MV52 camera models. */\n    \"MV52\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'. */\n    resolution: \"1280x720\" | \"1920x1080\" | \"2688x1512\" | \"3840x2160\",\n\n},\n  /** Quality and resolution for MV63 camera models. */\n    \"MV63\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1920x1080' or '2688x1512'. */\n    resolution: \"1920x1080\" | \"2688x1512\",\n\n},\n  /** Quality and resolution for MV63X camera models. */\n    \"MV63X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'. */\n    resolution: \"1920x1080\" | \"2688x1512\" | \"3840x2160\",\n\n},\n  /** Quality and resolution for MV93 camera models. */\n    \"MV93\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080' or '2112x2112'. */\n    resolution: \"1080x1080\" | \"2112x2112\",\n\n},\n  /** Quality and resolution for MV93X camera models. */\n    \"MV93X\"?: {\n  /** Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'. */\n    quality: \"Enhanced\" | \"High\" | \"Standard\",\n  /** Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'. */\n    resolution: \"1080x1080\" | \"2112x2112\" | \"2880x2880\",\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qualityRetentionProfileId": {
        "rendered": " qualityRetentionProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/camera/schedules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/cameras/{serial}/snapshot": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** [optional] If set to \"true\" the snapshot will be taken at full sensor resolution. This will error if used with timestamp. */\n    fullframe?: boolean,\n  /**\n   * [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.\n   * @format date-time\n   */\n    timestamp?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/cameras/{serial}/videoLink": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** [optional] The video link will start at this timestamp. The timestamp is in UNIX Epoch time (milliseconds). If no timestamp is specified, we will assume current time. */\n timestamp?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timestamp": {
        "rendered": "\n/** [optional] The video link will start at this timestamp. The timestamp is in UNIX Epoch time (milliseconds). If no timestamp is specified, we will assume current time. */\n timestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/cellularFirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/cellularFirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An ordered array of the firewall rules (not including the default rule) */\n    rules?: ({\n  /** Description of the rule (optional) */\n    comment?: string,\n  /** Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any' */\n    destCidr: string,\n  /** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */\n    destPort?: string,\n  /** 'allow' or 'deny' traffic specified by this rule */\n    policy: \"allow\" | \"deny\",\n  /** The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any') */\n    protocol: \"any\" | \"icmp\" | \"icmp6\" | \"tcp\" | \"udp\",\n  /** Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses) */\n    srcCidr: string,\n  /** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */\n    srcPort?: string,\n  /** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */\n    syslogEnabled?: boolean,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Short description of the client */\n description?: string, \n/** Timestamp client was first seen in the network */\n firstSeen?: number, \n/** 802.1x group policy of the client */\n groupPolicy8021x?: string, \n/** The ID of the client */\n id?: string, \n/** The IP address of the client */\n ip?: string, \n/** The IPv6 address of the client */\n ip6?: string, \n/** Local IPv6 address of the client */\n ip6Local?: string, \n/** Timestamp client was last seen in the network */\n lastSeen?: number, \n/** The MAC address of the client */\n mac?: string, \n/** Manufacturer of the client */\n manufacturer?: string, \n/** Notes on the client */\n notes?: string, \n/** The operating system of the client */\n os?: string, \n/** The MAC address of the node that the device was last connected to */\n recentDeviceMac?: string, \n/** The name of the node the device was last connected to */\n recentDeviceName?: string, \n/** The serial of the node the device was last connected to */\n recentDeviceSerial?: string, \n/** Status of SM for the client */\n smInstalled?: boolean, \n/** The name of the SSID that the client is connected to */\n ssid?: string, \n/** The connection status of the client */\n status?: \"Offline\" | \"Online\", \n/** The switch port that the client is connected to */\n switchport?: string, \n/** Usage, sent and received */\n usage?: { \n/** Usage received by the client */\n recv?: number, \n/** Usage sent by the client */\n sent?: number, }, \n/** The username of the user of the client */\n user?: string, \n/** The name of the VLAN that the client is connected to */\n vlan?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.description": {
        "rendered": "\n/** Short description of the client */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.firstSeen": {
        "rendered": "\n/** Timestamp client was first seen in the network */\n firstSeen?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.groupPolicy8021x": {
        "rendered": "\n/** 802.1x group policy of the client */\n groupPolicy8021x?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.id": {
        "rendered": "\n/** The ID of the client */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ip": {
        "rendered": "\n/** The IP address of the client */\n ip?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ip6": {
        "rendered": "\n/** The IPv6 address of the client */\n ip6?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ip6Local": {
        "rendered": "\n/** Local IPv6 address of the client */\n ip6Local?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.lastSeen": {
        "rendered": "\n/** Timestamp client was last seen in the network */\n lastSeen?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.mac": {
        "rendered": "\n/** The MAC address of the client */\n mac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.manufacturer": {
        "rendered": "\n/** Manufacturer of the client */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.notes": {
        "rendered": "\n/** Notes on the client */\n notes?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.os": {
        "rendered": "\n/** The operating system of the client */\n os?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.recentDeviceMac": {
        "rendered": "\n/** The MAC address of the node that the device was last connected to */\n recentDeviceMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.recentDeviceName": {
        "rendered": "\n/** The name of the node the device was last connected to */\n recentDeviceName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.recentDeviceSerial": {
        "rendered": "\n/** The serial of the node the device was last connected to */\n recentDeviceSerial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.smInstalled": {
        "rendered": "\n/** Status of SM for the client */\n smInstalled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ssid": {
        "rendered": "\n/** The name of the SSID that the client is connected to */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** The connection status of the client */\n status?: \"Offline\" | \"Online\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.switchport": {
        "rendered": "\n/** The switch port that the client is connected to */\n switchport?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.usage": {
        "rendered": "\n/** Usage, sent and received */\n usage?: { \n/** Usage received by the client */\n recv?: number, \n/** Usage sent by the client */\n sent?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.usage.recv": {
        "rendered": "\n/** Usage received by the client */\n recv?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.usage.sent": {
        "rendered": "\n/** Usage sent by the client */\n sent?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.user": {
        "rendered": "\n/** The username of the user of the client */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.vlan": {
        "rendered": "\n/** The name of the VLAN that the client is connected to */\n vlan?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/clients/connectionStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/latencyStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/clients/provision": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The policy to apply to the specified client. Can be 'Group policy', 'Whitelisted', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required. */\n    devicePolicy: \"Allowed\" | \"Blocked\" | \"Group policy\" | \"Normal\" | \"Per connection\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n  /** The MAC address of the client. Required. */\n    mac: string,\n  /** The display name for the client. Optional. Limited to 255 bytes. */\n    name?: string,\n  /** An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network) */\n    policiesBySecurityAppliance?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked' or 'Normal'. Required. */\n    devicePolicy?: \"Blocked\" | \"Normal\" | \"Whitelisted\",\n\n},\n  /** An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy */\n    policiesBySsid?: {\n  /** The number for the SSID */\n    \"0\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"1\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"2\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"3\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"4\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"5\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"6\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"7\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"8\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"9\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"10\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"11\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"12\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"13\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n  /** The number for the SSID */\n    \"14\"?: {\n  /** The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: \"Blocked\" | \"Group policy\" | \"Normal\" | \"Whitelisted\",\n  /** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to \"Group policy\". Otherwise this is ignored. */\n    groupPolicyId?: string,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/connectionStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/events": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 100. Default is 100. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 100. Default is 100. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/latencyHistory": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 791 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 791 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. */\n timespan?: number, \n/** The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. */\n resolution?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 791 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 791 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.resolution": {
        "rendered": "\n/** The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. */\n resolution?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/latencyStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/policy": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/clients/{clientId}/policy": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required. */\n    devicePolicy: string,\n  /** [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID. */\n    groupPolicyId?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs */\n    ssids: {\n  /** Splash authorization for SSID 0 */\n    \"0\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 1 */\n    \"1\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 2 */\n    \"2\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 3 */\n    \"3\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 4 */\n    \"4\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 5 */\n    \"5\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 6 */\n    \"6\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 7 */\n    \"7\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 8 */\n    \"8\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 9 */\n    \"9\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 10 */\n    \"10\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 11 */\n    \"11\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 12 */\n    \"12\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 13 */\n    \"13\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n  /** Splash authorization for SSID 14 */\n    \"14\"?: {\n  /** New authorization status for the SSID (true, false). */\n    isAuthorized?: boolean,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/clients/{clientId}/usageHistory": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".clientId": {
        "rendered": " clientId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/connectionStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/contentFiltering": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/contentFiltering": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A list of URL patterns that are allowed */\n    allowedUrlPatterns?: (string)[],\n  /** A list of URL categories to block */\n    blockedUrlCategories?: (string)[],\n  /** A list of URL patterns that are blocked */\n    blockedUrlPatterns?: (string)[],\n  /** URL category list size which is either 'topSites' or 'fullList' */\n    urlCategoryListSize?: \"fullList\" | \"topSites\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/contentFiltering/categories": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/devices/claim": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** [DEPRECATED] The serial of a device to claim */\n    serial?: string,\n  /** A list of serials of devices to claim */\n    serials?: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/devices/connectionStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/latencyStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/devices/{serial}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The address of a device */\n    address?: string,\n  /** The floor plan to associate to this device. null disassociates the device from the floorplan. */\n    floorPlanId?: string,\n  /**\n   * The latitude of a device\n   * @format float\n   */\n    lat?: number,\n  /**\n   * The longitude of a device\n   * @format float\n   */\n    lng?: number,\n  /** Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified. */\n    moveMapMarker?: boolean,\n  /** The name of a device */\n    name?: string,\n  /** The notes for the device. String. Limited to 255 characters. */\n    notes?: string,\n  /** The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template. */\n    switchProfileId?: string,\n  /** The tags of a device */\n    tags?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/connectionStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/latencyStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/lossAndLatencyHistory": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 60 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number, \n/** The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. */\n resolution?: number, \n/** The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. */\n uplink?: \"cellular\" | \"wan1\" | \"wan2\", \n/** The destination IP used to obtain the requested stats. This is required. */\n ip: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 60 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.resolution": {
        "rendered": "\n/** The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. */\n resolution?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.uplink": {
        "rendered": "\n/** The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. */\n uplink?: \"cellular\" | \"wan1\" | \"wan2\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ip": {
        "rendered": "\n/** The destination IP used to obtain the requested stats. This is required. */\n ip: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/performance": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/devices/{serial}/reboot": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/devices/{serial}/remove": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/uplink": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/devices/{serial}/wireless/status": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".serial": {
        "rendered": " serial: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/events": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental */\n productType?: string, \n/** A list of event types. The returned events will be filtered to only include events with these types. */\n includedEventTypes?: (string)[], \n/** A list of event types. The returned events will be filtered to exclude events with these types. */\n excludedEventTypes?: (string)[], \n/** The MAC address of the Meraki device which the list of events will be filtered with */\n deviceMac?: string, \n/** The serial of the Meraki device which the list of events will be filtered with */\n deviceSerial?: string, \n/** The name of the Meraki device which the list of events will be filtered with */\n deviceName?: string, \n/** The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. */\n clientIp?: string, \n/** The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. */\n clientMac?: string, \n/** The name, or partial name, of the client which the list of events will be filtered with */\n clientName?: string, \n/** The MAC address of the Systems Manager device which the list of events will be filtered with */\n smDeviceMac?: string, \n/** The name of the Systems Manager device which the list of events will be filtered with */\n smDeviceName?: string, \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.productType": {
        "rendered": "\n/** The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental */\n productType?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includedEventTypes": {
        "rendered": "\n/** A list of event types. The returned events will be filtered to only include events with these types. */\n includedEventTypes?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includedEventTypes.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.excludedEventTypes": {
        "rendered": "\n/** A list of event types. The returned events will be filtered to exclude events with these types. */\n excludedEventTypes?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.excludedEventTypes.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deviceMac": {
        "rendered": "\n/** The MAC address of the Meraki device which the list of events will be filtered with */\n deviceMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deviceSerial": {
        "rendered": "\n/** The serial of the Meraki device which the list of events will be filtered with */\n deviceSerial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deviceName": {
        "rendered": "\n/** The name of the Meraki device which the list of events will be filtered with */\n deviceName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.clientIp": {
        "rendered": "\n/** The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. */\n clientIp?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.clientMac": {
        "rendered": "\n/** The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. */\n clientMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.clientName": {
        "rendered": "\n/** The name, or partial name, of the client which the list of events will be filtered with */\n clientName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.smDeviceMac": {
        "rendered": "\n/** The MAC address of the Systems Manager device which the list of events will be filtered with */\n smDeviceMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.smDeviceName": {
        "rendered": "\n/** The name of the Systems Manager device which the list of events will be filtered with */\n smDeviceName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/events/eventTypes": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/failedConnections": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Filter by AP */\n serial?: string, \n/** Filter by client MAC */\n clientId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.serial": {
        "rendered": "\n/** Filter by AP */\n serial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.clientId": {
        "rendered": "\n/** Filter by client MAC */\n clientId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/firewalledServices": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/firewalledServices/{service}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".service": {
        "rendered": " service: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/firewalledServices/{service}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are \"blocked\" (no remote IPs can access the service), \"restricted\" (only whitelisted IPs can access the service), and \"unrestriced\" (any remote IP can access the service). This field is required */\n    access: \"blocked\" | \"restricted\" | \"unrestricted\",\n  /** An array of whitelisted IPs that can access the service. This field is required if \"access\" is set to \"restricted\". Otherwise this field is ignored */\n    allowedIps?: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".service": {
        "rendered": " service: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/floorPlans": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/floorPlans": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The longitude and latitude of the bottom left corner of your floor plan. */\n    bottomLeftCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the bottom right corner of your floor plan. */\n    bottomRightCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair. */\n    center?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /**\n   * The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.\n   * @format byte\n   */\n    imageContents: string,\n  /** The name of your floor plan. */\n    name: string,\n  /** The longitude and latitude of the top left corner of your floor plan. */\n    topLeftCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the top right corner of your floor plan. */\n    topRightCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/floorPlans/{floorPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".floorPlanId": {
        "rendered": " floorPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/floorPlans/{floorPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".floorPlanId": {
        "rendered": " floorPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/floorPlans/{floorPlanId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The longitude and latitude of the bottom left corner of your floor plan. */\n    bottomLeftCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the bottom right corner of your floor plan. */\n    bottomRightCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair. */\n    center?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /**\n   * The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.\n   * @format byte\n   */\n    imageContents?: string,\n  /** The name of your floor plan. */\n    name?: string,\n  /** The longitude and latitude of the top left corner of your floor plan. */\n    topLeftCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n  /** The longitude and latitude of the top right corner of your floor plan. */\n    topRightCorner?: {\n  /**\n   * Latitude\n   * @format float\n   */\n    lat?: number,\n  /**\n   * Longitude\n   * @format float\n   */\n    lng?: number,\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".floorPlanId": {
        "rendered": " floorPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/l3FirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/l3FirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An ordered array of the firewall rules (not including the default rule) */\n    rules?: ({\n  /** Description of the rule (optional) */\n    comment?: string,\n  /** Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any' */\n    destCidr: string,\n  /** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */\n    destPort?: string,\n  /** 'allow' or 'deny' traffic specified by this rule */\n    policy: \"allow\" | \"deny\",\n  /** The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any') */\n    protocol: \"any\" | \"icmp\" | \"icmp6\" | \"tcp\" | \"udp\",\n  /** Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses) */\n    srcCidr: string,\n  /** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */\n    srcPort?: string,\n  /** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */\n    syslogEnabled?: boolean,\n\n})[],\n  /** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */\n    syslogDefaultRule?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/l7FirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/l7FirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An ordered array of the MX L7 firewall rules */\n    rules?: ({\n  /** 'Deny' traffic specified by this rule */\n    policy?: \"deny\",\n  /** Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange' */\n    type?: \"application\" | \"applicationCategory\" | \"host\" | \"ipRange\" | \"port\",\n  /** The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format. */\n    value?: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/l7FirewallRules/applicationCategories": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/latencyStats": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number, \n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\", \n/** Filter results by SSID */\n ssid?: number, \n/** Filter results by VLAN */\n vlan?: number, \n/** Filter results by AP Tag */\n apTag?: string, \n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 180 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 7 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.band": {
        "rendered": "\n/** Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information. */\n band?: \"2.4\" | \"5\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssid": {
        "rendered": "\n/** Filter results by SSID */\n ssid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.vlan": {
        "rendered": "\n/** Filter results by VLAN */\n vlan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apTag": {
        "rendered": "\n/** Filter results by AP Tag */\n apTag?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/merakiAuthUsers": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".merakiAuthUserId": {
        "rendered": " merakiAuthUserId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/oneToManyNatRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/oneToManyNatRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An array of 1:Many nat rules */\n    rules: ({\n  /** An array of associated forwarding rules */\n    portRules: ({\n  /** Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any' */\n    allowedIps?: (string)[],\n  /** Local IP address to which traffic will be forwarded */\n    localIp?: string,\n  /** Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port */\n    localPort?: string,\n  /** A description of the rule */\n    name?: string,\n  /** 'tcp' or 'udp' */\n    protocol?: \"tcp\" | \"udp\",\n  /** Destination port of the traffic that is arriving on the WAN */\n    publicPort?: string,\n\n})[],\n  /** The IP address that will be used to access the internal resource from the WAN */\n    publicIp: string,\n  /** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2') */\n    uplink: \"internet1\" | \"internet2\",\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/oneToOneNatRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/oneToOneNatRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An array of 1:1 nat rules */\n    rules: ({\n  /** The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource */\n    allowedInbound?: ({\n  /** An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any' */\n    allowedIps?: (string)[],\n  /** An array of ports or port ranges that will be forwarded to the host on the LAN */\n    destinationPorts?: (string)[],\n  /** Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any' */\n    protocol?: \"any\" | \"icmp-ping\" | \"tcp\" | \"udp\",\n\n})[],\n  /** The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN */\n    lanIp: string,\n  /** A descriptive name for the rule */\n    name?: string,\n  /** The IP address that will be used to access the internal resource from the WAN */\n    publicIp?: string,\n  /** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2') */\n    uplink?: \"internet1\" | \"internet2\",\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/pii/piiKeys": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The username of a Systems Manager user */\n username?: string, \n/** The email of a network user account or a Systems Manager device */\n email?: string, \n/** The MAC of a network client device or a Systems Manager device */\n mac?: string, \n/** The serial of a Systems Manager device */\n serial?: string, \n/** The IMEI of a Systems Manager device */\n imei?: string, \n/** The MAC of a Bluetooth client */\n bluetoothMac?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.username": {
        "rendered": "\n/** The username of a Systems Manager user */\n username?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.email": {
        "rendered": "\n/** The email of a network user account or a Systems Manager device */\n email?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.mac": {
        "rendered": "\n/** The MAC of a network client device or a Systems Manager device */\n mac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.serial": {
        "rendered": "\n/** The serial of a Systems Manager device */\n serial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.imei": {
        "rendered": "\n/** The IMEI of a Systems Manager device */\n imei?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bluetoothMac": {
        "rendered": "\n/** The MAC of a Bluetooth client */\n bluetoothMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/pii/requests": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/pii/requests": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The datasets related to the provided key that should be deleted. Only applies to \"delete\" requests. The value \"all\" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user) */\n    datasets?: (string)[],\n  /** The email of a network user account. Only applies to \"delete\" requests. */\n    email?: string,\n  /** The MAC of a network client device. Applies to both \"restrict processing\" and \"delete\" requests. */\n    mac?: string,\n  /** The sm_device_id of a Systems Manager device. The only way to \"restrict processing\" or \"delete\" a Systems Manager device. Must include \"device\" in the dataset for a \"delete\" request to destroy the device. */\n    smDeviceId?: string,\n  /** The sm_user_id of a Systems Manager user. The only way to \"restrict processing\" or \"delete\" a Systems Manager user. Must include \"user\" in the dataset for a \"delete\" request to destroy the user. */\n    smUserId?: string,\n  /** One of \"delete\" or \"restrict processing\" */\n    type?: \"delete\" | \"restrict processing\",\n  /** The username of a network log in. Only applies to \"delete\" requests. */\n    username?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/pii/requests/{requestId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".requestId": {
        "rendered": " requestId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/pii/requests/{requestId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".requestId": {
        "rendered": " requestId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/pii/smDevicesForKey": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The username of a Systems Manager user */\n username?: string, \n/** The email of a network user account or a Systems Manager device */\n email?: string, \n/** The MAC of a network client device or a Systems Manager device */\n mac?: string, \n/** The serial of a Systems Manager device */\n serial?: string, \n/** The IMEI of a Systems Manager device */\n imei?: string, \n/** The MAC of a Bluetooth client */\n bluetoothMac?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.username": {
        "rendered": "\n/** The username of a Systems Manager user */\n username?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.email": {
        "rendered": "\n/** The email of a network user account or a Systems Manager device */\n email?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.mac": {
        "rendered": "\n/** The MAC of a network client device or a Systems Manager device */\n mac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.serial": {
        "rendered": "\n/** The serial of a Systems Manager device */\n serial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.imei": {
        "rendered": "\n/** The IMEI of a Systems Manager device */\n imei?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bluetoothMac": {
        "rendered": "\n/** The MAC of a Bluetooth client */\n bluetoothMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/pii/smOwnersForKey": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The username of a Systems Manager user */\n username?: string, \n/** The email of a network user account or a Systems Manager device */\n email?: string, \n/** The MAC of a network client device or a Systems Manager device */\n mac?: string, \n/** The serial of a Systems Manager device */\n serial?: string, \n/** The IMEI of a Systems Manager device */\n imei?: string, \n/** The MAC of a Bluetooth client */\n bluetoothMac?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.username": {
        "rendered": "\n/** The username of a Systems Manager user */\n username?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.email": {
        "rendered": "\n/** The email of a network user account or a Systems Manager device */\n email?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.mac": {
        "rendered": "\n/** The MAC of a network client device or a Systems Manager device */\n mac?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.serial": {
        "rendered": "\n/** The serial of a Systems Manager device */\n serial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.imei": {
        "rendered": "\n/** The IMEI of a Systems Manager device */\n imei?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bluetoothMac": {
        "rendered": "\n/** The MAC of a Bluetooth client */\n bluetoothMac?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/portForwardingRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/portForwardingRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An array of port forwarding params */\n    rules: ({\n  /** An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any) */\n    allowedIps: (string)[],\n  /** The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN */\n    lanIp: string,\n  /** A port or port ranges that will receive the forwarded traffic from the WAN */\n    localPort: string,\n  /** A descriptive name for the rule */\n    name?: string,\n  /** TCP or UDP */\n    protocol: \"tcp\" | \"udp\",\n  /** A port or port ranges that will be forwarded to the host on the LAN */\n    publicPort: string,\n  /** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both') */\n    uplink?: \"both\" | \"internet1\" | \"internet2\",\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/security/intrusionSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/security/intrusionSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved */\n    idsRulesets?: \"balanced\" | \"connectivity\" | \"security\",\n  /** Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged) */\n    mode?: \"detection\" | \"disabled\" | \"prevention\",\n  /** Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode */\n    protectedNetworks?: {\n  /** list of IP addresses or subnets being excluded from protection (required if 'useDefault' is false) */\n    excludedCidr?: (string)[],\n  /** list of IP addresses or subnets being protected (required if 'useDefault' is false) */\n    includedCidr?: (string)[],\n  /** true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved */\n    useDefault?: boolean,\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/security/malwareSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/security/malwareSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing */\n    allowedFiles?: ({\n  /** Comment about the allowed entity */\n    comment: string,\n  /** The file sha256 hash to allow */\n    \"sha256\": string,\n\n})[],\n  /** The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing */\n    allowedUrls?: ({\n  /** Comment about the allowed entity */\n    comment: string,\n  /** The url to allow */\n    url: string,\n\n})[],\n  /** Set mode to 'enabled' to enable malware prevention, otherwise 'disabled' */\n    mode: \"disabled\" | \"enabled\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/securityEvents": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/siteToSiteVpn": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/siteToSiteVpn": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required. */\n    hubs?: ({\n  /** The network ID of the hub. */\n    hubId: string,\n  /** Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub. */\n    useDefaultRoute?: boolean,\n\n})[],\n  /** The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub' */\n    mode: \"hub\" | \"none\" | \"spoke\",\n  /** The list of subnets and their VPN presence. */\n    subnets?: ({\n  /** The CIDR notation subnet used within the VPN */\n    localSubnet: string,\n  /** Indicates the presence of the subnet in the VPN */\n    useVpn?: boolean,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/sm/bypassActivationLockAttempts": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ids of the devices to attempt activation lock bypass. */\n    ids: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".attemptId": {
        "rendered": " attemptId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/sm/device/fields": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The new fields of the device. Each field of this object is optional. */\n    deviceFields: {\n  /** New name for the device */\n    name?: string,\n  /** New notes for the device */\n    notes?: string,\n\n},\n  /** The id of the device to be modified. */\n    id?: string,\n  /** The serial of the device to be modified. */\n    serial?: string,\n  /** The wifiMac of the device to be modified. */\n    wifiMac?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/sm/device/wipe": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The id of the device to be wiped. */\n    id?: string,\n  /** The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices. */\n    pin?: number,\n  /** The serial of the device to be wiped. */\n    serial?: string,\n  /** The wifiMac of the device to be wiped. */\n    wifiMac?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/sm/device/{deviceId}/refreshDetails": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/sm/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Additional fields that will be displayed for each device. Multiple fields can be passed in as comma separated values.\n    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,\n    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,\n    ownerEmail, ownerUsername, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,\n    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,\n    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,\n    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion. */\n fields?: string, \n/** Filter devices by wifi mac(s). Multiple wifi macs can be passed in as comma separated values. */\n wifiMacs?: string, \n/** Filter devices by serial(s). Multiple serials can be passed in as comma separated values. */\n serials?: string, \n/** Filter devices by id(s). Multiple ids can be passed in as comma separated values. */\n ids?: string, \n/** Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags as comma separated values. */\n scope?: string, \n/** Number of devices to return, 1000 is the default as well as the max. */\n batchSize?: number, \n/** If the network has more devices than the batch size, a batch token will be returned\n    as a part of the device list. To see the remainder of the devices, pass in the batchToken as a parameter in the next request.\n    Requests made with the batchToken do not require additional parameters as the batchToken includes the parameters passed in\n    with the original request. Additional parameters passed in with the batchToken will be ignored. */\n batchToken?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Additional fields that will be displayed for each device. Multiple fields can be passed in as comma separated values.\n    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,\n    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,\n    ownerEmail, ownerUsername, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,\n    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,\n    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,\n    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion. */\n fields?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.wifiMacs": {
        "rendered": "\n/** Filter devices by wifi mac(s). Multiple wifi macs can be passed in as comma separated values. */\n wifiMacs?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.serials": {
        "rendered": "\n/** Filter devices by serial(s). Multiple serials can be passed in as comma separated values. */\n serials?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ids": {
        "rendered": "\n/** Filter devices by id(s). Multiple ids can be passed in as comma separated values. */\n ids?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.scope": {
        "rendered": "\n/** Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags as comma separated values. */\n scope?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.batchSize": {
        "rendered": "\n/** Number of devices to return, 1000 is the default as well as the max. */\n batchSize?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.batchToken": {
        "rendered": "\n/** If the network has more devices than the batch size, a batch token will be returned\n    as a part of the device list. To see the remainder of the devices, pass in the batchToken as a parameter in the next request.\n    Requests made with the batchToken do not require additional parameters as the batchToken includes the parameters passed in\n    with the original request. Additional parameters passed in with the batchToken will be ignored. */\n batchToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/sm/devices/checkin": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ids of the devices to be checked-in. */\n    ids?: string,\n  /** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in. */\n    scope?: string,\n  /** The serials of the devices to be checked-in. */\n    serials?: string,\n  /** The wifiMacs of the devices to be checked-in. */\n    wifiMacs?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/sm/devices/tags": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ids of the devices to be modified. */\n    ids?: string,\n  /** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified. */\n    scope?: string,\n  /** The serials of the devices to be modified. */\n    serials?: string,\n  /** The tags to be added, deleted, or updated. */\n    tags: string,\n  /** One of add, delete, or update. Only devices that have been modified will be returned. */\n    updateAction: string,\n  /** The wifiMacs of the devices to be modified. */\n    wifiMacs?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/sm/devices/{deviceId}/unenroll": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/profiles": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/targetGroups": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response */\n withDetails?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.withDetails": {
        "rendered": "\n/** Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response */\n withDetails?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/sm/targetGroups": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of this target group */\n    name?: string,\n  /** The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty. */\n    scope?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/sm/targetGroups/{targetGroupId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".targetGroupId": {
        "rendered": " targetGroupId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/sm/targetGroups/{targetGroupId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response */\n withDetails?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.withDetails": {
        "rendered": "\n/** Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response */\n withDetails?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".targetGroupId": {
        "rendered": " targetGroupId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/sm/targetGroups/{targetGroupId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of this target group */\n    name?: string,\n  /** The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty. */\n    scope?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".targetGroupId": {
        "rendered": " targetGroupId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/user/{userId}/deviceProfiles": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".userId": {
        "rendered": " userId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/user/{userId}/softwares": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".userId": {
        "rendered": " userId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/users": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Filter users by id(s). Multiple ids can be passed in as comma separated values. */\n ids?: string, \n/** Filter users by username(s). Multiple usernames can be passed in as comma separated values. */\n usernames?: string, \n/** Filter users by email(s). Multiple emails can be passed in as comma separated values. */\n emails?: string, \n/** Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags as comma separated values. */\n scope?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ids": {
        "rendered": "\n/** Filter users by id(s). Multiple ids can be passed in as comma separated values. */\n ids?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.usernames": {
        "rendered": "\n/** Filter users by username(s). Multiple usernames can be passed in as comma separated values. */\n usernames?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.emails": {
        "rendered": "\n/** Filter users by email(s). Multiple emails can be passed in as comma separated values. */\n emails?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.scope": {
        "rendered": "\n/** Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags as comma separated values. */\n scope?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/cellularUsageHistory": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/certs": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/deviceProfiles": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/networkAdapters": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/restrictions": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/securityCenters": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/softwares": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/sm/{deviceId}/wlanLists": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".deviceId": {
        "rendered": " deviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/snmpSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/splashLoginAttempts": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Only return the login attempts for the specified SSID */\n ssidNumber?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14, \n/** The username, email, or phone number used during login */\n loginIdentifier?: string, \n/** The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ssidNumber": {
        "rendered": "\n/** Only return the login attempts for the specified SSID */\n ssidNumber?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.loginIdentifier": {
        "rendered": "\n/** The username, email, or phone number used during login */\n loginIdentifier?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/split": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/ssids": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/ssids/{number}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/ssids/{number}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */\n    apTagsAndVlanIds?: ({\n  /** Comma-separated list of AP tags */\n    tags?: string,\n  /** Numerical identifier that is assigned to the VLAN */\n    vlanId?: number,\n\n})[],\n  /** The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius') */\n    authMode?: \"8021x-google\" | \"8021x-localradius\" | \"8021x-meraki\" | \"8021x-nac\" | \"8021x-radius\" | \"ipsk-with-radius\" | \"ipsk-without-radius\" | \"open\" | \"open-enhanced\" | \"open-with-nac\" | \"open-with-radius\" | \"psk\",\n  /** Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list. */\n    availabilityTags?: (string)[],\n  /** Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags. */\n    availableOnAllAps?: boolean,\n  /** The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering') */\n    bandSelection?: string,\n  /** The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'. */\n    concentratorNetworkId?: string,\n  /** The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */\n    defaultVlanId?: number,\n  /** Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'. */\n    disassociateClientsOnVpnFailover?: boolean,\n  /** Whether or not the SSID is enabled */\n    enabled?: boolean,\n  /** The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk' */\n    encryptionMode?: \"wep\" | \"wpa\",\n  /** Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled') */\n    enterpriseAdminAccess?: \"access disabled\" | \"access enabled\",\n  /** The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN') */\n    ipAssignmentMode?: string,\n  /** Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'. */\n    lanIsolationEnabled?: boolean,\n  /**\n   * The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')\n   * @format float\n   */\n    minBitrate?: number,\n  /** The name of the SSID */\n    name?: string,\n  /** The download bandwidth limit in Kbps. (0 represents no limit.) */\n    perClientBandwidthLimitDown?: number,\n  /** The upload bandwidth limit in Kbps. (0 represents no limit.) */\n    perClientBandwidthLimitUp?: number,\n  /** The passkey for the SSID. This param is only valid if the authMode is 'psk' */\n    psk?: string,\n  /** Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' */\n    radiusAccountingEnabled?: boolean,\n  /** The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true' */\n    radiusAccountingServers?: ({\n  /** IP address to which the APs will send RADIUS accounting messages */\n    host: string,\n  /** Port on the RADIUS server that is listening for accounting messages */\n    port?: number,\n  /** Shared key used to authenticate messages between the APs and RADIUS server */\n    secret?: string,\n\n})[],\n  /** Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message */\n    radiusAttributeForGroupPolicies?: string,\n  /** If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server. */\n    radiusCoaEnabled?: boolean,\n  /** This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access') */\n    radiusFailoverPolicy?: \"Allow access\" | \"Deny access\",\n  /** This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin') */\n    radiusLoadBalancingPolicy?: \"Round robin\" | \"Strict priority order\",\n  /** If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'. */\n    radiusOverride?: boolean,\n  /** The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' */\n    radiusServers?: ({\n  /** IP address of your RADIUS server */\n    host: string,\n  /** UDP port the RADIUS server listens on for Access-requests */\n    port?: number,\n  /** RADIUS client shared secret */\n    secret?: string,\n\n})[],\n  /** The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.) */\n    secondaryConcentratorNetworkId?: string,\n  /** The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children. */\n    splashPage?: \"Billing\" | \"Cisco ISE\" | \"Click-through splash page\" | \"Facebook Wi-Fi\" | \"Google Apps domain\" | \"Google OAuth\" | \"None\" | \"Password-protected with Active Directory\" | \"Password-protected with LDAP\" | \"Password-protected with Meraki RADIUS\" | \"Password-protected with custom RADIUS\" | \"SMS authentication\" | \"Sponsored guest\" | \"Systems Manager Sentry\",\n  /** Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */\n    useVlanTagging?: boolean,\n  /** Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true */\n    visible?: boolean,\n  /** The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN' */\n    vlanId?: number,\n  /** Allow access to a configurable list of IP ranges, which users may access prior to sign-on. */\n    walledGardenEnabled?: boolean,\n  /** Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki's splash page is automatically included in your walled garden. */\n    walledGardenRanges?: string,\n  /** The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only') */\n    wpaEncryptionMode?: \"WPA1 and WPA2\" | \"WPA1 only\" | \"WPA2 only\" | \"WPA3 Transition Mode\" | \"WPA3 only\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/ssids/{number}/l3FirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/ssids/{number}/l3FirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional) */\n    allowLanAccess?: boolean,\n  /** An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule) */\n    rules?: ({\n  /** Description of the rule (optional) */\n    comment?: string,\n  /** Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any' */\n    destCidr: string,\n  /** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */\n    destPort?: string,\n  /** 'allow' or 'deny' traffic specified by this rule */\n    policy: \"allow\" | \"deny\",\n  /** The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any') */\n    protocol: \"any\" | \"icmp\" | \"icmp6\" | \"tcp\" | \"udp\",\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/ssids/{number}/splashSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/ssids/{number}/splashSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl' */\n    splashUrl?: string,\n  /** [optional] Boolean indicating whether the user will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL. */\n    useSplashUrl?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".number": {
        "rendered": " number: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/staticRoutes": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/staticRoutes": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The gateway IP (next hop) of the static route */\n    gatewayIp: string,\n  /** The name of the new static route */\n    name: string,\n  /** The subnet of the static route */\n    subnet: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/staticRoutes/{staticRouteId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".staticRouteId": {
        "rendered": " staticRouteId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/staticRoutes/{staticRouteId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".staticRouteId": {
        "rendered": " staticRouteId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/staticRoutes/{staticRouteId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The enabled state of the static route */\n    enabled?: boolean,\n  /** The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain \"ip\" and \"name\" string fields. See the sample request/response for more details. */\n    fixedIpAssignments?: hasuraSdk.JSONValue,\n  /** The gateway IP (next hop) of the static route */\n    gatewayIp?: string,\n  /** The name of the static route */\n    name?: string,\n  /** The DHCP reserved IP ranges on the static route */\n    reservedIpRanges?: ({\n  /** A text comment for the reserved range */\n    comment: string,\n  /** The last IP in the reserved range */\n    end: string,\n  /** The first IP in the reserved range */\n    start: string,\n\n})[],\n  /** The subnet of the static route */\n    subnet?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".staticRouteId": {
        "rendered": " staticRouteId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/swapWarmSpare": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/linkAggregations": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switch/linkAggregations": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported. */\n    switchPorts?: ({\n  /** Port identifier of switch port. For modules, the identifier is \"SlotNumber_ModuleType_PortNumber\" (Ex: \"1_8X10G_1\"), otherwise it is just the port number (Ex: \"8\"). */\n    portId: string,\n  /** Serial number of the switch. */\n    serial: string,\n\n})[],\n  /** Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported. */\n    switchProfilePorts?: ({\n  /** Port identifier of switch port. For modules, the identifier is \"SlotNumber_ModuleType_PortNumber\" (Ex: \"1_8X10G_1\"), otherwise it is just the port number (Ex: \"8\"). */\n    portId: string,\n  /** Profile identifier. */\n    profile: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/switch/linkAggregations/{linkAggregationId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".linkAggregationId": {
        "rendered": " linkAggregationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/networks/{networkId}/switch/linkAggregations/{linkAggregationId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported. */\n    switchPorts?: ({\n  /** Port identifier of switch port. For modules, the identifier is \"SlotNumber_ModuleType_PortNumber\" (Ex: \"1_8X10G_1\"), otherwise it is just the port number (Ex: \"8\"). */\n    portId: string,\n  /** Serial number of the switch. */\n    serial: string,\n\n})[],\n  /** Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported. */\n    switchProfilePorts?: ({\n  /** Port identifier of switch port. For modules, the identifier is \"SlotNumber_ModuleType_PortNumber\" (Ex: \"1_8X10G_1\"), otherwise it is just the port number (Ex: \"8\"). */\n    portId: string,\n  /** Profile identifier. */\n    profile: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".linkAggregationId": {
        "rendered": " linkAggregationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/portSchedules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switch/portSchedules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name for your port schedule. Required */\n    name: string,\n  /**\n   *     The schedule for switch port scheduling. Schedules are applied to days of the week.\n   *     When it's empty, default schedule with all days of a week are configured.\n   *     Any unspecified day in the schedule is added as a default schedule configuration of the day.\n   */\n    portSchedule?: {\n  /** The schedule object for Friday. */\n    friday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Monday. */\n    monday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Saturday. */\n    saturday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Sunday. */\n    sunday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Thursday. */\n    thursday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Tuesday. */\n    tuesday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Wednesday. */\n    wednesday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/switch/portSchedules/{portScheduleId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".portScheduleId": {
        "rendered": " portScheduleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/networks/{networkId}/switch/portSchedules/{portScheduleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name for your port schedule. */\n    name?: string,\n  /**\n   *     The schedule for switch port scheduling. Schedules are applied to days of the week.\n   *     When it's empty, default schedule with all days of a week are configured.\n   *     Any unspecified day in the schedule is added as a default schedule configuration of the day.\n   */\n    portSchedule?: {\n  /** The schedule object for Friday. */\n    friday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Monday. */\n    monday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Saturday. */\n    saturday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Sunday. */\n    sunday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Thursday. */\n    thursday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Tuesday. */\n    tuesday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n  /** The schedule object for Wednesday. */\n    wednesday?: {\n  /** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */\n    active?: boolean,\n  /** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */\n    from?: string,\n  /** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */\n    to?: string,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".portScheduleId": {
        "rendered": " portScheduleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Exceptions on a per switch basis to \"useCombinedPower\" */\n    powerExceptions?: ({\n  /** Per switch exception (combined, redundant, useNetworkSetting) */\n    powerType: \"combined\" | \"redundant\" | \"useNetworkSetting\",\n  /** Serial number of the switch */\n    serial: string,\n\n})[],\n  /** The use Combined Power as the default behavior of secondary power supplies on supported devices. */\n    useCombinedPower?: boolean,\n  /** Management VLAN */\n    vlan?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/mtu": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings/mtu": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** MTU size for the entire network. Default value is 9578. */\n    defaultMtuSize?: number,\n  /** Override MTU size for individual switches or switch profiles. An empty array will clear overrides. */\n    overrides?: ({\n  /** MTU size for the switches or switch profiles. */\n    mtuSize: number,\n  /** List of switch profile IDs. Applicable only for template network. */\n    switchProfiles?: (string)[],\n  /** List of switch serials. Applicable only for switch network. */\n    switches?: (string)[],\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/multicast": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings/multicast": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default. */\n    defaultSettings?: {\n  /** Flood unknown multicast traffic setting for entire network */\n    floodUnknownMulticastTrafficEnabled?: boolean,\n  /** IGMP snooping setting for entire network */\n    igmpSnoopingEnabled?: boolean,\n\n},\n  /** Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings. */\n    overrides?: ({\n  /** Flood unknown multicast traffic setting for switches, switch stacks or switch profiles */\n    floodUnknownMulticastTrafficEnabled: boolean,\n  /** IGMP snooping setting for switches, switch stacks or switch profiles */\n    igmpSnoopingEnabled: boolean,\n  /** List of switch stack ids for non-template network */\n    stacks?: (string)[],\n  /** List of switch profiles ids for template network */\n    switchProfiles?: (string)[],\n  /** List of switch serials for non-template network */\n    switches?: (string)[],\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/qosRules": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switch/settings/qosRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0 */\n    dscp?: number,\n  /** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */\n    dstPort?: number,\n  /** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */\n    dstPortRange?: string,\n  /** The protocol of the incoming packet. Can be one of \"ANY\", \"TCP\" or \"UDP\". Default value is \"ANY\" */\n    protocol?: \"ANY\" | \"TCP\" | \"UDP\",\n  /** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */\n    srcPort?: number,\n  /** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */\n    srcPortRange?: string,\n  /** The VLAN of the incoming packet. A null value will match any VLAN. */\n    vlan: number,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/qosRules/order": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings/qosRules/order": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A list of quality of service rule IDs arranged in order in which they should be processed by the switch. */\n    ruleIds: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/switch/settings/qosRules/{qosRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qosRuleId": {
        "rendered": " qosRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/qosRules/{qosRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qosRuleId": {
        "rendered": " qosRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings/qosRules/{qosRuleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0. */\n    dscp?: number,\n  /** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */\n    dstPort?: number,\n  /** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */\n    dstPortRange?: string,\n  /** The protocol of the incoming packet. Can be one of \"ANY\", \"TCP\" or \"UDP\". Default value is \"ANY\". */\n    protocol?: \"ANY\" | \"TCP\" | \"UDP\",\n  /** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */\n    srcPort?: number,\n  /** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */\n    srcPortRange?: string,\n  /** The VLAN of the incoming packet. A null value will match any VLAN. */\n    vlan?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".qosRuleId": {
        "rendered": " qosRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switch/settings/stormControl": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/switch/settings/stormControl": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration. */\n    broadcastThreshold?: number,\n  /** Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration. */\n    multicastThreshold?: number,\n  /** Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration. */\n    unknownUnicastThreshold?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/switchStacks": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switchStacks": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of the new stack */\n    name: string,\n  /** An array of switch serials to be added into the new stack */\n    serials: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/switchStacks/{switchStackId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".switchStackId": {
        "rendered": " switchStackId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/switchStacks/{switchStackId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".switchStackId": {
        "rendered": " switchStackId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switchStacks/{switchStackId}/add": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The serial of the switch to be added */\n    serial: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".switchStackId": {
        "rendered": " switchStackId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/switchStacks/{switchStackId}/remove": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The serial of the switch to be removed */\n    serial: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".switchStackId": {
        "rendered": " switchStackId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/syslogServers": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/syslogServers": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A list of the syslog servers for this network */\n    servers: ({\n  /** The IP address of the syslog server */\n    host: string,\n  /** The port of the syslog server */\n    port: number,\n  /** A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events' */\n    roles: (string)[],\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/traffic": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 30 days from today. */\n t0?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. */\n timespan?: number, \n/** Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage. */\n deviceType?: \"appliance\" | \"combined\" | \"switch\" | \"wireless\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 30 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deviceType": {
        "rendered": "\n/** Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage. */\n deviceType?: \"appliance\" | \"combined\" | \"switch\" | \"wireless\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/unbind": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/uplinkSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/uplinkSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network) */\n    bandwidthLimits?: {\n  /** The bandwidth settings for the 'cellular' uplink */\n    cellular?: {\n  /** The maximum download limit (integer, in Kbps). null indicates no limit */\n    limitDown?: number,\n  /** The maximum upload limit (integer, in Kbps). null indicates no limit */\n    limitUp?: number,\n\n},\n  /** The bandwidth settings for the 'wan1' uplink */\n    \"wan1\"?: {\n  /** The maximum download limit (integer, in Kbps). null indicates no limit */\n    limitDown?: number,\n  /** The maximum upload limit (integer, in Kbps). null indicates no limit */\n    limitUp?: number,\n\n},\n  /** The bandwidth settings for the 'wan2' uplink */\n    \"wan2\"?: {\n  /** The maximum download limit (integer, in Kbps). null indicates no limit */\n    limitDown?: number,\n  /** The maximum upload limit (integer, in Kbps). null indicates no limit */\n    limitUp?: number,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/vlans": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/vlans": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The local IP of the appliance on the VLAN */\n    applianceIp: string,\n  /** The id of the desired group policy to apply to the VLAN */\n    groupPolicyId?: string,\n  /** The VLAN ID of the new VLAN (must be between 1 and 4094) */\n    id: string,\n  /** The name of the new VLAN */\n    name: string,\n  /** The subnet of the VLAN */\n    subnet: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/vlans/{vlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".vlanId": {
        "rendered": " vlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/vlans/{vlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".vlanId": {
        "rendered": " vlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/vlans/{vlanId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The local IP of the appliance on the VLAN */\n    applianceIp?: string,\n  /** DHCP boot option for boot filename */\n    dhcpBootFilename?: string,\n  /** DHCP boot option to direct boot clients to the server to load the boot file from */\n    dhcpBootNextServer?: string,\n  /** Use DHCP boot options specified in other properties */\n    dhcpBootOptionsEnabled?: boolean,\n  /** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */\n    dhcpHandling?: \"Do not respond to DHCP requests\" | \"Relay DHCP to another server\" | \"Run a DHCP server\",\n  /** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */\n    dhcpLeaseTime?: \"1 day\" | \"1 hour\" | \"1 week\" | \"12 hours\" | \"30 minutes\" | \"4 hours\",\n  /** The list of DHCP options that will be included in DHCP responses. Each object in the list should have \"code\", \"type\", and \"value\" properties. */\n    dhcpOptions?: ({\n  /** The code for the DHCP option. This should be an integer between 2 and 254. */\n    code: string,\n  /** The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer' */\n    type: \"hex\" | \"integer\" | \"ip\" | \"text\",\n  /** The value for the DHCP option */\n    value: string,\n\n})[],\n  /** The IPs of the DHCP servers that DHCP requests should be relayed to */\n    dhcpRelayServerIps?: (string)[],\n  /** The DNS nameservers used for DHCP responses, either \"upstream_dns\", \"google_dns\", \"opendns\", or a newline seperated string of IP addresses or domain names */\n    dnsNameservers?: string,\n  /** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain \"ip\" and \"name\" string fields. See the sample request/response for more details. */\n    fixedIpAssignments?: hasuraSdk.JSONValue,\n  /** The id of the desired group policy to apply to the VLAN */\n    groupPolicyId?: string,\n  /** The name of the VLAN */\n    name?: string,\n  /** The DHCP reserved IP ranges on the VLAN */\n    reservedIpRanges?: ({\n  /** A text comment for the reserved range */\n    comment: string,\n  /** The last IP in the reserved range */\n    end: string,\n  /** The first IP in the reserved range */\n    start: string,\n\n})[],\n  /** The subnet of the VLAN */\n    subnet?: string,\n  /** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */\n    vpnNatSubnet?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".vlanId": {
        "rendered": " vlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/vlansEnabledState": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/vlansEnabledState": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Boolean indicating whether to enable (true) or disable (false) VLANs for the network */\n    enabled: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/warmSpareSettings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/warmSpareSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Enable warm spare */\n    enabled: boolean,\n  /** Serial number of the warm spare appliance */\n    spareSerial?: string,\n  /** Uplink mode, either virtual or public */\n    uplinkMode?: string,\n  /** The WAN 1 shared IP */\n    \"virtualIp1\"?: string,\n  /** The WAN 2 shared IP */\n    \"virtualIp2\"?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/wireless/rfProfiles": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. */\n includeTemplateProfiles?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includeTemplateProfiles": {
        "rendered": "\n/** If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. */\n includeTemplateProfiles?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/networks/{networkId}/wireless/rfProfiles": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Settings that will be enabled if selectionType is set to 'ap'. */\n    apBandSettings?: {\n  /** Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual. */\n    bandOperationMode?: \"2.4ghz\" | \"5ghz\" | \"dual\",\n  /** Steers client to most open band. Can be either true or false. Defaults to true. */\n    bandSteeringEnabled?: boolean,\n\n},\n  /** Band selection can be set to either 'ssid' or 'ap'. This param is required on creation. */\n    bandSelectionType: \"ap\" | \"ssid\",\n  /** Steers client to best available access point. Can be either true or false. Defaults to true. */\n    clientBalancingEnabled?: boolean,\n  /** Settings related to 5Ghz band */\n    fiveGhzSettings?: {\n  /** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto. */\n    channelWidth?: string,\n  /** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30. */\n    maxPower?: number,\n  /** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12. */\n    minBitrate?: number,\n  /** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8. */\n    minPower?: number,\n  /** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */\n    rxsop?: number,\n  /** Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165]. */\n    validAutoChannels?: (number)[],\n\n},\n  /** Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band. */\n    minBitrateType?: \"band\" | \"ssid\",\n  /** The name of the new profile. Must be unique. This param is required on creation. */\n    name: string,\n  /** Settings related to 2.4Ghz band */\n    twoFourGhzSettings?: {\n  /** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true. */\n    axEnabled?: boolean,\n  /** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30. */\n    maxPower?: number,\n  /**\n   * Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.\n   * @format float\n   */\n    minBitrate?: number,\n  /** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5. */\n    minPower?: number,\n  /** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */\n    rxsop?: number,\n  /** Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11]. */\n    validAutoChannels?: (number)[],\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/networks/{networkId}/wireless/rfProfiles/{rfProfileId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".rfProfileId": {
        "rendered": " rfProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/networks/{networkId}/wireless/rfProfiles/{rfProfileId}": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".rfProfileId": {
        "rendered": " rfProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/wireless/rfProfiles/{rfProfileId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Settings that will be enabled if selectionType is set to 'ap'. */\n    apBandSettings?: {\n  /** Choice between 'dual', '2.4ghz' or '5ghz'. */\n    bandOperationMode?: \"2.4ghz\" | \"5ghz\" | \"dual\",\n  /** Steers client to most open band. Can be either true or false. */\n    bandSteeringEnabled?: boolean,\n\n},\n  /** Band selection can be set to either 'ssid' or 'ap'. */\n    bandSelectionType?: \"ap\" | \"ssid\",\n  /** Steers client to best available access point. Can be either true or false. */\n    clientBalancingEnabled?: boolean,\n  /** Settings related to 5Ghz band */\n    fiveGhzSettings?: {\n  /** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. */\n    channelWidth?: string,\n  /** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. */\n    maxPower?: number,\n  /** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. */\n    minBitrate?: number,\n  /** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. */\n    minPower?: number,\n  /** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */\n    rxsop?: number,\n  /** Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'. */\n    validAutoChannels?: (number)[],\n\n},\n  /** Minimum bitrate can be set to either 'band' or 'ssid'. */\n    minBitrateType?: \"band\" | \"ssid\",\n  /** The name of the new profile. Must be unique. */\n    name?: string,\n  /** Settings related to 2.4Ghz band */\n    twoFourGhzSettings?: {\n  /** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. */\n    axEnabled?: boolean,\n  /** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */\n    maxPower?: number,\n  /**\n   * Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.\n   * @format float\n   */\n    minBitrate?: number,\n  /** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */\n    minPower?: number,\n  /** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */\n    rxsop?: number,\n  /** Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. */\n    validAutoChannels?: (number)[],\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".rfProfileId": {
        "rendered": " rfProfileId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{networkId}/wireless/settings": {
    "query": {},
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{networkId}/wireless/settings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */\n    \"ipv6BridgeEnabled\"?: boolean,\n  /** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */\n    ledLightsOn?: boolean,\n  /** Toggle for enabling or disabling location analytics for your network */\n    locationAnalyticsEnabled?: boolean,\n  /** Toggle for enabling or disabling meshing in a network */\n    meshingEnabled?: boolean,\n  /** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */\n    upgradeStrategy?: \"minimizeClientDowntime\" | \"minimizeUpgradeTime\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/networks/{network_id}/sm/devices/lock": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ids of the devices to be locked. */\n    ids?: string,\n  /** The pin number for locking macOS devices (a six digit number). Required only for macOS devices. */\n    pin?: number,\n  /** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped. */\n    scope?: string,\n  /** The serials of the devices to be locked. */\n    serials?: string,\n  /** The wifiMacs of the devices to be locked. */\n    wifiMacs?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{network_id}/sm/{id}/connectivity": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".id": {
        "rendered": " id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{network_id}/sm/{id}/desktopLogs": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".id": {
        "rendered": " id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{network_id}/sm/{id}/deviceCommandLogs": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".id": {
        "rendered": " id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/networks/{network_id}/sm/{id}/performanceHistory": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".networkId": {
        "rendered": " networkId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".id": {
        "rendered": " id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/actionBatches": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Filter batches by status. Valid types are pending, completed, and failed. */\n status?: \"completed\" | \"failed\" | \"pending\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.status": {
        "rendered": "\n/** Filter batches by status. Valid types are pending, completed, and failed. */\n status?: \"completed\" | \"failed\" | \"pending\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/actionBatches": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A set of changes to make as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>) */\n    actions: ({\n  /**\n   * The body of the action\n   * @default {}\n   */\n    body?: hasuraSdk.JSONValue,\n  /** The operation to be used */\n    operation: string,\n  /** Unique identifier for the resource to be acted on */\n    resource: string,\n\n})[],\n  /** Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false. */\n    confirmed?: boolean,\n  /** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false. */\n    synchronous?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/organizations/{organizationId}/actionBatches/{actionBatchId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".actionBatchId": {
        "rendered": " actionBatchId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/organizations/{organizationId}/actionBatches/{actionBatchId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true. */\n    confirmed?: boolean,\n  /** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. */\n    synchronous?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".actionBatchId": {
        "rendered": " actionBatchId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/admins": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/admins": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication */\n    authenticationMethod?: \"Cisco SecureX Sign-On\" | \"Email\",\n  /** The email of the dashboard administrator. This attribute can not be updated. */\n    email: string,\n  /** The name of the dashboard administrator */\n    name: string,\n  /** The list of networks that the dashboard administrator has privileges on */\n    networks?: ({\n  /** The privilege of the dashboard administrator on the network */\n    access: string,\n  /** The network ID */\n    id: string,\n\n})[],\n  /** The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none' */\n    orgAccess: \"enterprise\" | \"full\" | \"none\" | \"read-only\",\n  /** The list of tags that the dashboard administrator has privileges on */\n    tags?: ({\n  /** The privilege of the dashboard administrator on the tag */\n    access: string,\n  /** The name of the tag */\n    tag: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/organizations/{organizationId}/admins/{adminId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".adminId": {
        "rendered": " adminId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/organizations/{organizationId}/admins/{adminId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of the dashboard administrator */\n    name?: string,\n  /** The list of networks that the dashboard administrator has privileges on */\n    networks?: ({\n  /** The privilege of the dashboard administrator on the network */\n    access: string,\n  /** The network ID */\n    id: string,\n\n})[],\n  /** The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none' */\n    orgAccess?: \"enterprise\" | \"full\" | \"none\" | \"read-only\",\n  /** The list of tags that the dashboard administrator has privileges on */\n    tags?: ({\n  /** The privilege of the dashboard administrator on the tag */\n    access: string,\n  /** The name of the tag */\n    tag: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".adminId": {
        "rendered": " adminId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/apiRequests": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, \n/** Filter the results by the ID of the admin who made the API requests */\n adminId?: string, \n/** Filter the results by the path of the API requests */\n path?: string, \n/** Filter the results by the method of the API requests (must be 'GET', 'PUT', 'POST' or 'DELETE') */\n method?: string, \n/** Filter the results by the response code of the API requests */\n responseCode?: number, \n/** Filter the results by the IP address of the originating API request */\n sourceIp?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.adminId": {
        "rendered": "\n/** Filter the results by the ID of the admin who made the API requests */\n adminId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.path": {
        "rendered": "\n/** Filter the results by the path of the API requests */\n path?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.method": {
        "rendered": "\n/** Filter the results by the method of the API requests (must be 'GET', 'PUT', 'POST' or 'DELETE') */\n method?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.responseCode": {
        "rendered": "\n/** Filter the results by the response code of the API requests */\n responseCode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sourceIp": {
        "rendered": "\n/** Filter the results by the IP address of the originating API request */\n sourceIp?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/apiRequests/overview": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. */\n timespan?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 31 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 31 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/claim": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The licenses that should be claimed */\n    licenses?: ({\n  /** The key of the license */\n    key: string,\n  /** Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled. */\n    mode?: \"addDevices\" | \"renew\",\n\n})[],\n  /** The numbers of the orders that should be claimed */\n    orders?: (string)[],\n  /** The serials of the devices that should be claimed */\n    serials?: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/clone": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The name of the new organization */\n    name: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/configTemplates": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/organizations/{organizationId}/configTemplates/{configTemplateId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".configTemplateId": {
        "rendered": " configTemplateId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/organizations/{organizationId}/configTemplates/{configTemplateId}/switchProfiles": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".configTemplateId": {
        "rendered": " configTemplateId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/configurationChanges": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, \n/** Filters on the given network */\n networkId?: string, \n/** Filters on the given Admin */\n adminId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 365 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.networkId": {
        "rendered": "\n/** Filters on the given network */\n networkId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.adminId": {
        "rendered": "\n/** Filters on the given Admin */\n adminId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/deviceStatuses": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, \n/** Filter results by whether or not the device's configuration has been updated after the given timestamp */\n configurationUpdatedAfter?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.configurationUpdatedAfter": {
        "rendered": "\n/** Filter results by whether or not the device's configuration has been updated after the given timestamp */\n configurationUpdatedAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/insight/monitoredMediaServers": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/insight/monitoredMediaServers": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The IP address (IPv4 only) or hostname of the media server to monitor */\n    address: string,\n  /** The name of the VoIP provider */\n    name: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".monitoredMediaServerId": {
        "rendered": " monitoredMediaServerId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".monitoredMediaServerId": {
        "rendered": " monitoredMediaServerId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The IP address (IPv4 only) or hostname of the media server to monitor */\n    address?: string,\n  /** The name of the VoIP provider */\n    name?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".monitoredMediaServerId": {
        "rendered": " monitoredMediaServerId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/inventory": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** When this parameter is true, each entity in the response will include the license expiration date of the device (if any). Only applies to organizations that are on the per-device licensing model. Defaults to false. */\n includeLicenseInfo?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.includeLicenseInfo": {
        "rendered": "\n/** When this parameter is true, each entity in the response will include the license expiration date of the device (if any). Only applies to organizations that are on the per-device licensing model. Defaults to false. */\n includeLicenseInfo?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/licenseState": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/licenses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, \n/** Filter the licenses to those assigned to a particular device */\n deviceSerial?: string, \n/** Filter the licenses to those assigned in a particular network */\n networkId?: string, \n/** Filter the licenses to those in a particular state. Can be one of 'active', 'expired', 'expiring', 'recentlyQueued', 'unused' or 'unusedActive' */\n state?: \"active\" | \"expired\" | \"expiring\" | \"recentlyQueued\" | \"unused\" | \"unusedActive\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deviceSerial": {
        "rendered": "\n/** Filter the licenses to those assigned to a particular device */\n deviceSerial?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.networkId": {
        "rendered": "\n/** Filter the licenses to those assigned in a particular network */\n networkId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.state": {
        "rendered": "\n/** Filter the licenses to those in a particular state. Can be one of 'active', 'expired', 'expiring', 'recentlyQueued', 'unused' or 'unusedActive' */\n state?: \"active\" | \"expired\" | \"expiring\" | \"recentlyQueued\" | \"unused\" | \"unusedActive\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/licenses/assignSeats": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ID of the SM license to assign seats from */\n    licenseId: string,\n  /** The ID of the SM network to assign the seats to */\n    networkId: string,\n  /** The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license */\n    seatCount: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/licenses/moveSeats": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ID of the organization to move the SM seats to */\n    destOrganizationId: string,\n  /** The ID of the SM license to move the seats from */\n    licenseId: string,\n  /** The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license */\n    seatCount: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/licenses/renewSeats": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ID of the SM license to renew. This license must already be assigned to an SM network */\n    licenseIdToRenew: string,\n  /** The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew' */\n    unusedLicenseId: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/licenses/{licenseId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".licenseId": {
        "rendered": " licenseId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/networks": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** An optional parameter that is the ID of a config template. Will return all networks bound to that template. */\n configTemplateId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.configTemplateId": {
        "rendered": "\n/** An optional parameter that is the ID of a config template. Will return all networks bound to that template. */\n configTemplateId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/networks": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly. */\n    copyFromNetworkId?: string,\n  /** Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */\n    disableMyMerakiCom?: boolean,\n  /** Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false */\n    disableRemoteStatusPage?: boolean,\n  /** The name of the new network */\n    name: string,\n  /** A space-separated list of tags to be applied to the network */\n    tags?: string,\n  /** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */\n    timeZone?: string,\n  /** The type of the new network. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, environmental, or a space-separated list of those for a combined network. */\n    type: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/networks/combine": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted. */\n    enrollmentString?: string,\n  /** The name of the combined network */\n    name: string,\n  /** A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network */\n    networkIds: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/openapiSpec": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/samlRoles": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/organizations/{organizationId}/samlRoles": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The list of networks that the SAML administrator has privileges on */\n    networks?: ({\n  /** The privilege of the SAML administrator on the network */\n    access: string,\n  /** The network ID */\n    id: string,\n\n})[],\n  /** The privilege of the SAML administrator on the organization */\n    orgAccess: string,\n  /** The role of the SAML administrator */\n    role: string,\n  /** The list of tags that the SAML administrator has privleges on */\n    tags?: ({\n  /** The privilege of the SAML administrator on the tag */\n    access: string,\n  /** The name of the tag */\n    tag: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/samlRoles/{samlRoleId}": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".samlRoleId": {
        "rendered": " samlRoleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/organizations/{organizationId}/samlRoles/{samlRoleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The list of networks that the SAML administrator has privileges on */\n    networks?: ({\n  /** The privilege of the SAML administrator on the network */\n    access: string,\n  /** The network ID */\n    id: string,\n\n})[],\n  /** The privilege of the SAML administrator on the organization */\n    orgAccess?: string,\n  /** The role of the SAML administrator */\n    role?: string,\n  /** The list of tags that the SAML administrator has privleges on */\n    tags?: ({\n  /** The privilege of the SAML administrator on the tag */\n    access: string,\n  /** The name of the tag */\n    tag: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".samlRoleId": {
        "rendered": " samlRoleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/security/intrusionSettings": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/organizations/{organizationId}/security/intrusionSettings": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Sets a list of specific SNORT signatures to allow */\n    whitelistedRules: ({\n  /** Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET */\n    message?: string,\n  /** A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents */\n    ruleId: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/securityEvents": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. */\n timespan?: number, \n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. */\n perPage?: number, \n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string, \n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 365 days after t0. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.perPage": {
        "rendered": "\n/** The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. */\n perPage?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startingAfter": {
        "rendered": "\n/** A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n startingAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endingBefore": {
        "rendered": "\n/** A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. */\n endingBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/snmp": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/thirdPartyVPNPeers": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/organizations/{organizationId}/thirdPartyVPNPeers": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The list of VPN peers */\n    peers: ({\n  /**\n   * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.\n   * @default \"1\"\n   */\n    ikeVersion?: \"1\" | \"2\",\n  /** Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used. */\n    ipsecPolicies?: {\n  /** This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */\n    childAuthAlgo?: (string)[],\n  /** This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null' */\n    childCipherAlgo?: (string)[],\n  /** The lifetime of the Phase 2 SA in seconds. */\n    childLifetime?: number,\n  /** This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1' */\n    childPfsGroup?: (string)[],\n  /** This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */\n    ikeAuthAlgo?: (string)[],\n  /** This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des' */\n    ikeCipherAlgo?: (string)[],\n  /** This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1' */\n    ikeDiffieHellmanGroup?: (string)[],\n  /** The lifetime of the Phase 1 SA in seconds. */\n    ikeLifetime?: number,\n  /** [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm. */\n    ikePrfAlgo?: (\"default\" | \"prfmd5\" | \"prfsha1\" | \"prfsha256\")[],\n\n},\n  /** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */\n    ipsecPoliciesPreset?: string,\n  /** The name of the VPN peer */\n    name: string,\n  /** A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all']. */\n    networkTags?: (string)[],\n  /** The list of the private subnets of the VPN peer */\n    privateSubnets: (string)[],\n  /** The public IP of the VPN peer */\n    publicIp: string,\n  /** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */\n    remoteId?: string,\n  /** The shared secret with the VPN peer */\n    secret: string,\n\n})[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/uplinksLossAndLatency": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The beginning of the timespan for the data. The maximum lookback period is 60 days from today. */\n t0?: string, \n/** The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. */\n t1?: string, \n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. */\n timespan?: number, \n/** Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. */\n uplink?: \"cellular\" | \"wan1\" | \"wan2\", \n/** Optional filter for a specific destination IP. Default will return all destination IPs. */\n ip?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.t0": {
        "rendered": "\n/** The beginning of the timespan for the data. The maximum lookback period is 60 days from today. */\n t0?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.t1": {
        "rendered": "\n/** The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. */\n t1?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timespan": {
        "rendered": "\n/** The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. */\n timespan?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.uplink": {
        "rendered": "\n/** Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. */\n uplink?: \"cellular\" | \"wan1\" | \"wan2\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ip": {
        "rendered": "\n/** Optional filter for a specific destination IP. Default will return all destination IPs. */\n ip?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/organizations/{organizationId}/vpnFirewallRules": {
    "query": {},
    "body": {},
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/organizations/{organizationId}/vpnFirewallRules": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** An ordered array of the firewall rules (not including the default rule) */\n    rules?: ({\n  /** Description of the rule (optional) */\n    comment?: string,\n  /** Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported) */\n    destCidr: string,\n  /** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */\n    destPort?: string,\n  /** 'allow' or 'deny' traffic specified by this rule */\n    policy: \"allow\" | \"deny\",\n  /** The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any') */\n    protocol: \"any\" | \"icmp\" | \"icmp6\" | \"tcp\" | \"udp\",\n  /** Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported) */\n    srcCidr: string,\n  /** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */\n    srcPort?: string,\n  /** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */\n    syslogEnabled?: boolean,\n\n})[],\n  /** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */\n    syslogDefaultRule?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".organizationId": {
        "rendered": " organizationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue)[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  }
}