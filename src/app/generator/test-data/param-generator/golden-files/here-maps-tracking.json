{
  "get__/aliases/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** An alias type */\n type?: string, \n/** Filter for aliases external IDs */\n externalId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.externalId": {
        "rendered": "\n/** Filter for aliases external IDs */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseAllAliases",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/aliases/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/trackingId": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** An alias type */\n type: string, \n/** An external ID. An externalId and type pair uniquely identifies an alias. */\n externalId: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.externalId": {
        "rendered": "\n/** An external ID. An externalId and type pair uniquely identifies an alias. */\n externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Virtual device application ID, only present when the device is virtual\n   * @minLength 8\n   */\n    appId?: string,\n  /**\n   * Virtual device external ID, only present when the device is virtual\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalId?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/aliases/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/aliases/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** An alias type */\n type?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseAliases",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/aliases/v2/{trackingId}/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/aliases/v2/{trackingId}/{type}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/aliases/v2/{trackingId}/{type}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": " type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseAliases",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/aliases/v2/{trackingId}/{type}/{externalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalId": {
        "rendered": "\n/** An external ID. An `externalId` and a `type` pair uniquely identifies an alias. */\n externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/aliases/v2/{trackingId}/{type}/{externalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": " type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalId": {
        "rendered": " externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/associations/v3/devices/batchUpdate": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/associations/v3/devices/{trackingId}/batchCreate": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/associations/v3/devices/{trackingId}/batchDelete": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseDevicesAssociatedWithRule",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseDevicesAssociatedWithRule",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseDevicesAssociatedWithRule",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/{trackingId}/geofences": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type.__no_name": {
        "rendered": "\"circle\" | \"polygon\" | \"poi\"",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 100\n   * @default 100\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ({\n    geofence: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n    trainingStatus: {\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n  /** True if the POI geofence is trained */\n    trained: boolean,\n\n},\n  /** The geofence type. */\n    type: \"poi\",\n\n}),\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n})[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/associations/v3/{trackingId}/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/associations/v3/{trackingId}/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/{trackingId}/rules": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 100\n   * @default 100\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ({\n    rule: ({\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Detention event is triggered when the asset has been continuously stationary for longer\n   * than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"detention\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Dwelling event is triggered when the asset has been continuously inside a geofence\n   * for longer than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"dwelling\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Utilization event is triggered when the asset starts moving\n   * indicating that the asset is utilized, and also when the asset stops\n   * moving and has been stationary for longer than the threshold duration\n   * indicating that the asset is unutilized.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"utilization\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /** The rule type */\n    type: \"online\",\n\n}),\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n\n})[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/associations/v3/{trackingId}/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/associations/v3/{trackingId}/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/associations/v3/{trackingId}/sensors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseSensorRulesByJson",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/associations/v3/{trackingId}/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/associations/v3/{trackingId}/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/bulkjobs/v4/deviceUploads": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",  status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\" | (\"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\")[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.status": {
        "rendered": " status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\" | (\"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\")[],",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * Bulk upload job ID\n   * @pattern ^BULK-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    jobId: string,\n  /** Status of the bulk upload. */\n    status: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",\n  /** Type of bulk job (either `create` or `delete`) */\n    type?: \"create\" | \"delete\",\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/bulkjobs/v4/deviceUploads": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The name of the upload file. */\n fileName?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fileName": {
        "rendered": "\n/** The name of the upload file. */\n fileName?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Bulk upload job ID\n   * @pattern ^BULK-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    jobId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/bulkjobs/v4/deviceUploads/{jobId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Status of the bulk upload. */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/deviceUploads/{jobId}/results": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * Identifier of the connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    connectorId?: string,\n  /**\n   * Device ID of a provisioned device\n   * @minLength 1\n   * @maxLength 50\n   */\n    deviceId?: string,\n  /** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n    deviceSecret?: string,\n    errors?: ({\n  /** Error code */\n    code?: number,\n  /** Error details */\n    details?: string,\n  /** Error description */\n    message?: string,\n\n})[],\n  /**\n   * Identifier of the device on the external cloud.\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalDeviceId?: string,\n  /**\n   * Virtual device external ID, only present when the device is virtual\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalId?: string,\n  /**\n   * The name of the device. Must be unique within a project.\n   * @minLength 1\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /** Status of the bulk upload. */\n    status: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",\n  /** Type of bulk job (either `create` or `delete`) */\n    type?: \"create\" | \"delete\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/deviceUploads/{jobId}/status": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** The number of devices for which all planned upload operations failed. */\n    failed: number,\n  /**\n   * The name of the upload file.\n   * @minLength 1\n   * @maxLength 50\n   */\n    fileName?: string,\n  /** The number of devices for which some upload operations succeeded. */\n    partiallySucceeded: number,\n  /** The number of devices that are still waiting upload operations to be done. */\n    pending: number,\n  /**\n   * The percentage of the job that was completed at the time of the request.\n   * @min 0\n   * @max 100\n   */\n    progress: number,\n  /** Status of the bulk upload. */\n    status: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",\n  /** The number of devices for which all planned upload operations succeeded. */\n    succeeded: number,\n  /** The total number of devices to be uploaded in this job. */\n    total: number,\n  /** Type of bulk job (either `create` or `delete`) */\n    type?: \"create\" | \"delete\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/c2c/v4/callback": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** API Key */\n apiKey: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apiKey": {
        "rendered": "\n/** API Key */\n apiKey: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/connectors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: (({\n  /**\n   * Identifier of the connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    connectorId?: string,\n  /**\n   * Project ID.\n   * Any HERE Tracking user must be a member of a Tracking project.\n   * The project ID can be implicitly resolved if the user calling the API is a member of a single project.\n   * If the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n   * @minLength 1\n   * @maxLength 50\n   */\n    projectId?: string,\n\n} & {\n  /**\n   * Brief description of the connector.\n   * @maxLength 200\n   */\n    description?: string,\n  /**\n   * Identifier of the driver to be used with this connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    driverId: string,\n  /**\n   * Enabled state of the connector. If set to false then the connector\n   * will not execute periodically.\n   */\n    enabled: boolean,\n  /**\n   * An external cloud-specific object that the driver will use to login to the\n   * external cloud. The structure of this object varies per driver\n   * implementation.\n   * It is recommended to have dedicated credentials for logging in to\n   * the external cloud in order not to violate possible concurrent users\n   * policies of the external cloud.\n   * In case of the HERE Tracking loopback driver, the maximum\n   * allowed concurrent user account tokens is 3 per account,\n   * therefore it is recommended to create a separate HERE account\n   * and grant it the required privilege to update the connector's\n   * project, and use that account in externalCloudInfo.\n   */\n    externalCloudInfo: hasuraSdk.JSONValue,\n  /**\n   * Name of the connector.\n   * @minLength 1\n   * @maxLength 100\n   */\n    name: string,\n  /**\n   * This is the interval (in seconds) to execute the sync process\n   * between the connector's external cloud and HERE Tracking project.\n   * The maximum and at the same time default value for callback-type connectors is 900 seconds.\n   * The default value for other type of connectors is 3600 seconds and there is no maximum value set.\n   * @min 60\n   */\n    refreshIntervalS?: number,\n\n} & {\n  /**\n   * Timestamp of the last connection execution.\n   * @maxLength 50\n   */\n    lastExecTs?: string,\n\n} & {\n  /**\n   * Number of external devices added to the connector.\n   * @min 0\n   */\n    totalAddedDevices: number,\n\n} & {\n  /**\n   * Timestamp of the connector creation.\n   * @format date-time\n   */\n    createdAt: string,\n\n}))[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/connectors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "Data",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/connectors/ext-devices/{externalDeviceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".externalDeviceId": {
        "rendered": "\n/** Identifier of the external device */\n externalDeviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    items: ({\n  /**\n   * Identifier of the connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    connectorId: string,\n\n})[],\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Unclaim and unprovision devices */\n deleteDevices?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deleteDevices": {
        "rendered": "\n/** Unclaim and unprovision devices */\n deleteDevices?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/connectors/{connectorId}": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "CompleteConnectorInfo",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/c2c/v4/connectors/{connectorId}": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "Data",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/connectors/{connectorId}/ext-devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /** Indicates if C2C should pull data for this device from external cloud at connector execution time. */\n    enabled: boolean,\n  /**\n   * Identifier of the device on the external cloud.\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalDeviceId: string,\n  /** Other extra information related to the external device or shipment ID. */\n    externalDeviceInfo?: hasuraSdk.JSONValue,\n  /**\n   * Extra information regarding the device's provisioning status at HERE Tracking Cloud.\n   * It also contains an error object if the device failed provisioning.\n   */\n    info?: hasuraSdk.JSONValue,\n  /**\n   * Device id in TC. Either trackingId or shipmentId.\n   * @minLength 1\n   * @maxLength 50\n   */\n    localDeviceId?: string,\n  /**\n   * Current device status from HERE Tracking Cloud's perspective.\n   * \"provisioning\": The device is currently being provisioned at HERE Tracking Cloud. Its data still cannot be mirrored when at this state.\n   * \"provisioned\": The device has been provisioned successfully at HERE Tracking Cloud. Its data can be mirrored when at this state.\n   * \"failed\": The device has failed provisioning at HERE Tracking Cloud. Its data cannot be mirrored when at this state.\n   */\n    provisioning: \"provisioning\" | \"provisioned\" | \"failed\",\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/connectors/{connectorId}/ext-devices": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}/ext-devices-batch": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}/ext-devices/{externalDeviceId}": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalDeviceId": {
        "rendered": "\n/** Identifier of the external device */\n externalDeviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/drivers": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /** If true, it indicates that this one is a self-provisioning callback driver. */\n    autoProvisionCallbackDevices?: boolean,\n  /**\n   * Identifier of the driver.\n   * @minLength 1\n   * @maxLength 50\n   */\n    driverId: string,\n  /** Driver synchronization method */\n    driverSyncMethod: \"push\" | \"pull\" | \"none\",\n  /** Driver type. */\n    driverType: \"tracker-device\" | \"transporter\" | \"internal\",\n    externalCloudInfoSchema: ({\n  /** Indicates whether cloud info parameter is hidden. */\n    hidden?: boolean,\n  /**\n   * Key of external cloud info parameter.\n   * @maxLength 100\n   */\n    key: string,\n  /** Label of external cloud info parameter. */\n    label: string,\n\n})[],\n  /** Name/description of the external cloud that the driver represents. */\n    provider: string,\n    strategy: {\n  /**\n   * Identifier of the manager.\n   * @minLength 1\n   * @maxLength 50\n   */\n    managerId?: string,\n  /** A strategy name */\n    name?: string,\n\n},\n  /** Version number of the driver. */\n    version: number,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/drivers/{driverId}/verify": {
    "query": {},
    "body": {},
    "path": {
      ".driverId": {
        "rendered": "\n/** Identifier of the driver. */\n driverId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/c2c/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/device-associations/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/device-associations/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/device-associations/v2/{trackingId}/geofences": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 100\n   * @default 100\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ({\n    geofence: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n    trainingStatus: {\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n  /** True if the POI geofence is trained */\n    trained: boolean,\n\n},\n  /** The geofence type. */\n    type: \"poi\",\n\n}),\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n})[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/events/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  ruleId?: string | (string)[], \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.initialState": {
        "rendered": "\n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 1000\n   * @default 1000\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ((({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source rule type. */\n    eventSource: \"attach\" | \"tamper\" | \"online\",\n    eventType: \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source rule type. */\n    eventSource: \"battery\" | \"humidity\" | \"pressure\" | \"temperature\",\n    eventType: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: acceleration rule */\n    eventSource: \"acceleration\",\n    eventType: \"EVENT\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: geofence rule */\n    eventSource: \"geofence\",\n    eventType: \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\",\n\n}) | ({\n  /** The event source: stock rule */\n    eventSource: \"stock\",\n  /**\n   * The \"OVERSTOCK\" type - Events are triggered when the number of assets\n   * is over a maximum stock volume.\n   * \n   * The \"UNDERSTOCK\" type - Events are triggered when the number of assets\n   * is under a minimum stock volume.\n   * \n   * The \"NORMAL_VOLUME\" type - Events are triggered when the number of assets\n   * is between the minimum stock volume and the maximum stock volume.\n   */\n    eventType: \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\",\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n\n} & {\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: dwelling rule */\n    eventSource: \"dwelling\",\n    eventType: \"DWELLING_STARTED\" | \"DWELLING_ENDED\",\n  /**\n   * An ID of a geofence that triggered the dwelling event\n   * @format uuid\n   */\n    geofenceId: string,\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: detention rule */\n    eventSource: \"detention\",\n    eventType: \"DETENTION_STARTED\" | \"DETENTION_ENDED\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: utilization rule */\n    eventSource: \"utilization\",\n    eventType: \"UTILIZED\" | \"UNUTILIZED\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n    eventSource: \"shipmentSchedule\",\n    eventType: \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * An ID of the segment where the schedule deviation was detected\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId: string,\n  /** Status of the segment. */\n    segmentStatus: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n\n})))[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/events/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/events/v3/statuses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  trackingId?: string | (string)[],  ruleId?: string | (string)[],  geofenceId?: string | (string)[], \n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trackingId": {
        "rendered": " trackingId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": " geofenceId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipments": {
        "rendered": "\n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "StatusResponseJson",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/events/v3/statuses/deviceCounts": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Define whether the number of devices and shipments in each event state is calculated per rule ID or per rule type.\n */\n groupBy?: \"ruleId\" | \"eventSource\",  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  trackingId?: string | (string)[],  ruleId?: string | (string)[],  geofenceId?: string | (string)[], \n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.groupBy": {
        "rendered": "\n/** Define whether the number of devices and shipments in each event state is calculated per rule ID or per rule type.\n */\n groupBy?: \"ruleId\" | \"eventSource\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trackingId": {
        "rendered": " trackingId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": " geofenceId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipments": {
        "rendered": "\n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "DeviceCountsResponseJson",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/events/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/events/v3/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  ruleId?: string | (string)[], \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.initialState": {
        "rendered": "\n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 1000\n   * @default 1000\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ((({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source rule type. */\n    eventSource: \"attach\" | \"tamper\" | \"online\",\n    eventType: \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source rule type. */\n    eventSource: \"battery\" | \"humidity\" | \"pressure\" | \"temperature\",\n    eventType: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: acceleration rule */\n    eventSource: \"acceleration\",\n    eventType: \"EVENT\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: geofence rule */\n    eventSource: \"geofence\",\n    eventType: \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\",\n\n}) | ({\n  /** The event source: stock rule */\n    eventSource: \"stock\",\n  /**\n   * The \"OVERSTOCK\" type - Events are triggered when the number of assets\n   * is over a maximum stock volume.\n   * \n   * The \"UNDERSTOCK\" type - Events are triggered when the number of assets\n   * is under a minimum stock volume.\n   * \n   * The \"NORMAL_VOLUME\" type - Events are triggered when the number of assets\n   * is between the minimum stock volume and the maximum stock volume.\n   */\n    eventType: \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\",\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n\n} & {\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: dwelling rule */\n    eventSource: \"dwelling\",\n    eventType: \"DWELLING_STARTED\" | \"DWELLING_ENDED\",\n  /**\n   * An ID of a geofence that triggered the dwelling event\n   * @format uuid\n   */\n    geofenceId: string,\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: detention rule */\n    eventSource: \"detention\",\n    eventType: \"DETENTION_STARTED\" | \"DETENTION_ENDED\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n  /** The event source: utilization rule */\n    eventSource: \"utilization\",\n    eventType: \"UTILIZED\" | \"UNUTILIZED\",\n\n}) | ({\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n} & {\n    eventSource: \"shipmentSchedule\",\n    eventType: \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * An ID of the segment where the schedule deviation was detected\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId: string,\n  /** Status of the segment. */\n    segmentStatus: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n\n})))[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/geofence-associations/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofence-associations/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/geofence-associations/v2/{geofenceId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseDevicesAssociatedWithRule",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/geofence-associations/v2/{geofenceId}/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/geofence-associations/v2/{geofenceId}/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** The floor of the indoor geofence */\n floor?: | { \n/** ID of the venue, which is associated with the geofence */\n id?: string, } | \"null\", \n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[], \n/** Limit search to geofences intersecting the given bounding box. */\n bbox?: (number)[], \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.floor": {
        "rendered": "\n/** The floor of the indoor geofence */\n floor?: | { \n/** ID of the venue, which is associated with the geofence */\n id?: string, } | \"null\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type.__no_name": {
        "rendered": "\"circle\" | \"polygon\" | \"poi\"",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox": {
        "rendered": "\n/** Limit search to geofences intersecting the given bounding box. */\n bbox?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "({\n  /**\n   * The number of items in the response.\n   * @min 0\n   * @max 100\n   * @default 100\n   */\n    count?: number,\n  /** A token that can be used to retrieve the next page of the response. */\n    pageToken?: string,\n\n} & {\n    data?: ({\n    geofence: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n    trainingStatus: {\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n  /** True if the POI geofence is trained */\n    trained: boolean,\n\n},\n  /** The geofence type. */\n    type: \"poi\",\n\n}),\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n})[],\n\n})",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/geofences/v2/trainingTest": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n    reason?: string,\n    success: boolean,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/geofences/v2/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/geofences/v2/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    geofence: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n    trainingStatus: {\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n  /** True if the POI geofence is trained */\n    trained: boolean,\n\n},\n  /** The geofence type. */\n    type: \"poi\",\n\n}),\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/geofences/v2/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    geofence: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"poi\",\n\n}),\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/geofences/v2/{geofenceId}/poiTraining": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    trainingStatus: {\n    metadata?: {\n  /** Training data position */\n    coordinate?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Training data timestamp\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** The number of WLAN access point used in training */\n    usedWlanApCount: number,\n\n},\n  /** True if the POI geofence is trained */\n    trained: boolean,\n\n},\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/labels/v4/{resourceType}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A filter containing label key-value pairs. */\n labels?: object, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.labels": {
        "rendered": "\n/** A filter containing label key-value pairs. */\n labels?: object,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /** An object containing label key-value pairs. */\n    labels?: hasuraSdk.JSONValue,\n  /**\n   * The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n   * @minLength 1\n   * @maxLength 50\n   */\n    resourceId: string,\n  /** The resource type, for example \"device\", \"geofence\". */\n    resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}/keys": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    keys: (string)[],\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}/keys/{key}/values": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    values: (string)[],\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/labels/v4/{resourceType}/{resourceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": " resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": " resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** An object containing label key-value pairs. */\n    labels?: hasuraSdk.JSONValue,\n  /**\n   * The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n   * @minLength 1\n   * @maxLength 50\n   */\n    resourceId: string,\n  /** The resource type, for example \"device\", \"geofence\". */\n    resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/labels/v4/{resourceType}/{resourceId}/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** An object containing label key-value pairs. */\n    labels?: hasuraSdk.JSONValue,\n  /**\n   * The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n   * @minLength 1\n   * @maxLength 50\n   */\n    resourceId: string,\n  /** The resource type, for example \"device\", \"geofence\". */\n    resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}/{key}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}/{key}/{value}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".value": {
        "rendered": "\n/** The label value. */\n value: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "put__/labels/v4/{resourceType}/{resourceId}/{key}/{value}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": " resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".resourceId": {
        "rendered": " resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": " key: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".value": {
        "rendered": " value: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** An object containing label key-value pairs. */\n    labels?: hasuraSdk.JSONValue,\n  /**\n   * The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n   * @minLength 1\n   * @maxLength 50\n   */\n    resourceId: string,\n  /** The resource type, for example \"device\", \"geofence\". */\n    resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/largedata/v4": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Large data object identifier\n   * @pattern ^DATA-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    dataId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/devices/{trackingId}/metadata": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * Time when data upload was completed\n   * @format date-time\n   */\n    completedAt?: string,\n  /**\n   * Time when data upload was created\n   * @format date-time\n   */\n    createdAt: string,\n  /**\n   * Large data object identifier\n   * @pattern ^DATA-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    dataId: string,\n  /**\n   * Large data object description\n   * @minLength 1\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Large data object name\n   * @minLength 1\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Number of parts\n   * @minLength 1\n   * @maxLength 10000\n   */\n    numberOfParts: number,\n  /**\n   * Total size of the data in bytes\n   * @min 0\n   */\n    size?: number,\n  /** State of the data upload */\n    status: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\",\n  /**\n   * ID of the device that produced this data\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/largedata/v4/{dataId}": {
    "query": {},
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/largedata/v4/{dataId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Flag telling if the data upload should be aborted */\n abort?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.abort": {
        "rendered": "\n/** Flag telling if the data upload should be aborted */\n abort?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/largedata/v4/{dataId}/data": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Byte offset to the data to be downloaded (inclusive, starts at zero) */\n offset?: number, \n/** Number of bytes of the data to download */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.offset": {
        "rendered": "\n/** Byte offset to the data to be downloaded (inclusive, starts at zero) */\n offset?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** Number of bytes of the data to download */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "File",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/largedata/v4/{dataId}/metadata": {
    "query": {},
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Time when data upload was completed\n   * @format date-time\n   */\n    completedAt?: string,\n  /**\n   * Time when data upload was created\n   * @format date-time\n   */\n    createdAt: string,\n  /**\n   * Large data object identifier\n   * @pattern ^DATA-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    dataId: string,\n  /**\n   * Large data object description\n   * @minLength 1\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Large data object name\n   * @minLength 1\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Number of parts\n   * @minLength 1\n   * @maxLength 10000\n   */\n    numberOfParts: number,\n  /**\n   * Total size of the data in bytes\n   * @min 0\n   */\n    size?: number,\n  /** State of the data upload */\n    status: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\",\n  /**\n   * ID of the device that produced this data\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/{dataId}/parts": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * MD5 digest of the data (hexadecimal representation)\n   * @minLength 32\n   * @maxLength 32\n   */\n    \"md5\"?: string,\n  /**\n   * Part number for a large data object\n   * @min 1\n   * @max 10000\n   */\n    partNumber?: number,\n  /**\n   * Part size in bytes\n   * @min 0\n   */\n    size?: number,\n  /** State of the data part upload */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\",\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/largedata/v4/{dataId}/parts/{partNumber}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.md5": {
        "rendered": "\n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".partNumber": {
        "rendered": "\n/** Part number for a large data object */\n partNumber: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The number of items to return per page */\n limit?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Filter locations by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Filter locations by street address. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n street?: string, \n/** Filter locations by city. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n city?: string, \n/** Filter locations by postal code. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n postalCode?: string, \n/** Filter locations by state. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n state?: string, \n/** Filter locations by country. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n country?: string, \n/** Filter locations by locationId wildcard.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n locationId?: string, \n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'steet:desc' sort by street in descending order.\nAllowed fields to sort by:\nlocationId, name, street, city, postalCode, state, country.\n */\n sort?: string | (string)[], \n/** External location id in external cloud */\n externalLocationId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter locations by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.street": {
        "rendered": "\n/** Filter locations by street address. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n street?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.city": {
        "rendered": "\n/** Filter locations by city. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n city?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.postalCode": {
        "rendered": "\n/** Filter locations by postal code. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n postalCode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.state": {
        "rendered": "\n/** Filter locations by state. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n state?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.country": {
        "rendered": "\n/** Filter locations by country. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n country?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.locationId": {
        "rendered": "\n/** Filter locations by locationId wildcard.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'steet:desc' sort by street in descending order.\nAllowed fields to sort by:\nlocationId, name, street, city, postalCode, state, country.\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.externalLocationId": {
        "rendered": "\n/** External location id in external cloud */\n externalLocationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /** Location address. */\n    address?: {\n  /**\n   * City\n   * @maxLength 100\n   */\n    city?: string,\n  /**\n   * Country\n   * @maxLength 100\n   */\n    country?: string,\n  /**\n   * Postal code\n   * @maxLength 10\n   */\n    postalCode?: string,\n  /**\n   * State\n   * @maxLength 100\n   */\n    state?: string,\n  /**\n   * Street address\n   * @maxLength 100\n   */\n    street?: string,\n\n},\n  /**\n   * Description of the location.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * External location id in external cloud\n   * @minLength 1\n   * @maxLength 100\n   */\n    externalLocationId?: string,\n  /**\n   * Optional geofenceId associated with the location. Has to match an existing geofenceId.\n   * @format uuid\n   */\n    geofenceId?: string,\n  /** Location coordinates. */\n    location?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Location ID\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    locationId: string,\n  /**\n   * Name of the location.\n   * @maxLength 50\n   */\n    name?: string,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /** Total number of locations for query */\n    total?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Location ID\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    locationId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/locations/v4/{locationId}": {
    "query": {},
    "body": {},
    "path": {
      ".locationId": {
        "rendered": "\n/** Location ID */\n locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/locations/v4/{locationId}": {
    "query": {},
    "body": {},
    "path": {
      ".locationId": {
        "rendered": " locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Location address. */\n    address?: {\n  /**\n   * City\n   * @maxLength 100\n   */\n    city?: string,\n  /**\n   * Country\n   * @maxLength 100\n   */\n    country?: string,\n  /**\n   * Postal code\n   * @maxLength 10\n   */\n    postalCode?: string,\n  /**\n   * State\n   * @maxLength 100\n   */\n    state?: string,\n  /**\n   * Street address\n   * @maxLength 100\n   */\n    street?: string,\n\n},\n  /**\n   * Description of the location.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * External location id in external cloud\n   * @minLength 1\n   * @maxLength 100\n   */\n    externalLocationId?: string,\n  /**\n   * Optional geofenceId associated with the location. Has to match an existing geofenceId.\n   * @format uuid\n   */\n    geofenceId?: string,\n  /** Location coordinates. */\n    location?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Location ID\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    locationId: string,\n  /**\n   * Name of the location.\n   * @maxLength 50\n   */\n    name?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/locations/v4/{locationId}": {
    "query": {},
    "body": {},
    "path": {
      ".locationId": {
        "rendered": " locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Location address. */\n    address?: {\n  /**\n   * City\n   * @maxLength 100\n   */\n    city?: string,\n  /**\n   * Country\n   * @maxLength 100\n   */\n    country?: string,\n  /**\n   * Postal code\n   * @maxLength 10\n   */\n    postalCode?: string,\n  /**\n   * State\n   * @maxLength 100\n   */\n    state?: string,\n  /**\n   * Street address\n   * @maxLength 100\n   */\n    street?: string,\n\n},\n  /**\n   * Description of the location.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * External location id in external cloud\n   * @minLength 1\n   * @maxLength 100\n   */\n    externalLocationId?: string,\n  /**\n   * Optional geofenceId associated with the location. Has to match an existing geofenceId.\n   * @format uuid\n   */\n    geofenceId?: string,\n  /** Location coordinates. */\n    location?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * Location ID\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    locationId: string,\n  /**\n   * Name of the location.\n   * @maxLength 50\n   */\n    name?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/devices/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseGetMetadataBatchDevices",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/geofences/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseGetMetadataBatchGeofences",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/sensorRules/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseGetMetadataBatchSensorRules",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * Sensor rule ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Metadata JSON object\n   * @example {\"priority\":\"high\"}\n   */\n    data: hasuraSdk.JSONValue,\n  /**\n   * Sensor rule ID\n   * @format uuid\n   */\n    id: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/notifications/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {},
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {},
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    registration?: ({\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"webhook\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /** A URL for webhook notifications capable of receiving POST requests. */\n    url: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"email\",\n  /**\n   * emailBounce property is set `true` if emails to the user's email address bounce. For those\n   * emails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\n   * to be deleted and created again after the email has been changed in HERE Account.\n   */\n    emailBounce?: boolean,\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"browserPull\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n}),\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {},
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    registration?: ({\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"webhook\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /** A URL for webhook notifications capable of receiving POST requests. */\n    url: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"email\",\n  /**\n   * emailBounce property is set `true` if emails to the user's email address bounce. For those\n   * emails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\n   * to be deleted and created again after the email has been changed in HERE Account.\n   */\n    emailBounce?: boolean,\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"browserPull\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n}),\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Filter result by channelType.\n\nExample: `channelType[]=webhook`, `channelType[]=browserPull,email`\n */\n channelType?: (\"webhook\" | \"email\" | \"browserPull\")[], \n/** The HERE Account ID of a user. */\n userId?: string, \n/** Filters by `emailBounce` property. When set to `true`, returns the email channels which are not active anymore\ndue to email bounce. When set to `false`, returns all the channels which are active (and not only email channels).\n */\n emailBounce?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channelType": {
        "rendered": "\n/** Filter result by channelType.\n\nExample: `channelType[]=webhook`, `channelType[]=browserPull,email`\n */\n channelType?: (\"webhook\" | \"email\" | \"browserPull\")[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channelType.__no_name": {
        "rendered": "\"webhook\" | \"email\" | \"browserPull\"",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.emailBounce": {
        "rendered": "\n/** Filters by `emailBounce` property. When set to `true`, returns the email channels which are not active anymore\ndue to email bounce. When set to `false`, returns all the channels which are active (and not only email channels).\n */\n emailBounce?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseRegistrationsV3",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The HERE Account ID of a user. */\n userId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n    registration?: ({\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"webhook\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /** A URL for webhook notifications capable of receiving POST requests. */\n    url: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"email\",\n  /**\n   * emailBounce property is set `true` if emails to the user's email address bounce. For those\n   * emails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\n   * to be deleted and created again after the email has been changed in HERE Account.\n   */\n    emailBounce?: boolean,\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n} | {\n  /**\n   * channel ID\n   * @format uuid\n   */\n    channelId: string,\n    channelType: \"browserPull\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /**\n   * User Id.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId: string,\n\n}),\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/notifications/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/licenses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Start of returned block from a list. Default 0. */\n startIndex?: number, \n/** End of returned block from a list. Default 100. */\n endIndex?: number,  projectIds?: string | (string)[],  projectTypes?: \"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\" | (\"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\")[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startIndex": {
        "rendered": "\n/** Start of returned block from a list. Default 0. */\n startIndex?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endIndex": {
        "rendered": "\n/** End of returned block from a list. Default 100. */\n endIndex?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectIds": {
        "rendered": " projectIds?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectTypes": {
        "rendered": " projectTypes?: \"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\" | (\"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\")[],",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * End of returned block from a list. Default 100.\n   * @min 0\n   * @default 100\n   */\n    end: number,\n  /** Developer plan licenses for HERE Tracking */\n    licenses: ({\n  /**\n   * A project application id.\n   * @minLength 8\n   */\n    appId?: string,\n  /** True if a license has expired. */\n    expired?: boolean,\n  /** A license expiration date. */\n    expiryDate?: string,\n  /** Features supported by the license plan. */\n    features?: (string)[],\n  /**\n   * Project description\n   * @minLength 1\n   * @maxLength 250\n   */\n    projectDescription?: string,\n  /**\n   * Project HRN\n   * @pattern ^hrn:here.*$\n   */\n    projectHrn?: string,\n  /**\n   * Project ID.\n   * Any HERE Tracking user must be a member of a Tracking project.\n   * The project ID can be implicitly resolved if the user calling the API is a member of a single project.\n   * If the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n   * @minLength 1\n   * @maxLength 50\n   */\n    projectId?: string,\n  /**\n   * Project name\n   * @minLength 1\n   * @maxLength 50\n   */\n    projectName?: string,\n    quota?: {\n  /** The number of devices that can still be provisioned. */\n    provisioning?: number,\n\n},\n  /** Platform application realm. */\n    realm?: string,\n  /** A license type. */\n    type?: \"evaluation\" | \"commercial\" | \"platformApp\" | \"platform\",\n\n})[],\n  /**\n   * Start of returned block from a list. Default 0.\n   * @min 0\n   * @default 0\n   */\n    start: number,\n  /**\n   * Total number of elements that can be received with current query.\n   * @min 0\n   * @default 0\n   */\n    total: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/registry/v2/{appId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ProvisionedDevicesResults",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/registry/v2/{appId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, the licenses are created and devices are immediately claimed by the same user. Supported only with `deviceId` array in body, and not with the `count` parameter. */\n autoclaim?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.autoclaim": {
        "rendered": "\n/** If set to `true`, the licenses are created and devices are immediately claimed by the same user. Supported only with `deviceId` array in body, and not with the `count` parameter. */\n autoclaim?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * The batch job ID, needed for subsequent requests. Valid for 24 hours.\n   * @format uuid\n   */\n    jobId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{appId}/licenseCount": {
    "query": {},
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * The number of created device licenses for given `appId`\n   * @min 0\n   */\n    count: number,\n  /** Timestamp of the last `count` update */\n    updatedAt: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/registry/v2/{appId}/one-device": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, the device license is created and the device is immediately claimed by the same user. */\n autoclaim?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.autoclaim": {
        "rendered": "\n/** If set to `true`, the device license is created and the device is immediately claimed by the same user. */\n autoclaim?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** A newly created device ID. */\n    deviceId: string,\n  /** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n    deviceSecret?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{jobId}/results": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** An asynchronous job ID. UUID v.4.0. */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseJobResults",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/registry/v2/{jobId}/status": {
    "query": {},
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** An asynchronous job ID. UUID v.4.0. */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * The percentage of the job that was completed at the time of the request.\n   * @min 0\n   * @max 100\n   */\n    percent: number,\n  /** The status of the batch job. When the job status is `complete`, use the `/registry/v2/{jobId}/results` endpoint to get the device licenses */\n    status: \"started\" | \"complete\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/registry/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/registry/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Device ID of a provisioned device\n   * @minLength 1\n   * @maxLength 50\n   */\n    deviceId?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/registry/v4/resources/{resourceType}/find": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** number of items returned in the response */\n    count: number,\n  /** Array of matching resource ids */\n    items: ({\n    resourceId: string,\n\n})[],\n  /** number of items as specified in request */\n    limit: number,\n  /** token to fetch the next page */\n    nextPageToken?: string,\n  /** total number of items at the moment when the first page was requested */\n    total: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/reports/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Report ID\n   * @minLength 1\n   * @maxLength 50\n   * @pattern ^REP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    reportId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/reports/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/reports/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/reports/v4/{reportId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Defines the report metric to be calculated. \nThe metrics are always calculated over a time period, either over each interval specified \nby the `interval` parameter (for example, over a week) or over the whole time period of the report.\n\n* `duration`: duration of the event\n  * _\"The asset dwelled for 45 hours during week 2. It was in detention for 4 hours.\"_\n* `occurrence`: total number of the event occurrences\n  * _\"During week 3, the asset was in detention 2 times. During the past month it had 7 individual dwelling periods.\"_\n* `day`: the number of days the event lasted\n  * _\"The asset was utilized for 3 days during week 4.\"_\n* `asset`: the number of assets that generated the event\n  * _\"On Monday 5 assets were in detention. On Tuesday 16 assets were in detention.\"_\n */\n measure?: \"duration\" | \"occurrence\" | \"day\" | \"asset\", \n/** Defines an interval, which can be a day, a week or a month, that will be used to group \nthe report results.\n\nWhen the `interval` parameter is provided, the response will be an array of `timestamp`-`value` \npairs where the `timestamp` defines the beginning of the interval and the `value` is the specified \nreport metric's value calculated over the interval time.\n */\n interval?: \"day\" | \"week\" | \"month\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Defines whether the report metrics, such as cumulative or average, \nare calculated per asset or per geofence.\n\nThe parameter can have a value 'geofence' only with reports created for a dwelling rule.\n\nTo get a report on how many times on average assets were in detention during each time interval,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a detention rule\n* `groupBy`: 'asset'\n* `method`: 'average'\n* `measure`: 'occurrence'\n\nTo get a report on how long all assets dwelled inside each geofence during the report period,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'geofence'\n* `measure`: 'duration'\n\nTo get a report on how long each asset dwelled (inside any geofence) during the report period, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'asset'\n* `measure`: 'duration'\n */\n groupBy?: \"asset\" | \"geofence\", \n/** Defines the calculation method. \nThe parameter `method` can only be provided along with `interval`.\n\nThe parameter value can be `percentage` only when `measure` is 'asset'.\n\nFor example, to get a report on percentage of all assets that were in use during each week,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'week'\n* `method`: 'percentage'\n* `measure`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'duration' or 'occurrence',\nthe `groupBy` parameter needs to be provided also. \nFor example, to get a report on how long all assets dwelled in total in the specified geofence during\neach week, create a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `geofenceId`: ID of a geofence\n* `interval`: 'week'\n* `method`: 'cumulative'\n* `measure`: 'duration'\n* `groupBy`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'day',\nthe `groupBy` parameter is automatically set to 'asset'. \nFor example, to get a report on how many days on average assets were in use during each month, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'month'\n* `method`: 'average'\n* `measure`: 'day'\n* `groupBy`: 'asset'\n */\n method?: \"average\" | \"cumulative\" | \"percentage\", \n/** Defines how the items are sorted.\n* If `interval` is provided, the default is `sort`=`timestamp:asc`\n* If `interval` is not provided, the default is `sort`=`value:desc`\n */\n sort?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.measure": {
        "rendered": "\n/** Defines the report metric to be calculated. \nThe metrics are always calculated over a time period, either over each interval specified \nby the `interval` parameter (for example, over a week) or over the whole time period of the report.\n\n* `duration`: duration of the event\n  * _\"The asset dwelled for 45 hours during week 2. It was in detention for 4 hours.\"_\n* `occurrence`: total number of the event occurrences\n  * _\"During week 3, the asset was in detention 2 times. During the past month it had 7 individual dwelling periods.\"_\n* `day`: the number of days the event lasted\n  * _\"The asset was utilized for 3 days during week 4.\"_\n* `asset`: the number of assets that generated the event\n  * _\"On Monday 5 assets were in detention. On Tuesday 16 assets were in detention.\"_\n */\n measure?: \"duration\" | \"occurrence\" | \"day\" | \"asset\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.interval": {
        "rendered": "\n/** Defines an interval, which can be a day, a week or a month, that will be used to group \nthe report results.\n\nWhen the `interval` parameter is provided, the response will be an array of `timestamp`-`value` \npairs where the `timestamp` defines the beginning of the interval and the `value` is the specified \nreport metric's value calculated over the interval time.\n */\n interval?: \"day\" | \"week\" | \"month\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.groupBy": {
        "rendered": "\n/** Defines whether the report metrics, such as cumulative or average, \nare calculated per asset or per geofence.\n\nThe parameter can have a value 'geofence' only with reports created for a dwelling rule.\n\nTo get a report on how many times on average assets were in detention during each time interval,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a detention rule\n* `groupBy`: 'asset'\n* `method`: 'average'\n* `measure`: 'occurrence'\n\nTo get a report on how long all assets dwelled inside each geofence during the report period,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'geofence'\n* `measure`: 'duration'\n\nTo get a report on how long each asset dwelled (inside any geofence) during the report period, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'asset'\n* `measure`: 'duration'\n */\n groupBy?: \"asset\" | \"geofence\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.method": {
        "rendered": "\n/** Defines the calculation method. \nThe parameter `method` can only be provided along with `interval`.\n\nThe parameter value can be `percentage` only when `measure` is 'asset'.\n\nFor example, to get a report on percentage of all assets that were in use during each week,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'week'\n* `method`: 'percentage'\n* `measure`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'duration' or 'occurrence',\nthe `groupBy` parameter needs to be provided also. \nFor example, to get a report on how long all assets dwelled in total in the specified geofence during\neach week, create a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `geofenceId`: ID of a geofence\n* `interval`: 'week'\n* `method`: 'cumulative'\n* `measure`: 'duration'\n* `groupBy`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'day',\nthe `groupBy` parameter is automatically set to 'asset'. \nFor example, to get a report on how many days on average assets were in use during each month, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'month'\n* `method`: 'average'\n* `measure`: 'day'\n* `groupBy`: 'asset'\n */\n method?: \"average\" | \"cumulative\" | \"percentage\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** Defines how the items are sorted.\n* If `interval` is provided, the default is `sort`=`timestamp:asc`\n* If `interval` is not provided, the default is `sort`=`value:desc`\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".reportId": {
        "rendered": "\n/** Report ID */\n reportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: (({\n  /**\n   * Timestamp of the beginning of the interval\n   * @format date-time\n   */\n    timestamp: string,\n  /**\n   * The value of the report metric, which was specified in the `measure` parameter.\n   * \n   * * `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n   * * `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n   * * `measure`: `day` => `value`: the number of days the event lasted over the time frame\n   * * `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n   * \n   * When `value` is provided along with `timestamp`, the time frame is the specified interval.\n   * When `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n   * \n   * Additionally, if `method` parameter was given, the `value` represents\n   * average/cumulative/percentage of the calculated metric.\n   */\n    value: number,\n\n} | {\n  /**\n   * Tracking ID on which the `value` is calculated\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n  /**\n   * The value of the report metric, which was specified in the `measure` parameter.\n   * \n   * * `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n   * * `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n   * * `measure`: `day` => `value`: the number of days the event lasted over the time frame\n   * * `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n   * \n   * When `value` is provided along with `timestamp`, the time frame is the specified interval.\n   * When `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n   * \n   * Additionally, if `method` parameter was given, the `value` represents\n   * average/cumulative/percentage of the calculated metric.\n   */\n    value: number,\n\n} | {\n  /**\n   * Geofence ID on which the `value` is calculated\n   * @format uuid\n   */\n    geofenceId: string,\n  /**\n   * The value of the report metric, which was specified in the `measure` parameter.\n   * \n   * * `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n   * * `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n   * * `measure`: `day` => `value`: the number of days the event lasted over the time frame\n   * * `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n   * \n   * When `value` is provided along with `timestamp`, the time frame is the specified interval.\n   * When `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n   * \n   * Additionally, if `method` parameter was given, the `value` represents\n   * average/cumulative/percentage of the calculated metric.\n   */\n    value: number,\n\n} | {\n  /**\n   * Timestamp of the beginning of the event\n   * @format date-time\n   */\n    timestamp: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n  /** Duration of the event in seconds */\n    value: number,\n\n}))[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /**\n   * Status of the report creation. \n   * When the status is `pending` or `started`, re-check the status later again. \n   * The actual reports can be queried only when the report creation status is 'completed'.\n   */\n    status: \"pending\" | \"started\" | \"completed\" | \"failed\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n    rule: ({\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Utilization event is triggered when the asset starts moving\n   * indicating that the asset is utilized, and also when the asset stops\n   * moving and has been stationary for longer than the threshold duration\n   * indicating that the asset is unutilized.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"utilization\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Detention event is triggered when the asset has been continuously stationary for longer\n   * than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"detention\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Dwelling event is triggered when the asset has been continuously inside a geofence\n   * for longer than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"dwelling\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    geofenceId: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * A maximum volume of stock\n   * @min 0\n   */\n    maxVolume?: number,\n  /**\n   * A minimum volume of stock\n   * @min 0\n   */\n    minVolume?: number,\n\n},\n  /** The rule type */\n    type: \"stock\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /** The rule type */\n    type: \"online\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule\n   * @min 0\n   * @max 2147483647\n   */\n    after?: number,\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule\n   * @min 0\n   * @max 2147483647\n   */\n    before?: number,\n\n},\n  /** The rule type */\n    type: \"shipmentSchedule\",\n\n}),\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/rules/v4/{ruleId}": {
    "query": {},
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/rules/v4/{ruleId}": {
    "query": {},
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    rule: ({\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Utilization event is triggered when the asset starts moving\n   * indicating that the asset is utilized, and also when the asset stops\n   * moving and has been stationary for longer than the threshold duration\n   * indicating that the asset is unutilized.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"utilization\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Detention event is triggered when the asset has been continuously stationary for longer\n   * than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"detention\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Dwelling event is triggered when the asset has been continuously inside a geofence\n   * for longer than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"dwelling\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    geofenceId: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * A maximum volume of stock\n   * @min 0\n   */\n    maxVolume?: number,\n  /**\n   * A minimum volume of stock\n   * @min 0\n   */\n    minVolume?: number,\n\n},\n  /** The rule type */\n    type: \"stock\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /** The rule type */\n    type: \"online\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule\n   * @min 0\n   * @max 2147483647\n   */\n    after?: number,\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule\n   * @min 0\n   * @max 2147483647\n   */\n    before?: number,\n\n},\n  /** The rule type */\n    type: \"shipmentSchedule\",\n\n}),\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/rules/v4/{ruleId}": {
    "query": {},
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    rule: ({\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Utilization event is triggered when the asset starts moving\n   * indicating that the asset is utilized, and also when the asset stops\n   * moving and has been stationary for longer than the threshold duration\n   * indicating that the asset is unutilized.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"utilization\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Detention event is triggered when the asset has been continuously stationary for longer\n   * than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"detention\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Dwelling event is triggered when the asset has been continuously inside a geofence\n   * for longer than the threshold duration.\n   */\n    threshold: {\n  /**\n   * Duration in seconds\n   * @min 0\n   * @max 2147483647\n   */\n    durationS: number,\n\n},\n  /** The rule type */\n    type: \"dwelling\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Geofence ID\n   * @format uuid\n   */\n    geofenceId: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * A maximum volume of stock\n   * @min 0\n   */\n    maxVolume?: number,\n  /**\n   * A minimum volume of stock\n   * @min 0\n   */\n    minVolume?: number,\n\n},\n  /** The rule type */\n    type: \"stock\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n  /** The rule type */\n    type: \"online\",\n\n} | {\n  /**\n   * Rule description\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Rule name\n   * @maxLength 50\n   */\n    name?: string,\n    threshold: {\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule\n   * @min 0\n   * @max 2147483647\n   */\n    after?: number,\n  /**\n   * Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule\n   * @min 0\n   * @max 2147483647\n   */\n    before?: number,\n\n},\n  /** The rule type */\n    type: \"shipmentSchedule\",\n\n}),\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseSensorRulesByJson",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    id: string,\n  /** Set to `created` if the sensor rule creation was successful. */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    description?: string,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    id: string,\n    name?: string,\n    range?: {\n  /** The lower threshold value. */\n    begin: number,\n  /** The upper threshold value. */\n    end: number,\n\n},\n    threshold?: {\n  /** Threshold value */\n    value: number,\n\n},\n  /** The sensor type. */\n    type: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseUpdateRule",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/shadows/v2/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseRetrieveBatch",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** If `true`, all the values of the `desired` shadow will be cleared */\n desired?: boolean, \n/** If `true`, all the values of the `reported` shadow will be cleared */\n reported?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.desired": {
        "rendered": "\n/** If `true`, all the values of the `desired` shadow will be cleared */\n desired?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.reported": {
        "rendered": "\n/** If `true`, all the values of the `reported` shadow will be cleared */\n reported?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** The desired shadow of the device. */\n    desired?: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** Contains device configuration settings. */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @min 2\n   * @max 4102448400000\n   */\n    begin?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @min 2\n   * @max 4102448400000\n   */\n    end?: number,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to geofences that device is associated\n   * with. This value is zero when device hasn't yet been associated with\n   * any geofence. This is set by HERE Tracking when any geofences\n   * associated with the device is modified or removed. Also adding and\n   * removing geofence associations update this value.\n   * @min 0\n   * @max 4102448400000\n   */\n    lastModifiedGeofenceTimestamp: number,\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /** The device sensors alarm configuration. */\n    sensorAlarmConfig?: {\n  /** An upper threshold value for acceleration in g-forces. */\n    alertAccelerationGMax?: number,\n  /** A lower threshold value for acceleration in g-forces. */\n    alertAccelerationGMin?: number,\n  /** An upper threshold value for battery level percentage. */\n    alertBatteryLevelPMax?: number,\n  /** A lower threshold value for battery level percentage. */\n    alertBatteryLevelPMin?: number,\n  /** An upper threshold value for pressure in hectopascals. */\n    alertPressureHpaMax?: number,\n  /** A lower threshold value for pressure in hectopascals. */\n    alertPressureHpaMin?: number,\n  /** An upper threshold value for relative humidity percentage. */\n    alertRelativeHumidityMax?: number,\n  /** A lower threshold value for relative humidity percentage. */\n    alertRelativeHumidityMin?: number,\n  /** An upper threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMax?: number,\n  /** A lower threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMin?: number,\n  /** An upper threshold value for tilt in degrees. */\n    alertTiltDegreeMax?: number,\n  /** A lower threshold value for tilt in degrees. */\n    alertTiltDegreeMin?: number,\n  /**\n   * True if attach sensor alert in device is enabled.\n   * @default false\n   */\n    isAttachAlertEnabled?: boolean,\n  /**\n   * True if tamper sensor alert in device is enabled.\n   * @default false\n   */\n    isTamperAlertEnabled?: boolean,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion: number,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to the desired shadow.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /**\n   * The `reported` shadow contains the most recent position, sensor readings and settings that the\n   * device has sent. The reported shadow may also contain additional properties generated by HERE \n   * Tracking based on the device-ingested telemetry.\n   * Such properties are stored in `system.computed` property of the shadow.\n   * \n   * In case the most recent telemetry did not contain all the possible\n   * fields, the last known information will remain in the shadow. This means that one can\n   * see, for example, the last reported temperature or tracker firmware information in the reported shadow,\n   * even if the device did not send that information in the latest telemetry.\n   */\n    reported?: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /** Values computed by HERE Tracking based on other data available. */\n    computed?: {\n  /**\n   * Timestamp referring to the trace point when the asset was last detected moving.\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   */\n    lastMovedTimestamp?: number,\n  /**\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   */\n    moving?: boolean,\n  /** Online status of the device. Computed based on the device's reporting rate. If the device has not reported within the time frame of the reporting rate plus five minutes, the device is considered to be offline. If the reporting rate is not specified for the device, a default of 15 minutes is used. */\n    online?: boolean,\n  /** Indicates that HERE Tracking detected position to be a possible outlier. */\n    outlier?: {\n  /** HERE Tracking estimate of more correct position. */\n    correctedPosition?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /** Reason why position was considered to be an outlier. */\n    reason: string,\n\n},\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The timestamp of the newest telemetry sent by the device. Note that this is not necessarily\n   * the timestamp of all the reported values in the reported shadow since the shadow retains\n   * values from previous ingestions if the latest telemetry did not conatain them.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** The desired shadow of the device. */\n    desired?: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** Contains device configuration settings. */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @min 2\n   * @max 4102448400000\n   */\n    begin?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @min 2\n   * @max 4102448400000\n   */\n    end?: number,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to geofences that device is associated\n   * with. This value is zero when device hasn't yet been associated with\n   * any geofence. This is set by HERE Tracking when any geofences\n   * associated with the device is modified or removed. Also adding and\n   * removing geofence associations update this value.\n   * @min 0\n   * @max 4102448400000\n   */\n    lastModifiedGeofenceTimestamp: number,\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /** The device sensors alarm configuration. */\n    sensorAlarmConfig?: {\n  /** An upper threshold value for acceleration in g-forces. */\n    alertAccelerationGMax?: number,\n  /** A lower threshold value for acceleration in g-forces. */\n    alertAccelerationGMin?: number,\n  /** An upper threshold value for battery level percentage. */\n    alertBatteryLevelPMax?: number,\n  /** A lower threshold value for battery level percentage. */\n    alertBatteryLevelPMin?: number,\n  /** An upper threshold value for pressure in hectopascals. */\n    alertPressureHpaMax?: number,\n  /** A lower threshold value for pressure in hectopascals. */\n    alertPressureHpaMin?: number,\n  /** An upper threshold value for relative humidity percentage. */\n    alertRelativeHumidityMax?: number,\n  /** A lower threshold value for relative humidity percentage. */\n    alertRelativeHumidityMin?: number,\n  /** An upper threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMax?: number,\n  /** A lower threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMin?: number,\n  /** An upper threshold value for tilt in degrees. */\n    alertTiltDegreeMax?: number,\n  /** A lower threshold value for tilt in degrees. */\n    alertTiltDegreeMin?: number,\n  /**\n   * True if attach sensor alert in device is enabled.\n   * @default false\n   */\n    isAttachAlertEnabled?: boolean,\n  /**\n   * True if tamper sensor alert in device is enabled.\n   * @default false\n   */\n    isTamperAlertEnabled?: boolean,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion: number,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to the desired shadow.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /**\n   * The `reported` shadow contains the most recent position, sensor readings and settings that the\n   * device has sent. The reported shadow may also contain additional properties generated by HERE \n   * Tracking based on the device-ingested telemetry.\n   * Such properties are stored in `system.computed` property of the shadow.\n   * \n   * In case the most recent telemetry did not contain all the possible\n   * fields, the last known information will remain in the shadow. This means that one can\n   * see, for example, the last reported temperature or tracker firmware information in the reported shadow,\n   * even if the device did not send that information in the latest telemetry.\n   */\n    reported?: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /** Values computed by HERE Tracking based on other data available. */\n    computed?: {\n  /**\n   * Timestamp referring to the trace point when the asset was last detected moving.\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   */\n    lastMovedTimestamp?: number,\n  /**\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   */\n    moving?: boolean,\n  /** Online status of the device. Computed based on the device's reporting rate. If the device has not reported within the time frame of the reporting rate plus five minutes, the device is considered to be offline. If the reporting rate is not specified for the device, a default of 15 minutes is used. */\n    online?: boolean,\n  /** Indicates that HERE Tracking detected position to be a possible outlier. */\n    outlier?: {\n  /** HERE Tracking estimate of more correct position. */\n    correctedPosition?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /** Reason why position was considered to be an outlier. */\n    reason: string,\n\n},\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The timestamp of the newest telemetry sent by the device. Note that this is not necessarily\n   * the timestamp of all the reported values in the reported shadow since the shadow retains\n   * values from previous ingestions if the latest telemetry did not conatain them.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/{trackingId}/{state}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".state": {
        "rendered": "\n/** Desired or reported state object of a device to query. */\n state: \"desired\" | \"reported\",",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ShadowStateResponse",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shadows/v2/{trackingId}/{state}/{selector}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".state": {
        "rendered": "\n/** Desired or reported state object of a device to query. */\n state: \"desired\" | \"reported\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".selector": {
        "rendered": "\n/** A JSON selector that specifies the property. */\n selector: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "(hasuraSdk.JSONValue | (any)[])",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shadows/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** If provided returns the shadows for which `reported.timestamp` is greater than given `after` parameter. */\n after?: string, \n/** Defines how the items are sorted.\nThe default sort is `sort=trackingId:asc`\n */\n sort?: string, \n/** Limit search to shadows, whose position intersects the given bounding box.\nThe `bbox` array consist of latitude and longitude of Northwest and Southeast corners.\n */\n bbox?: (number)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** If provided returns the shadows for which `reported.timestamp` is greater than given `after` parameter. */\n after?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** Defines how the items are sorted.\nThe default sort is `sort=trackingId:asc`\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox": {
        "rendered": "\n/** Limit search to shadows, whose position intersects the given bounding box.\nThe `bbox` array consist of latitude and longitude of Northwest and Southeast corners.\n */\n bbox?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 1000\n   */\n    count: number,\n    items: ({\n  /**\n   * Virtual device application ID, only present when the device is virtual\n   * @minLength 8\n   */\n    appId?: string,\n  /**\n   * Virtual device external ID, only present when the device is virtual\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalId?: string,\n    shadow: {\n  /** The desired shadow of the device. */\n    desired: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** Contains device configuration settings. */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @format date-time\n   */\n    begin?: string,\n  /**\n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @format date-time\n   */\n    end?: string,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /**\n   * The time of the last update to geofences that device is associated\n   * with. This value is zero when device hasn't yet been associated with\n   * any geofence. This is set by HERE Tracking when any geofences\n   * associated with the device is modified or removed. Also adding and\n   * removing geofence associations update this value.\n   * @format date-time\n   */\n    lastModifiedGeofenceTimestamp: string,\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /** The device sensors alarm configuration. */\n    sensorAlarmConfig?: {\n  /** An upper threshold value for acceleration in g-forces. */\n    alertAccelerationGMax?: number,\n  /** A lower threshold value for acceleration in g-forces. */\n    alertAccelerationGMin?: number,\n  /** An upper threshold value for battery level percentage. */\n    alertBatteryLevelPMax?: number,\n  /** A lower threshold value for battery level percentage. */\n    alertBatteryLevelPMin?: number,\n  /** An upper threshold value for pressure in hectopascals. */\n    alertPressureHpaMax?: number,\n  /** A lower threshold value for pressure in hectopascals. */\n    alertPressureHpaMin?: number,\n  /** An upper threshold value for relative humidity percentage. */\n    alertRelativeHumidityMax?: number,\n  /** A lower threshold value for relative humidity percentage. */\n    alertRelativeHumidityMin?: number,\n  /** An upper threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMax?: number,\n  /** A lower threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMin?: number,\n  /** An upper threshold value for tilt in degrees. */\n    alertTiltDegreeMax?: number,\n  /** A lower threshold value for tilt in degrees. */\n    alertTiltDegreeMin?: number,\n  /**\n   * True if attach sensor alert in device is enabled.\n   * @default false\n   */\n    isAttachAlertEnabled?: boolean,\n  /**\n   * True if tamper sensor alert in device is enabled.\n   * @default false\n   */\n    isTamperAlertEnabled?: boolean,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion: number,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n  /**\n   * The time of the last update to the desired shadow.\n   * @format date-time\n   */\n    timestamp?: string,\n\n},\n  /**\n   * The `reported` shadow contains the most recent position, sensor readings and settings that the\n   * device has sent. The reported shadow may also contain additional properties generated by HERE \n   * Tracking based on the device-ingested telemetry.\n   * Such properties are stored in `system.computed` property of the shadow.\n   * \n   * In case the most recent telemetry did not contain all the possible\n   * fields, the last known information will remain in the shadow. This means that one can\n   * see, for example, the last reported temperature or tracker firmware information in the reported shadow,\n   * even if the device did not send that information in the latest telemetry.\n   */\n    reported: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @format date-time\n   */\n    timestamp?: string,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /** Values computed by HERE Tracking based on other data available. */\n    computed?: {\n  /**\n   * Timestamp referring to the trace point when the asset was last detected moving.\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   * @format date-time\n   */\n    lastMovedTimestamp?: string,\n  /**\n   * Asset is considered moving if the positions of two consecutive trace points differ more\n   * than the combined positioning accuracy + 100 meters.\n   */\n    moving?: boolean,\n  /** Online status of the device. Computed based on the device's reporting rate. If the device has not reported within the time frame of the reporting rate plus five minutes, the device is considered to be offline. If the reporting rate is not specified for the device, a default of 15 minutes is used. */\n    online?: boolean,\n  /** Indicates that HERE Tracking detected position to be a possible outlier. */\n    outlier?: {\n  /** HERE Tracking estimate of more correct position. */\n    correctedPosition?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Timestamp for the corrected position\n   * @format date-time\n   */\n    timestamp?: string,\n\n},\n  /** Reason why position was considered to be an outlier. */\n    reason: string,\n\n},\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * This describes when the reported measurements were taken.\n   * @format date-time\n   */\n    timestamp?: string,\n\n},\n\n},\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 1000\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipment-reports/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Shipment report ID\n   * @pattern ^SHPR-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentReportId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/status": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n    error?: {\n  /** An HTTP status code */\n    code: number,\n  /** An optional object containing more information about the error */\n    details?: any,\n  /** An HTTP error description */\n    error: string,\n  /**\n   * An error ID that allows you to trace the error details\n   * @format uuid\n   */\n    id: string,\n  /** Descriptive text that explains the error */\n    message?: string,\n\n},\n    status: \"completed\" | \"failed\" | \"ongoing\" | \"pending\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/summary": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * When generation of the shipment report was completed.\n   * @format date-time\n   */\n    completedAt: string,\n  /**\n   * When generation of the shipment report was started.\n   * @format date-time\n   */\n    createdAt: string,\n  /** Count of locations over all segment plans in the shipment report. */\n    totalLocationCount: number,\n  /** Count of segment plans in the shipments report. */\n    totalSegmentPlanCount: number,\n  /** Count of segments over all segment plans in the shipment report. */\n    totalSegmentsCount: number,\n  /** Count of shipment plans in the shipments report. */\n    totalShipmentPlanCount: number,\n  /** Count of shipments over all shipment plans in the shipment report. */\n    totalShipmentsCount: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/{metric}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** The response items can be sorted to ascending or descending order by their statistics properties. E.g for\n`shipmentPlanPunctualityAtOrigin` it could be `avg:desc`.\nDefault is ascending sort order.\n */\n sort?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** The response items can be sorted to ascending or descending order by their statistics properties. E.g for\n`shipmentPlanPunctualityAtOrigin` it could be `avg:desc`.\nDefault is ascending sort order.\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".metric": {
        "rendered": "\n/** Metric for which results to include in the response.\n */\n metric: \"shipmentPlanPunctualityAtOrigin\" | \"shipmentPlanPunctualityAtDestination\" | \"segmentPlanPunctualityAtOrigin\" | \"segmentPlanPunctualityAtDestination\" | \"shipmentPunctualityAtOrigin\" | \"shipmentPunctualityAtDestination\" | \"segmentPunctualityAtOrigin\" | \"segmentPunctualityAtDestination\" | \"locationDwelling\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count?: number,\n    items?: ({\n  /**\n   * Combination of shipmentId, shipmentPlanId, segmentId, segmentPlanId or locationId based on\n   * the given metric.\n   */\n    ids?: {\n  /**\n   * Location ID\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    locationId?: string,\n  /**\n   * Segment ID\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId?: string,\n  /**\n   * Segment plan ID\n   * @pattern ^SEGP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentPlanId?: string,\n  /**\n   * Shipment ID\n   * @pattern ^SHP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentId?: string,\n  /**\n   * Shipment plan ID\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId?: string,\n\n},\n  /** Calculated statistics of the given metric. */\n    statistics?: {\n  /** Average value taken over metric values. */\n    avg?: number,\n  /** Value of a metric. */\n    val?: number,\n\n},\n  /** How many inputs were used to calculate the given metric. */\n    statisticsCount?: number,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit?: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /**\n   * Total number of items\n   * @min 0\n   */\n    total?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter the results by shipment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Return only shipments that started before the specified timestamp */\n startedBefore?: string, \n/** Return only shipments that started after the specified timestamp */\n startedAfter?: string, \n/** Return only shipments that ended before the specified timestamp */\n endedBefore?: string, \n/** Return only shipments that ended after the specified timestamp */\n endedAfter?: string, \n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Filter shipments by `shipmentId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentId?: string, \n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean, \n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string, \n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string, \n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'shipmentId:desc' sort by shipmentId in descending order.\nAllowed fields to sort by:\nshipmentId, name, status, startedAt, createdAt, endedAt, providedEtd,\nprovidedEta, calculatedEtd.\n */\n sort?: string | (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.status": {
        "rendered": "\n/** Filter the results by shipment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startedBefore": {
        "rendered": "\n/** Return only shipments that started before the specified timestamp */\n startedBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startedAfter": {
        "rendered": "\n/** Return only shipments that started after the specified timestamp */\n startedAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endedBefore": {
        "rendered": "\n/** Return only shipments that ended before the specified timestamp */\n endedBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endedAfter": {
        "rendered": "\n/** Return only shipments that ended after the specified timestamp */\n endedAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentId": {
        "rendered": "\n/** Filter shipments by `shipmentId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.isSubShipment": {
        "rendered": "\n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdBefore": {
        "rendered": "\n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdAfter": {
        "rendered": "\n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'shipmentId:desc' sort by shipmentId in descending order.\nAllowed fields to sort by:\nshipmentId, name, status, startedAt, createdAt, endedAt, providedEtd,\nprovidedEta, calculatedEtd.\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   */\n    autoStart: boolean,\n  /**\n   * Calculated  ETA for the shipment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the shipment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when the shipment has been created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Timestamp indicating when the shipment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * User provided ETA for the shipment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the shipment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /** Array containing the segment details */\n    segments: ({\n  /**\n   * Calculated  ETA for the segment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the segment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when this segment created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Timestamp indicating when this segment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * User provided ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Segment ID\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId?: string,\n  /**\n   * Timestamp indicating when this segment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the segment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /**\n   * Shipment ID\n   * @pattern ^SHP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentId: string,\n  /**\n   * A shipment plan's id that the shipment was generated from.\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId?: string,\n  /**\n   * Timestamp indicating when the shipment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the shipment */\n    status: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /** Flag telling if shipment is a subShipment. */\n    subShipment?: boolean,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /** Total number of shipments for query */\n    total?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Shipment ID\n   * @pattern ^SHP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Return only shipment plans that have been instantiated from the specified `shipmentPlanId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentPlanId?: string, \n/** Return only shipments that have been instantiated from the specified `locationId`\n */\n locationId?: string, \n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string, \n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string, \n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean, \n/** A paramater to specify field to sort by and order.\nAllowed fields to sort by: shipmentPlanId, name, createdAt\n */\n sort?: string | (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentPlanId": {
        "rendered": "\n/** Return only shipment plans that have been instantiated from the specified `shipmentPlanId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.locationId": {
        "rendered": "\n/** Return only shipments that have been instantiated from the specified `locationId`\n */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdBefore": {
        "rendered": "\n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdAfter": {
        "rendered": "\n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.isSubShipment": {
        "rendered": "\n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nAllowed fields to sort by: shipmentPlanId, name, createdAt\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count: number,\n    items: ({\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   * @default true\n   */\n    autoStart?: boolean,\n  /**\n   * Timestamp indicating when the shipment plan has been created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /**\n   * Array of objects each defining the origin and destination of the segment\n   * @maxItems 20\n   * @minItems 1\n   */\n    segments: ({\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Segment duration in seconds.\n   * @min 0\n   */\n    durationS?: number,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * Segment plan ID\n   * @pattern ^SEGP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentPlanId?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /**\n   * Shipment plan ID\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId: string,\n  /**\n   * Flag telling if shipment is a subShipment.\n   * @default false\n   */\n    subShipment?: boolean,\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n  /**\n   * Total count of matching results\n   * @min 0\n   */\n    total: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Shipment plan ID\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   * @default true\n   */\n    autoStart?: boolean,\n  /**\n   * Timestamp indicating when the shipment plan has been created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /**\n   * Array of objects each defining the origin and destination of the segment\n   * @maxItems 20\n   * @minItems 1\n   */\n    segments: ({\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Segment duration in seconds.\n   * @min 0\n   */\n    durationS?: number,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * Segment plan ID\n   * @pattern ^SEGP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentPlanId?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /**\n   * Shipment plan ID\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId: string,\n  /**\n   * Flag telling if shipment is a subShipment.\n   * @default false\n   */\n    subShipment?: boolean,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/plans/{shipmentPlanId}/{segmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Segment duration in seconds.\n   * @min 0\n   */\n    durationS?: number,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * Segment plan ID\n   * @pattern ^SEGP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentPlanId?: string,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/plans/{shipmentPlanId}/{segmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   */\n    autoStart: boolean,\n  /**\n   * Calculated  ETA for the shipment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the shipment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when the shipment has been created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Timestamp indicating when the shipment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * User provided ETA for the shipment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the shipment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /** Array containing the segment details */\n    segments: ({\n  /**\n   * Calculated  ETA for the segment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the segment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when this segment created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Timestamp indicating when this segment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * User provided ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Segment ID\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId?: string,\n  /**\n   * Timestamp indicating when this segment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the segment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /**\n   * Shipment ID\n   * @pattern ^SHP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentId: string,\n  /**\n   * A shipment plan's id that the shipment was generated from.\n   * @pattern ^SHPP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentPlanId?: string,\n  /**\n   * Timestamp indicating when the shipment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the shipment */\n    status: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /** Flag telling if shipment is a subShipment. */\n    subShipment?: boolean,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/{shipmentId}/{segmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Calculated  ETA for the segment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the segment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when this segment created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Timestamp indicating when this segment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * User provided ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Segment ID\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId?: string,\n  /**\n   * Timestamp indicating when this segment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the segment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/{shipmentId}/{segmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/shipments/v4/{trackingId}/segments": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter the results by segment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.status": {
        "rendered": "\n/** Filter the results by segment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Number of items returned in the response\n   * @min 0\n   * @max 100\n   */\n    count?: number,\n    items?: ({\n  /**\n   * Calculated  ETA for the segment\n   * @format date-time\n   */\n    calculatedEta?: string,\n  /**\n   * Calculated ETD for the segment\n   * @format date-time\n   */\n    calculatedEtd?: string,\n  /**\n   * Timestamp indicating when this segment created\n   * @format date-time\n   */\n    createdAt?: string,\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination?: string,\n  /**\n   * Timestamp indicating when this segment ended\n   * @format date-time\n   */\n    endedAt?: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin?: string,\n  /**\n   * User provided ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * User provided ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Segment ID\n   * @pattern ^SEG-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    segmentId?: string,\n  /**\n   * Shipment ID\n   * @pattern ^SHP-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    shipmentId?: string,\n  /**\n   * Timestamp indicating when this segment started\n   * @format date-time\n   */\n    startedAt?: string,\n  /** Status of the segment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /**\n   * Maximum number of items as specified in request\n   * @min 1\n   * @max 100\n   */\n    limit?: number,\n  /** Token to fetch the next page (if exists) */\n    nextPageToken?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/traces/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/traces/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "delete__/traces/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/traces/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Flag specifying if only outliers (`true`) or only nonoutliers (`false`)\nare to be returned. If the parameter is not present both nonoutlier\nand outlier traces are returned.\n */\n outliers?: boolean, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** Flag telling if smoothed traces (true) or non-smoothed (false)\ntraces should get returned. By default the traces are not smoothed.\n\nThe smoothing will have an effect on to the stationary trace points only.\n */\n smooth?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of records per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.outliers": {
        "rendered": "\n/** Flag specifying if only outliers (`true`) or only nonoutliers (`false`)\nare to be returned. If the parameter is not present both nonoutlier\nand outlier traces are returned.\n */\n outliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.smooth": {
        "rendered": "\n/** Flag telling if smoothed traces (true) or non-smoothed (false)\ntraces should get returned. By default the traces are not smoothed.\n\nThe smoothing will have an effect on to the stationary trace points only.\n */\n smooth?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of records per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseTraces",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/transitions/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "ResponseTransitions",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/transitions/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/transitions/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/users/v2/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "ResponseListDevices",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/users/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/login": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n    accessToken?: string,\n  /**\n   * The lifetime in seconds of the access token.\n   * For example 86400 means the token will expire in 24 hours from the time the response was generated.\n   */\n    expiresIn?: number,\n  /** Current realm ID */\n    realm?: string,\n    refreshToken?: string,\n  /** The token type is bearer */\n    tokenType?: string,\n  /**\n   * The HERE Account ID of a user.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/refresh": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n    accessToken?: string,\n  /**\n   * The lifetime in seconds of the access token.\n   * For example 86400 means the token will expire in 24 hours from the time the response was generated.\n   */\n    expiresIn?: number,\n  /** Current realm ID */\n    realm?: string,\n    refreshToken?: string,\n  /** The token type is bearer */\n    tokenType?: string,\n  /**\n   * The HERE Account ID of a user.\n   * @pattern ^HERE-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    userId?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/tokenExchange": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Project-scoped access token. */\n    accessToken?: string,\n  /**\n   * The lifetime in seconds of the access token.\n   * For example 86400 means the token will expire in 24 hours from the time the response was generated.\n   */\n    expiresIn?: number,\n  /** The type of token issued when grantType is \"urn:ietf:params:oauth:grant-type:token-exchange\". */\n    issuedTokenType?: string,\n  /** Requested scope of the access token. Must be an HRN identifying a project that the identified user has access to. */\n    scope?: string,\n  /** The token type is 'Bearer'. */\n    tokenType?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/users/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/v2/": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.async": {
        "rendered": "\n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** Contains device configuration settings. */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @min 2\n   * @max 4102448400000\n   */\n    begin?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @min 2\n   * @max 4102448400000\n   */\n    end?: number,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to geofences that device is associated\n   * with. This value is zero when device hasn't yet been associated with\n   * any geofence. This is set by HERE Tracking when any geofences\n   * associated with the device is modified or removed. Also adding and\n   * removing geofence associations update this value.\n   * @min 0\n   * @max 4102448400000\n   */\n    lastModifiedGeofenceTimestamp: number,\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /** The device sensors alarm configuration. */\n    sensorAlarmConfig?: {\n  /** An upper threshold value for acceleration in g-forces. */\n    alertAccelerationGMax?: number,\n  /** A lower threshold value for acceleration in g-forces. */\n    alertAccelerationGMin?: number,\n  /** An upper threshold value for battery level percentage. */\n    alertBatteryLevelPMax?: number,\n  /** A lower threshold value for battery level percentage. */\n    alertBatteryLevelPMin?: number,\n  /** An upper threshold value for pressure in hectopascals. */\n    alertPressureHpaMax?: number,\n  /** A lower threshold value for pressure in hectopascals. */\n    alertPressureHpaMin?: number,\n  /** An upper threshold value for relative humidity percentage. */\n    alertRelativeHumidityMax?: number,\n  /** A lower threshold value for relative humidity percentage. */\n    alertRelativeHumidityMin?: number,\n  /** An upper threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMax?: number,\n  /** A lower threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMin?: number,\n  /** An upper threshold value for tilt in degrees. */\n    alertTiltDegreeMax?: number,\n  /** A lower threshold value for tilt in degrees. */\n    alertTiltDegreeMin?: number,\n  /**\n   * True if attach sensor alert in device is enabled.\n   * @default false\n   */\n    isAttachAlertEnabled?: boolean,\n  /**\n   * True if tamper sensor alert in device is enabled.\n   * @default false\n   */\n    isTamperAlertEnabled?: boolean,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion: number,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to the desired shadow.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/timestamp": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * Seconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400\n   */\n    timestamp?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v2/token": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n    accessToken?: string,\n    expiresIn?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "post__/v3/": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.async": {
        "rendered": "\n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** Contains device configuration settings. */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @min 2\n   * @max 4102448400000\n   */\n    begin?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @min 2\n   * @max 4102448400000\n   */\n    end?: number,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to geofences that device is associated\n   * with. This value is zero when device hasn't yet been associated with\n   * any geofence. This is set by HERE Tracking when any geofences\n   * associated with the device is modified or removed. Also adding and\n   * removing geofence associations update this value.\n   * @min 0\n   * @max 4102448400000\n   */\n    lastModifiedGeofenceTimestamp: number,\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /** The device sensors alarm configuration. */\n    sensorAlarmConfig?: {\n  /** An upper threshold value for acceleration in g-forces. */\n    alertAccelerationGMax?: number,\n  /** A lower threshold value for acceleration in g-forces. */\n    alertAccelerationGMin?: number,\n  /** An upper threshold value for battery level percentage. */\n    alertBatteryLevelPMax?: number,\n  /** A lower threshold value for battery level percentage. */\n    alertBatteryLevelPMin?: number,\n  /** An upper threshold value for pressure in hectopascals. */\n    alertPressureHpaMax?: number,\n  /** A lower threshold value for pressure in hectopascals. */\n    alertPressureHpaMin?: number,\n  /** An upper threshold value for relative humidity percentage. */\n    alertRelativeHumidityMax?: number,\n  /** A lower threshold value for relative humidity percentage. */\n    alertRelativeHumidityMin?: number,\n  /** An upper threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMax?: number,\n  /** A lower threshold value for temperature in degrees Celsius. */\n    alertTemperatureCMin?: number,\n  /** An upper threshold value for tilt in degrees. */\n    alertTiltDegreeMax?: number,\n  /** A lower threshold value for tilt in degrees. */\n    alertTiltDegreeMin?: number,\n  /**\n   * True if attach sensor alert in device is enabled.\n   * @default false\n   */\n    isAttachAlertEnabled?: boolean,\n  /**\n   * True if tamper sensor alert in device is enabled.\n   * @default false\n   */\n    isTamperAlertEnabled?: boolean,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion: number,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The time of the last update to the desired shadow.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v3/batch": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  },
  "get__/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{\n  /** Health status */\n    message?: string,\n\n}",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false },
      ".__no_name.__no_name.__no_name": {
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "any",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": { "requiresRelaxedTypeAnnotation": false }
    }
  }
}
