{
  "get__/aliases/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** An alias type */\n type?: string, \n/** Filter for aliases external IDs */\n externalId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.externalId": {
        "rendered": "\n/** Filter for aliases external IDs */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** A map of key-value pairs where the key is the type of the alias\nand the value is an array of externalIds.\n */\n aliases?: hasuraSdk.JSONValue,  trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/aliases/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/trackingId": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** An alias type */\n type: string, \n/** An external ID. An externalId and type pair uniquely identifies an alias. */\n externalId: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.externalId": {
        "rendered": "\n/** An external ID. An externalId and type pair uniquely identifies an alias. */\n externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.appId": {
        "rendered": "\n/** Virtual device application ID, only present when the device is virtual */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.externalId": {
        "rendered": "\n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/aliases/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** An alias type */\n type?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** An alias type */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & { \n/** A map of key-value pairs where the key is the type of the alias\nand the value is an array of `externalId`s.\n */\n data?: hasuraSdk.JSONValue, }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/aliases/v2/{trackingId}/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * A map of key-value pairs where the key is the type of the\n   * alias and the value is an array of `externalId`s.\n   */\n    aliases: hasuraSdk.JSONValue,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/aliases/v2/{trackingId}/{type}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/aliases/v2/{trackingId}/{type}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": " type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & { \n/** A map of key-value pairs where the key is the type of the alias\nand the value is an array of `externalId`s.\n */\n data?: hasuraSdk.JSONValue, }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/aliases/v2/{trackingId}/{type}/{externalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": "\n/** An alias type */\n type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalId": {
        "rendered": "\n/** An external ID. An `externalId` and a `type` pair uniquely identifies an alias. */\n externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/aliases/v2/{trackingId}/{type}/{externalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".type": {
        "rendered": " type: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalId": {
        "rendered": " externalId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/associations/v3/devices/batchUpdate": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** Rules to be associated to the devices */\n    newRules: {\n  /**\n   * Array of geofence IDs\n   * @maxItems 15\n   */\n    geofenceIds: (string)[],\n  /**\n   * Array of rule IDs\n   * @maxItems 15\n   */\n    ruleIds: (string)[],\n\n},\n  /** Rules to be disassociated from the devices */\n    oldRules: {\n  /**\n   * Array of geofence IDs\n   * @maxItems 15\n   */\n    geofenceIds: (string)[],\n  /**\n   * Array of rule IDs\n   * @maxItems 15\n   */\n    ruleIds: (string)[],\n\n},\n  /**\n   * Array of tracking IDs (external IDs are also permitted here)\n   * @maxItems 50\n   * @minItems 1\n   */\n    trackingIds: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/associations/v3/devices/{trackingId}/batchCreate": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Array of geofence IDs\n   * @maxItems 15\n   */\n    geofenceIds: (string)[],\n  /**\n   * Array of rule IDs\n   * @maxItems 15\n   */\n    ruleIds: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/associations/v3/devices/{trackingId}/batchDelete": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Array of geofence IDs\n   * @maxItems 15\n   */\n    geofenceIds: (string)[],\n  /**\n   * Array of rule IDs\n   * @maxItems 15\n   */\n    ruleIds: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/{trackingId}/geofences": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.type.__no_name": {
        "rendered": "\"circle\" | \"polygon\" | \"poi\"",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string,  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Geofence ID */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/associations/v3/{trackingId}/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/associations/v3/{trackingId}/geofences/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/{trackingId}/rules": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/associations/v3/{trackingId}/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/associations/v3/{trackingId}/rules/{ruleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/associations/v3/{trackingId}/sensors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  description?: string, \n/** Must be a valid UUIDv4.\n */\n id?: string,  name?: string,  range: { \n/** The lower threshold value. */\n begin?: number, \n/** The upper threshold value. */\n end?: number, },  threshold: { \n/** Threshold value */\n value?: number, }, \n/** The sensor type. */\n type?: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/associations/v3/{trackingId}/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/associations/v3/{trackingId}/sensors/{sensorRuleId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/deviceUploads": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",  status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\" | (\"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\")[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.type": {
        "rendered": "\n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.status": {
        "rendered": " status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\" | (\"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\")[],",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Bulk upload job ID */\n jobId?: string, \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\", })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Bulk upload job ID */\n jobId?: string, \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Bulk upload job ID */\n jobId?: string, \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.status": {
        "rendered": "\n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.type": {
        "rendered": "\n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/bulkjobs/v4/deviceUploads": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The name of the upload file. */\n fileName?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fileName": {
        "rendered": "\n/** The name of the upload file. */\n fileName?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ((({\n  /**\n   * True if device should be configured to be in area based mode.\n   * Area based mode can be set to true only if device has maximum of 3 associated geofences.\n   * @default false\n   */\n    areaBased?: boolean,\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * Geofence IDs to be associated with the device\n   * @maxItems 10\n   */\n    geofences?: (string)[],\n  /**\n   * The name of the device. Must be unique within a project.\n   * @minLength 1\n   * @maxLength 50\n   */\n    name: string,\n  /**\n   * Rule or sensor rule IDs to be associated with the device\n   * @maxItems 10\n   */\n    rules?: (string)[],\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n  /**\n   * Arbitrary tags to be assigned to the device\n   * @maxItems 10\n   */\n    tags?: (string)[],\n  /**\n   * The type of the asset. Can be any user defined string, but if one of the following types is\n   * selected, the asset icon in asset.tracking.here.com application will be changed accordingly:\n   * \n   * * `Phone`\n   * * `Heavy Machinery`\n   * * `Tracker`\n   * * `Airport / Air Cargo`\n   * * `Warehouse`\n   * * `Returnable / Reusable`\n   * * `Generic`\n   * * `Hospital`\n   * @minLength 1\n   * @maxLength 50\n   */\n    type?: string,\n\n} | {\n  /**\n   * True if device should be configured to be in area based mode.\n   * Area based mode can be set to true only if device has maximum of 3 associated geofences.\n   * @default false\n   */\n    areaBased?: boolean,\n  /**\n   * Device ID of a provisioned device\n   * @minLength 1\n   * @maxLength 50\n   */\n    deviceId: string,\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * Geofence IDs to be associated with the device\n   * @maxItems 10\n   */\n    geofences?: (string)[],\n  /**\n   * The name of the device. Must be unique within a project.\n   * @minLength 1\n   * @maxLength 50\n   */\n    name: string,\n  /**\n   * Rule or sensor rule IDs to be associated with the device\n   * @maxItems 10\n   */\n    rules?: (string)[],\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n  /**\n   * Arbitrary tags to be assigned to the device\n   * @maxItems 10\n   */\n    tags?: (string)[],\n  /**\n   * The type of the asset. Can be any user defined string, but if one of the following types is\n   * selected, the asset icon in asset.tracking.here.com application will be changed accordingly:\n   * \n   * * `Phone`\n   * * `Heavy Machinery`\n   * * `Tracker`\n   * * `Airport / Air Cargo`\n   * * `Warehouse`\n   * * `Returnable / Reusable`\n   * * `Generic`\n   * * `Hospital`\n   * @minLength 1\n   * @maxLength 50\n   */\n    type?: string,\n\n} | {\n  /**\n   * True if device should be configured to be in area based mode.\n   * Area based mode can be set to true only if device has maximum of 3 associated geofences.\n   * @default false\n   */\n    areaBased?: boolean,\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * Virtual device external ID, only present when the device is virtual\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalId: string,\n  /**\n   * Geofence IDs to be associated with the device\n   * @maxItems 10\n   */\n    geofences?: (string)[],\n  /**\n   * The name of the device. Must be unique within a project.\n   * @minLength 1\n   * @maxLength 50\n   */\n    name: string,\n  /**\n   * Rule or sensor rule IDs to be associated with the device\n   * @maxItems 10\n   */\n    rules?: (string)[],\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n  /**\n   * Arbitrary tags to be assigned to the device\n   * @maxItems 10\n   */\n    tags?: (string)[],\n  /**\n   * The type of the asset. Can be any user defined string, but if one of the following types is\n   * selected, the asset icon in asset.tracking.here.com application will be changed accordingly:\n   * \n   * * `Phone`\n   * * `Heavy Machinery`\n   * * `Tracker`\n   * * `Airport / Air Cargo`\n   * * `Warehouse`\n   * * `Returnable / Reusable`\n   * * `Generic`\n   * * `Hospital`\n   * @minLength 1\n   * @maxLength 50\n   */\n    type?: string,\n\n} | {\n  /**\n   * True if device should be configured to be in area based mode.\n   * Area based mode can be set to true only if device has maximum of 3 associated geofences.\n   * @default false\n   */\n    areaBased?: boolean,\n  /**\n   * Identifier of the connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    connectorId: string,\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * Identifier of the device on the external cloud.\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalDeviceId: string,\n  /**\n   * Geofence IDs to be associated with the device\n   * @maxItems 10\n   */\n    geofences?: (string)[],\n  /**\n   * The name of the device. Must be unique within a project.\n   * @minLength 1\n   * @maxLength 50\n   */\n    name: string,\n  /**\n   * Rule or sensor rule IDs to be associated with the device\n   * @maxItems 10\n   */\n    rules?: (string)[],\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n  /**\n   * Arbitrary tags to be assigned to the device\n   * @maxItems 10\n   */\n    tags?: (string)[],\n  /**\n   * The type of the asset. Can be any user defined string, but if one of the following types is\n   * selected, the asset icon in asset.tracking.here.com application will be changed accordingly:\n   * \n   * * `Phone`\n   * * `Heavy Machinery`\n   * * `Tracker`\n   * * `Airport / Air Cargo`\n   * * `Warehouse`\n   * * `Returnable / Reusable`\n   * * `Generic`\n   * * `Hospital`\n   * @minLength 1\n   * @maxLength 50\n   */\n    type?: string,\n\n}))[] | (({\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking.\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId: string,\n  /**\n   * If set to true, the device will only be unclaimed but not unprovisioned. Set `unclaimOnly`\n   * to true in case you want to use the already existing deviceId and deviceSecret of the device\n   * to claim the device in this or other project in the future.\n   * @default false\n   */\n    unclaimOnly?: boolean,\n\n} | {\n  /**\n   * Virtual device external ID, only present when the device is virtual\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalId: string,\n  /**\n   * If set to true, the device will only be unclaimed but not unprovisioned. Set `unclaimOnly`\n   * to true in case you want to use the already existing deviceId and deviceSecret of the device\n   * to claim the device in this or other project in the future.\n   * @default false\n   */\n    unclaimOnly?: boolean,\n\n} | {\n  /**\n   * Identifier of the connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    connectorId: string,\n  /**\n   * Identifier of the device on the external cloud.\n   * @minLength 1\n   * @maxLength 50\n   */\n    externalDeviceId: string,\n  /**\n   * If set to true, external device is only removed from the connector but the virtual device\n   * will remain claimed and provisioned in Tracking Cloud. Can be true only when removing c2c\n   * device, i.e. when `externalDeviceId` and `connectorId` are provided.\n   * @default false\n   */\n    removeFromConnectorOnly?: boolean,\n  /**\n   * If set to true, the device will only be unclaimed but not unprovisioned. Set `unclaimOnly`\n   * to true in case you want to use the already existing deviceId and deviceSecret of the device\n   * to claim the device in this or other project in the future.\n   * @default false\n   */\n    unclaimOnly?: boolean,\n\n}))[]),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Bulk upload job ID */\n jobId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/bulkjobs/v4/deviceUploads/{jobId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n    action: \"cancel\" | \"acknowledge\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/bulkjobs/v4/deviceUploads/{jobId}/results": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Device ID of a provisioned device */\n deviceId?: string, \n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string,  errors?: ({ \n/** Error code */\n code?: number, \n/** Error details */\n details?: string, \n/** Error description */\n message?: string, })[], \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** The name of the device. Must be unique within a project. */\n name?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Device ID of a provisioned device */\n deviceId?: string, \n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string,  errors?: ({ \n/** Error code */\n code?: number, \n/** Error details */\n details?: string, \n/** Error description */\n message?: string, })[], \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** The name of the device. Must be unique within a project. */\n name?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Device ID of a provisioned device */\n deviceId?: string, \n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string,  errors?: ({ \n/** Error code */\n code?: number, \n/** Error details */\n details?: string, \n/** Error description */\n message?: string, })[], \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** The name of the device. Must be unique within a project. */\n name?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.connectorId": {
        "rendered": "\n/** Identifier of the connector. */\n connectorId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.deviceId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.deviceSecret": {
        "rendered": "\n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.errors": {
        "rendered": " errors?: ({ \n/** Error code */\n code?: number, \n/** Error details */\n details?: string, \n/** Error description */\n message?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.errors.__no_name": {
        "rendered": "{ \n/** Error code */\n code?: number, \n/** Error details */\n details?: string, \n/** Error description */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.errors.__no_name.code": {
        "rendered": "\n/** Error code */\n code?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.errors.__no_name.details": {
        "rendered": "\n/** Error details */\n details?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.errors.__no_name.message": {
        "rendered": "\n/** Error description */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalDeviceId": {
        "rendered": "\n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalId": {
        "rendered": "\n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** The name of the device. Must be unique within a project. */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.type": {
        "rendered": "\n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/bulkjobs/v4/deviceUploads/{jobId}/status": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** Bulk upload job ID */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of devices for which all planned upload operations failed. */\n failed?: number, \n/** The name of the upload file. */\n fileName?: string, \n/** The number of devices for which some upload operations succeeded. */\n partiallySucceeded?: number, \n/** The number of devices that are still waiting upload operations to be done. */\n pending?: number, \n/** The percentage of the job that was completed at the time of the request. */\n progress?: number, \n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\", \n/** The number of devices for which all planned upload operations succeeded. */\n succeeded?: number, \n/** The total number of devices to be uploaded in this job. */\n total?: number, \n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.failed": {
        "rendered": "\n/** The number of devices for which all planned upload operations failed. */\n failed?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.fileName": {
        "rendered": "\n/** The name of the upload file. */\n fileName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.partiallySucceeded": {
        "rendered": "\n/** The number of devices for which some upload operations succeeded. */\n partiallySucceeded?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.pending": {
        "rendered": "\n/** The number of devices that are still waiting upload operations to be done. */\n pending?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.progress": {
        "rendered": "\n/** The percentage of the job that was completed at the time of the request. */\n progress?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the bulk upload. */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\" | \"cancelled\" | \"acknowledged\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.succeeded": {
        "rendered": "\n/** The number of devices for which all planned upload operations succeeded. */\n succeeded?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** The total number of devices to be uploaded in this job. */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.type": {
        "rendered": "\n/** Type of bulk job (either `create` or `delete`) */\n type?: \"create\" | \"delete\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/bulkjobs/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/bulkjobs/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/callback": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** API Key */\n apiKey: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.apiKey": {
        "rendered": "\n/** API Key */\n apiKey: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Data,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/connectors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, } & { \n/** Brief description of the connector. */\n description?: string, \n/** Identifier of the driver to be used with this connector. */\n driverId?: string, \n/** Enabled state of the connector. If set to false then the connector\nwill not execute periodically.\n */\n enabled?: boolean, \n/** An external cloud-specific object that the driver will use to login to the\nexternal cloud. The structure of this object varies per driver\nimplementation.\nIt is recommended to have dedicated credentials for logging in to\nthe external cloud in order not to violate possible concurrent users\npolicies of the external cloud.\nIn case of the HERE Tracking loopback driver, the maximum\nallowed concurrent user account tokens is 3 per account,\ntherefore it is recommended to create a separate HERE account\nand grant it the required privilege to update the connector's\nproject, and use that account in externalCloudInfo.\n */\n externalCloudInfo?: hasuraSdk.JSONValue, \n/** Name of the connector. */\n name?: string, \n/** This is the interval (in seconds) to execute the sync process\nbetween the connector's external cloud and HERE Tracking project.\nThe maximum and at the same time default value for callback-type connectors is 900 seconds.\nThe default value for other type of connectors is 3600 seconds and there is no maximum value set.\n */\n refreshIntervalS?: number, } & { \n/** Timestamp of the last connection execution. */\n lastExecTs?: string, } & { \n/** Number of external devices added to the connector. */\n totalAddedDevices?: number, } & { \n/** Timestamp of the connector creation. */\n createdAt?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, } & { \n/** Brief description of the connector. */\n description?: string, \n/** Identifier of the driver to be used with this connector. */\n driverId?: string, \n/** Enabled state of the connector. If set to false then the connector\nwill not execute periodically.\n */\n enabled?: boolean, \n/** An external cloud-specific object that the driver will use to login to the\nexternal cloud. The structure of this object varies per driver\nimplementation.\nIt is recommended to have dedicated credentials for logging in to\nthe external cloud in order not to violate possible concurrent users\npolicies of the external cloud.\nIn case of the HERE Tracking loopback driver, the maximum\nallowed concurrent user account tokens is 3 per account,\ntherefore it is recommended to create a separate HERE account\nand grant it the required privilege to update the connector's\nproject, and use that account in externalCloudInfo.\n */\n externalCloudInfo?: hasuraSdk.JSONValue, \n/** Name of the connector. */\n name?: string, \n/** This is the interval (in seconds) to execute the sync process\nbetween the connector's external cloud and HERE Tracking project.\nThe maximum and at the same time default value for callback-type connectors is 900 seconds.\nThe default value for other type of connectors is 3600 seconds and there is no maximum value set.\n */\n refreshIntervalS?: number, } & { \n/** Timestamp of the last connection execution. */\n lastExecTs?: string, } & { \n/** Number of external devices added to the connector. */\n totalAddedDevices?: number, } & { \n/** Timestamp of the connector creation. */\n createdAt?: string, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, } & { \n/** Brief description of the connector. */\n description?: string, \n/** Identifier of the driver to be used with this connector. */\n driverId?: string, \n/** Enabled state of the connector. If set to false then the connector\nwill not execute periodically.\n */\n enabled?: boolean, \n/** An external cloud-specific object that the driver will use to login to the\nexternal cloud. The structure of this object varies per driver\nimplementation.\nIt is recommended to have dedicated credentials for logging in to\nthe external cloud in order not to violate possible concurrent users\npolicies of the external cloud.\nIn case of the HERE Tracking loopback driver, the maximum\nallowed concurrent user account tokens is 3 per account,\ntherefore it is recommended to create a separate HERE account\nand grant it the required privilege to update the connector's\nproject, and use that account in externalCloudInfo.\n */\n externalCloudInfo?: hasuraSdk.JSONValue, \n/** Name of the connector. */\n name?: string, \n/** This is the interval (in seconds) to execute the sync process\nbetween the connector's external cloud and HERE Tracking project.\nThe maximum and at the same time default value for callback-type connectors is 900 seconds.\nThe default value for other type of connectors is 3600 seconds and there is no maximum value set.\n */\n refreshIntervalS?: number, } & { \n/** Timestamp of the last connection execution. */\n lastExecTs?: string, } & { \n/** Number of external devices added to the connector. */\n totalAddedDevices?: number, } & { \n/** Timestamp of the connector creation. */\n createdAt?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/connectors": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Brief description of the connector.\n   * @maxLength 200\n   */\n    description?: string,\n  /**\n   * Identifier of the driver to be used with this connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    driverId: string,\n  /**\n   * Enabled state of the connector. If set to false then the connector\n   * will not execute periodically.\n   */\n    enabled: boolean,\n  /**\n   * An external cloud-specific object that the driver will use to login to the\n   * external cloud. The structure of this object varies per driver\n   * implementation.\n   * It is recommended to have dedicated credentials for logging in to\n   * the external cloud in order not to violate possible concurrent users\n   * policies of the external cloud.\n   * In case of the HERE Tracking loopback driver, the maximum\n   * allowed concurrent user account tokens is 3 per account,\n   * therefore it is recommended to create a separate HERE account\n   * and grant it the required privilege to update the connector's\n   * project, and use that account in externalCloudInfo.\n   */\n    externalCloudInfo: hasuraSdk.JSONValue,\n  /**\n   * Name of the connector.\n   * @minLength 1\n   * @maxLength 100\n   */\n    name: string,\n  /**\n   * This is the interval (in seconds) to execute the sync process\n   * between the connector's external cloud and HERE Tracking project.\n   * The maximum and at the same time default value for callback-type connectors is 900 seconds.\n   * The default value for other type of connectors is 3600 seconds and there is no maximum value set.\n   * @min 60\n   */\n    refreshIntervalS?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/c2c/v4/connectors/ext-devices/{externalDeviceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".externalDeviceId": {
        "rendered": "\n/** Identifier of the external device */\n externalDeviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Identifier of the connector. */\n connectorId?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Identifier of the connector. */\n connectorId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.connectorId": {
        "rendered": "\n/** Identifier of the connector. */\n connectorId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Unclaim and unprovision devices */\n deleteDevices?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.deleteDevices": {
        "rendered": "\n/** Unclaim and unprovision devices */\n deleteDevices?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/connectors/{connectorId}": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Identifier of the connector. */\n connectorId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, } & { \n/** Brief description of the connector. */\n description?: string, \n/** Identifier of the driver to be used with this connector. */\n driverId?: string, \n/** Enabled state of the connector. If set to false then the connector\nwill not execute periodically.\n */\n enabled?: boolean, \n/** An external cloud-specific object that the driver will use to login to the\nexternal cloud. The structure of this object varies per driver\nimplementation.\nIt is recommended to have dedicated credentials for logging in to\nthe external cloud in order not to violate possible concurrent users\npolicies of the external cloud.\nIn case of the HERE Tracking loopback driver, the maximum\nallowed concurrent user account tokens is 3 per account,\ntherefore it is recommended to create a separate HERE account\nand grant it the required privilege to update the connector's\nproject, and use that account in externalCloudInfo.\n */\n externalCloudInfo?: hasuraSdk.JSONValue, \n/** Name of the connector. */\n name?: string, \n/** This is the interval (in seconds) to execute the sync process\nbetween the connector's external cloud and HERE Tracking project.\nThe maximum and at the same time default value for callback-type connectors is 900 seconds.\nThe default value for other type of connectors is 3600 seconds and there is no maximum value set.\n */\n refreshIntervalS?: number, } & { \n/** Timestamp of the last connection execution. */\n lastExecTs?: string, } & { \n/** Number of external devices added to the connector. */\n totalAddedDevices?: number, } & { \n/** Timestamp of the connector creation. */\n createdAt?: string, }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/c2c/v4/connectors/{connectorId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Brief description of the connector.\n   * @maxLength 200\n   */\n    description?: string,\n  /**\n   * Identifier of the driver to be used with this connector.\n   * @minLength 1\n   * @maxLength 50\n   */\n    driverId: string,\n  /**\n   * Enabled state of the connector. If set to false then the connector\n   * will not execute periodically.\n   */\n    enabled: boolean,\n  /**\n   * An external cloud-specific object that the driver will use to login to the\n   * external cloud. The structure of this object varies per driver\n   * implementation.\n   * It is recommended to have dedicated credentials for logging in to\n   * the external cloud in order not to violate possible concurrent users\n   * policies of the external cloud.\n   * In case of the HERE Tracking loopback driver, the maximum\n   * allowed concurrent user account tokens is 3 per account,\n   * therefore it is recommended to create a separate HERE account\n   * and grant it the required privilege to update the connector's\n   * project, and use that account in externalCloudInfo.\n   */\n    externalCloudInfo: hasuraSdk.JSONValue,\n  /**\n   * Name of the connector.\n   * @minLength 1\n   * @maxLength 100\n   */\n    name: string,\n  /**\n   * This is the interval (in seconds) to execute the sync process\n   * between the connector's external cloud and HERE Tracking project.\n   * The maximum and at the same time default value for callback-type connectors is 900 seconds.\n   * The default value for other type of connectors is 3600 seconds and there is no maximum value set.\n   * @min 60\n   */\n    refreshIntervalS?: number,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/c2c/v4/connectors/{connectorId}/ext-devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Indicates if C2C should pull data for this device from external cloud at connector execution time. */\n enabled?: boolean, \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Other extra information related to the external device or shipment ID. */\n externalDeviceInfo?: hasuraSdk.JSONValue, \n/** Extra information regarding the device's provisioning status at HERE Tracking Cloud.\nIt also contains an error object if the device failed provisioning.\n */\n info?: hasuraSdk.JSONValue, \n/** Device id in TC. Either trackingId or shipmentId. */\n localDeviceId?: string, \n/** Current device status from HERE Tracking Cloud's perspective.\n\"provisioning\": The device is currently being provisioned at HERE Tracking Cloud. Its data still cannot be mirrored when at this state.\n\"provisioned\": The device has been provisioned successfully at HERE Tracking Cloud. Its data can be mirrored when at this state.\n\"failed\": The device has failed provisioning at HERE Tracking Cloud. Its data cannot be mirrored when at this state.\n */\n provisioning?: \"provisioning\" | \"provisioned\" | \"failed\", })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Indicates if C2C should pull data for this device from external cloud at connector execution time. */\n enabled?: boolean, \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Other extra information related to the external device or shipment ID. */\n externalDeviceInfo?: hasuraSdk.JSONValue, \n/** Extra information regarding the device's provisioning status at HERE Tracking Cloud.\nIt also contains an error object if the device failed provisioning.\n */\n info?: hasuraSdk.JSONValue, \n/** Device id in TC. Either trackingId or shipmentId. */\n localDeviceId?: string, \n/** Current device status from HERE Tracking Cloud's perspective.\n\"provisioning\": The device is currently being provisioned at HERE Tracking Cloud. Its data still cannot be mirrored when at this state.\n\"provisioned\": The device has been provisioned successfully at HERE Tracking Cloud. Its data can be mirrored when at this state.\n\"failed\": The device has failed provisioning at HERE Tracking Cloud. Its data cannot be mirrored when at this state.\n */\n provisioning?: \"provisioning\" | \"provisioned\" | \"failed\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Indicates if C2C should pull data for this device from external cloud at connector execution time. */\n enabled?: boolean, \n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string, \n/** Other extra information related to the external device or shipment ID. */\n externalDeviceInfo?: hasuraSdk.JSONValue, \n/** Extra information regarding the device's provisioning status at HERE Tracking Cloud.\nIt also contains an error object if the device failed provisioning.\n */\n info?: hasuraSdk.JSONValue, \n/** Device id in TC. Either trackingId or shipmentId. */\n localDeviceId?: string, \n/** Current device status from HERE Tracking Cloud's perspective.\n\"provisioning\": The device is currently being provisioned at HERE Tracking Cloud. Its data still cannot be mirrored when at this state.\n\"provisioned\": The device has been provisioned successfully at HERE Tracking Cloud. Its data can be mirrored when at this state.\n\"failed\": The device has failed provisioning at HERE Tracking Cloud. Its data cannot be mirrored when at this state.\n */\n provisioning?: \"provisioning\" | \"provisioned\" | \"failed\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.enabled": {
        "rendered": "\n/** Indicates if C2C should pull data for this device from external cloud at connector execution time. */\n enabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalDeviceId": {
        "rendered": "\n/** Identifier of the device on the external cloud. */\n externalDeviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalDeviceInfo": {
        "rendered": "\n/** Other extra information related to the external device or shipment ID. */\n externalDeviceInfo?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.info": {
        "rendered": "\n/** Extra information regarding the device's provisioning status at HERE Tracking Cloud.\nIt also contains an error object if the device failed provisioning.\n */\n info?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.localDeviceId": {
        "rendered": "\n/** Device id in TC. Either trackingId or shipmentId. */\n localDeviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.provisioning": {
        "rendered": "\n/** Current device status from HERE Tracking Cloud's perspective.\n\"provisioning\": The device is currently being provisioned at HERE Tracking Cloud. Its data still cannot be mirrored when at this state.\n\"provisioned\": The device has been provisioned successfully at HERE Tracking Cloud. Its data can be mirrored when at this state.\n\"failed\": The device has failed provisioning at HERE Tracking Cloud. Its data cannot be mirrored when at this state.\n */\n provisioning?: \"provisioning\" | \"provisioned\" | \"failed\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/connectors/{connectorId}/ext-devices": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: AddConnectorExternalDevices,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}/ext-devices-batch": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * @maxItems 100\n   * @minItems 1\n   */\n    externalDeviceIds?: (string)[],\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/c2c/v4/connectors/{connectorId}/ext-devices/{externalDeviceId}": {
    "query": {},
    "body": {},
    "path": {
      ".connectorId": {
        "rendered": "\n/** Identifier of the connector */\n connectorId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".externalDeviceId": {
        "rendered": "\n/** Identifier of the external device */\n externalDeviceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/drivers": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** If true, it indicates that this one is a self-provisioning callback driver. */\n autoProvisionCallbackDevices?: boolean, \n/** Identifier of the driver. */\n driverId?: string, \n/** Driver synchronization method */\n driverSyncMethod?: \"push\" | \"pull\" | \"none\", \n/** Driver type. */\n driverType?: \"tracker-device\" | \"transporter\" | \"internal\",  externalCloudInfoSchema?: ({ \n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean, \n/** Key of external cloud info parameter. */\n key?: string, \n/** Label of external cloud info parameter. */\n label?: string, })[], \n/** Name/description of the external cloud that the driver represents.\n */\n provider?: string,  strategy?: { \n/** Identifier of the manager. */\n managerId?: string, \n/** A strategy name */\n name?: string, }, \n/** Version number of the driver. */\n version?: number, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** If true, it indicates that this one is a self-provisioning callback driver. */\n autoProvisionCallbackDevices?: boolean, \n/** Identifier of the driver. */\n driverId?: string, \n/** Driver synchronization method */\n driverSyncMethod?: \"push\" | \"pull\" | \"none\", \n/** Driver type. */\n driverType?: \"tracker-device\" | \"transporter\" | \"internal\",  externalCloudInfoSchema?: ({ \n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean, \n/** Key of external cloud info parameter. */\n key?: string, \n/** Label of external cloud info parameter. */\n label?: string, })[], \n/** Name/description of the external cloud that the driver represents.\n */\n provider?: string,  strategy?: { \n/** Identifier of the manager. */\n managerId?: string, \n/** A strategy name */\n name?: string, }, \n/** Version number of the driver. */\n version?: number, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** If true, it indicates that this one is a self-provisioning callback driver. */\n autoProvisionCallbackDevices?: boolean, \n/** Identifier of the driver. */\n driverId?: string, \n/** Driver synchronization method */\n driverSyncMethod?: \"push\" | \"pull\" | \"none\", \n/** Driver type. */\n driverType?: \"tracker-device\" | \"transporter\" | \"internal\",  externalCloudInfoSchema?: ({ \n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean, \n/** Key of external cloud info parameter. */\n key?: string, \n/** Label of external cloud info parameter. */\n label?: string, })[], \n/** Name/description of the external cloud that the driver represents.\n */\n provider?: string,  strategy?: { \n/** Identifier of the manager. */\n managerId?: string, \n/** A strategy name */\n name?: string, }, \n/** Version number of the driver. */\n version?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.autoProvisionCallbackDevices": {
        "rendered": "\n/** If true, it indicates that this one is a self-provisioning callback driver. */\n autoProvisionCallbackDevices?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.driverId": {
        "rendered": "\n/** Identifier of the driver. */\n driverId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.driverSyncMethod": {
        "rendered": "\n/** Driver synchronization method */\n driverSyncMethod?: \"push\" | \"pull\" | \"none\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.driverType": {
        "rendered": "\n/** Driver type. */\n driverType?: \"tracker-device\" | \"transporter\" | \"internal\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.externalCloudInfoSchema": {
        "rendered": " externalCloudInfoSchema?: ({ \n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean, \n/** Key of external cloud info parameter. */\n key?: string, \n/** Label of external cloud info parameter. */\n label?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalCloudInfoSchema.__no_name": {
        "rendered": "{ \n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean, \n/** Key of external cloud info parameter. */\n key?: string, \n/** Label of external cloud info parameter. */\n label?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalCloudInfoSchema.__no_name.hidden": {
        "rendered": "\n/** Indicates whether cloud info parameter is hidden. */\n hidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalCloudInfoSchema.__no_name.key": {
        "rendered": "\n/** Key of external cloud info parameter. */\n key?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalCloudInfoSchema.__no_name.label": {
        "rendered": "\n/** Label of external cloud info parameter. */\n label?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.provider": {
        "rendered": "\n/** Name/description of the external cloud that the driver represents.\n */\n provider?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.strategy": {
        "rendered": " strategy?: { \n/** Identifier of the manager. */\n managerId?: string, \n/** A strategy name */\n name?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.strategy.managerId": {
        "rendered": "\n/** Identifier of the manager. */\n managerId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.strategy.name": {
        "rendered": "\n/** A strategy name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.version": {
        "rendered": "\n/** Version number of the driver. */\n version?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/c2c/v4/drivers/{driverId}/verify": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Data,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".driverId": {
        "rendered": "\n/** Identifier of the driver. */\n driverId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/c2c/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/device-associations/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/device-associations/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/device-associations/v2/{trackingId}/geofences": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string,  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Geofence ID */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/events/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  ruleId?: string | (string)[], \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.initialState": {
        "rendered": "\n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ( |  |  |  | { \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, } |  |  |  | {  eventSource?: \"shipmentSchedule\",  eventType?: \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** An ID of the segment where the schedule deviation was detected\n */\n segmentId?: string, \n/** Status of the segment. */\n segmentStatus?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/events/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/events/v3/statuses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  trackingId?: string | (string)[],  ruleId?: string | (string)[],  geofenceId?: string | (string)[], \n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.trackingId": {
        "rendered": " trackingId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.geofenceId": {
        "rendered": " geofenceId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.shipments": {
        "rendered": "\n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ( |  |  |  |  |  |  | { \n/** The event source: stock rule\n */\n eventSource?: \"stock\", \n/** The \"OVERSTOCK\" type - Events are triggered when the number of assets\nis over a maximum stock volume.\n\nThe \"UNDERSTOCK\" type - Events are triggered when the number of assets\nis under a minimum stock volume.\n\nThe \"NORMAL_VOLUME\" type - Events are triggered when the number of assets\nis between the minimum stock volume and the maximum stock volume.\n */\n eventType?: \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\", \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC. */\n timestamp?: number, } | {  eventSource?: \"shipmentSchedule\",  eventType?: \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** An ID of the segment where the schedule deviation was detected\n */\n segmentId?: string, \n/** Status of the segment. */\n segmentStatus?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/events/v3/statuses/deviceCounts": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Define whether the number of devices and shipments in each event state is calculated per rule ID or per rule type.\n */\n groupBy?: \"ruleId\" | \"eventSource\",  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  trackingId?: string | (string)[],  ruleId?: string | (string)[],  geofenceId?: string | (string)[], \n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.groupBy": {
        "rendered": "\n/** Define whether the number of devices and shipments in each event state is calculated per rule ID or per rule type.\n */\n groupBy?: \"ruleId\" | \"eventSource\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.trackingId": {
        "rendered": " trackingId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.geofenceId": {
        "rendered": " geofenceId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.shipments": {
        "rendered": "\n/** If `true`, the results will be limited to shipment event statuses only.\nIf `false`, the results will be limited to device event statuses only.\nIf not specified, the results will include both device and shipments event statuses.\n */\n shipments?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Number of devices currently in this event state.\n */\n FALSE_TO_TRUE?: number, \n/** Number of devices currently in this event state.\n */\n TRUE_TO_FALSE?: number,  eventSource?: \"attach\" | \"tamper\" | \"online\", } | { \n/** Number of devices currently in this event state.\n */\n ABOVE_RANGE?: number, \n/** Number of devices currently in this event state.\n */\n BELOW_RANGE?: number, \n/** Number of devices currently in this event state.\n */\n IN_RANGE?: number,  eventSource?: \"battery\" | \"humidity\" | \"pressure\" | \"temperature\", } | { \n/** Number of devices currently in this event state.\n */\n EVENT?: number,  eventSource?: \"acceleration\", } | { \n/** Number of devices currently in this event state.\n */\n INSIDE_GEOFENCE?: number, \n/** Number of devices currently in this event state.\n */\n OUTSIDE_GEOFENCE?: number,  eventSource?: \"geofence\", } | { \n/** Number of devices currently in this event state.\n */\n DWELLING_ENDED?: number, \n/** Number of devices currently in this event state.\n */\n DWELLING_STARTED?: number,  eventSource?: \"dwelling\", } | { \n/** Number of devices currently in this event state.\n */\n DETENTION_ENDED?: number, \n/** Number of devices currently in this event state.\n */\n DETENTION_STARTED?: number,  eventSource?: \"detention\", } | { \n/** Number of devices currently in this event state.\n */\n UNUTILIZED?: number, \n/** Number of devices currently in this event state.\n */\n UTILIZED?: number,  eventSource?: \"utilization\", } | { \n/** Number of devices currently in this event state.\n */\n SHIPMENT_DELAYED?: number, \n/** Number of devices currently in this event state.\n */\n SHIPMENT_EARLY?: number, \n/** Number of devices currently in this event state.\n */\n SHIPMENT_ON_TIME?: number,  eventSource?: \"shipmentSchedule\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/events/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/events/v3/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,  eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],  eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],  ruleId?: string | (string)[], \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.eventSource": {
        "rendered": " eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\" | (\"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.eventType": {
        "rendered": " eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\" | (\"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.ruleId": {
        "rendered": " ruleId?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.initialState": {
        "rendered": "\n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ( |  |  |  | { \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, } |  |  |  | {  eventSource?: \"shipmentSchedule\",  eventType?: \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** An ID of the segment where the schedule deviation was detected\n */\n segmentId?: string, \n/** Status of the segment. */\n segmentStatus?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/geofence-associations/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofence-associations/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofence-associations/v2/{geofenceId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/geofence-associations/v2/{geofenceId}/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/geofence-associations/v2/{geofenceId}/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** The floor of the indoor geofence */\n floor?: { \n/** ID of the venue, which is associated with the geofence */\n id?: string, } | \"null\", \n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[], \n/** Limit search to geofences intersecting the given bounding box. */\n bbox?: (number)[], \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.floor": {
        "rendered": "\n/** The floor of the indoor geofence */\n floor?: { \n/** ID of the venue, which is associated with the geofence */\n id?: string, } | \"null\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.type": {
        "rendered": "\n/** Type of a geofence */\n type?: (\"circle\" | \"polygon\" | \"poi\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.type.__no_name": {
        "rendered": "\"circle\" | \"polygon\" | \"poi\"",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.bbox": {
        "rendered": "\n/** Limit search to geofences intersecting the given bounding box. */\n bbox?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string,  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Geofence ID */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/geofences/v2": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"poi\",\n\n}),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Geofence ID */\n id?: string,  message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.id": {
        "rendered": "\n/** Geofence ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": " message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/geofences/v2/trainingTest": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The value must be within the past 24 hours from the current timestamp\n   */\n    after: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The value must not be greater than current timestamp\n   */\n    before: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id: string,\n\n} | {\n  /**\n   * WLAN access points\n   * @maxItems 128\n   * @minItems 2\n   */\n    wlan: ({\n  /** Frequency range (GHz). Allowed values are 2.4, 3.65, and 5. (Possible future values include 4.9, 5.9, 60, and 900.) */\n    band?: 2.4 | 3.65 | 5,\n  /**\n   * The MAC address of the WLAN access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. Note that if the SSID contains postfix '_nomap', the AP should not be used for positioning. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac: string,\n  /**\n   * Received signal level (dBm) at the terminal (Optional)\n   * @min -128\n   * @max 0\n   */\n    powrx: number,\n  /**\n   * Time of the wlan measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n\n}),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, },  reason?: string,  success?: boolean, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata": {
        "rendered": " metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.coordinate": {
        "rendered": "\n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.coordinate.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.coordinate.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.timestamp": {
        "rendered": "\n/** Training data timestamp */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.metadata.usedWlanApCount": {
        "rendered": "\n/** The number of WLAN access point used in training */\n usedWlanApCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reason": {
        "rendered": " reason?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.success": {
        "rendered": " success?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/geofences/v2/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/geofences/v2/{geofenceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string,  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Geofence ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.geofence": {
        "rendered": " geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string,  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, \n/** The geofence type. */\n type?: \"poi\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Geofence ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/geofences/v2/{geofenceId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /** An object that defines the area of a circular geofence */\n    definition: {\n  /** The coordinates of the center point of the circle. */\n    center: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * The radius of the circle in meters.\n   * @min 0\n   */\n    radius: number,\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"circle\",\n\n} | {\n  /** An object that defines the area of a polygonal geofence. */\n    definition: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /**\n   * An array of points that define the polygon. A minimum of three and a maximum of ten points is required.\n   * @maxItems 10\n   * @minItems 3\n   */\n    points: ({\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n})[],\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"polygon\",\n\n} | {\n  /** An object that defines the area of a POI geofence. */\n    definition?: {\n  /** The building associated with the geofence */\n    floor?: {\n  /**\n   * The building ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    id: string,\n  /**\n   * The floor of the geofence in integer format\n   * @min -999\n   * @max 999\n   */\n    level?: number,\n  /**\n   * The building name\n   * @minLength 1\n   * @maxLength 255\n   */\n    name: string,\n\n},\n  /** Details of the geofence location */\n    location?: {\n  /**\n   * Address\n   * @minLength 1\n   * @maxLength 255\n   */\n    address?: string,\n  /**\n   * Country\n   * @minLength 1\n   * @maxLength 255\n   */\n    country?: string,\n  /** Coordinates for visualization purposes */\n    position?: {\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n\n},\n  /**\n   * The room ID\n   * @minLength 1\n   * @maxLength 100\n   */\n    room?: string,\n\n},\n\n},\n  /**\n   * A description of the area that the geofence encloses and the purpose of the geofence.\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * A human-readable name of the geofence.\n   * @maxLength 50\n   */\n    name?: string,\n  /** The geofence type. */\n    type: \"poi\",\n\n}),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Geofence ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.geofence": {
        "rendered": " geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"poi\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Geofence ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/geofences/v2/{geofenceId}/poiTraining": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The value must be within the past 24 hours from the current timestamp\n   */\n    after: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * The value must not be greater than current timestamp\n   */\n    before: number,\n  /**\n   * This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id: string,\n\n} | {\n  /**\n   * WLAN access points\n   * @maxItems 128\n   * @minItems 2\n   */\n    wlan: ({\n  /** Frequency range (GHz). Allowed values are 2.4, 3.65, and 5. (Possible future values include 4.9, 5.9, 60, and 900.) */\n    band?: 2.4 | 3.65 | 5,\n  /**\n   * The MAC address of the WLAN access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. Note that if the SSID contains postfix '_nomap', the AP should not be used for positioning. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac: string,\n  /**\n   * Received signal level (dBm) at the terminal (Optional)\n   * @min -128\n   * @max 0\n   */\n    powrx: number,\n  /**\n   * Time of the wlan measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n\n}),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".geofenceId": {
        "rendered": "\n/** ID of the geofence */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, }, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus": {
        "rendered": " trainingStatus: {  metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, }, \n/** True if the POI geofence is trained */\n trained?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata": {
        "rendered": " metadata: { \n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Training data timestamp */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** The number of WLAN access point used in training */\n usedWlanApCount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.coordinate": {
        "rendered": "\n/** Training data position */\n coordinate: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.coordinate.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.coordinate.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.timestamp": {
        "rendered": "\n/** Training data timestamp */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.metadata.usedWlanApCount": {
        "rendered": "\n/** The number of WLAN access point used in training */\n usedWlanApCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trainingStatus.trained": {
        "rendered": "\n/** True if the POI geofence is trained */\n trained?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A filter containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.labels": {
        "rendered": "\n/** A filter containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.labels": {
        "rendered": "\n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}/keys": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  keys?: (string)[], }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.keys": {
        "rendered": " keys?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.keys.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}/keys/{key}/values": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  values?: (string)[], }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.values": {
        "rendered": " values?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.values.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/labels/v4/{resourceType}/{resourceId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Field names to filter a result object.\n */\n fields?: (string)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields": {
        "rendered": "\n/** Field names to filter a result object.\n */\n fields?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.fields.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": " resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": " resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.labels": {
        "rendered": "\n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/labels/v4/{resourceType}/{resourceId}/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * A map of key-value pairs where the key is the label key\n   * and the value is an array of label values.\n   */\n    labels: hasuraSdk.JSONValue,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.labels": {
        "rendered": "\n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}/{key}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/labels/v4/{resourceType}/{resourceId}/{key}/{value}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc. */\n resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": "\n/** The label key. */\n key: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".value": {
        "rendered": "\n/** The label value. */\n value: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/labels/v4/{resourceType}/{resourceId}/{key}/{value}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".resourceType": {
        "rendered": " resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".resourceId": {
        "rendered": " resourceId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".key": {
        "rendered": " key: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".value": {
        "rendered": " value: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue, \n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string, \n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.labels": {
        "rendered": "\n/** An object containing label key-value pairs. */\n labels?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.resourceId": {
        "rendered": "\n/** The resource ID, for example `trackingId`, `externalId`, `geofenceId`, etc.\n */\n resourceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType?: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/largedata/v4": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Large data object description\n   * @minLength 1\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Large data object name\n   * @minLength 1\n   * @maxLength 50\n   */\n    name?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Large data object identifier */\n dataId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/devices/{trackingId}/metadata": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Time when data upload was completed */\n completedAt?: string, \n/** Time when data upload was created */\n createdAt?: string, \n/** Large data object identifier */\n dataId?: string, \n/** Large data object description */\n description?: string, \n/** Large data object name */\n name?: string, \n/** Number of parts */\n numberOfParts?: number, \n/** Total size of the data in bytes */\n size?: number, \n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\", \n/** ID of the device that produced this data */\n trackingId?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Time when data upload was completed */\n completedAt?: string, \n/** Time when data upload was created */\n createdAt?: string, \n/** Large data object identifier */\n dataId?: string, \n/** Large data object description */\n description?: string, \n/** Large data object name */\n name?: string, \n/** Number of parts */\n numberOfParts?: number, \n/** Total size of the data in bytes */\n size?: number, \n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\", \n/** ID of the device that produced this data */\n trackingId?: string, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Time when data upload was completed */\n completedAt?: string, \n/** Time when data upload was created */\n createdAt?: string, \n/** Large data object identifier */\n dataId?: string, \n/** Large data object description */\n description?: string, \n/** Large data object name */\n name?: string, \n/** Number of parts */\n numberOfParts?: number, \n/** Total size of the data in bytes */\n size?: number, \n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\", \n/** ID of the device that produced this data */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.completedAt": {
        "rendered": "\n/** Time when data upload was completed */\n completedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.createdAt": {
        "rendered": "\n/** Time when data upload was created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.description": {
        "rendered": "\n/** Large data object description */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** Large data object name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.numberOfParts": {
        "rendered": "\n/** Number of parts */\n numberOfParts?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.size": {
        "rendered": "\n/** Total size of the data in bytes */\n size?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.status": {
        "rendered": "\n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.trackingId": {
        "rendered": "\n/** ID of the device that produced this data */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/largedata/v4/{dataId}": {
    "query": {},
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/largedata/v4/{dataId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Flag telling if the data upload should be aborted */\n abort?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.abort": {
        "rendered": "\n/** Flag telling if the data upload should be aborted */\n abort?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/{dataId}/data": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Byte offset to the data to be downloaded (inclusive, starts at zero) */\n offset?: number, \n/** Number of bytes of the data to download */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.offset": {
        "rendered": "\n/** Byte offset to the data to be downloaded (inclusive, starts at zero) */\n offset?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** Number of bytes of the data to download */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "File",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/{dataId}/metadata": {
    "query": {},
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Time when data upload was completed */\n completedAt?: string, \n/** Time when data upload was created */\n createdAt?: string, \n/** Large data object identifier */\n dataId?: string, \n/** Large data object description */\n description?: string, \n/** Large data object name */\n name?: string, \n/** Number of parts */\n numberOfParts?: number, \n/** Total size of the data in bytes */\n size?: number, \n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\", \n/** ID of the device that produced this data */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.completedAt": {
        "rendered": "\n/** Time when data upload was completed */\n completedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.createdAt": {
        "rendered": "\n/** Time when data upload was created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Large data object description */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Large data object name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.numberOfParts": {
        "rendered": "\n/** Number of parts */\n numberOfParts?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.size": {
        "rendered": "\n/** Total size of the data in bytes */\n size?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** State of the data upload */\n status?: \"preparing\" | \"pending\" | \"ongoing\" | \"completed\" | \"failed\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** ID of the device that produced this data */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/largedata/v4/{dataId}/parts": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string, \n/** Part number for a large data object */\n partNumber?: number, \n/** Part size in bytes */\n size?: number, \n/** State of the data part upload */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\", })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string, \n/** Part number for a large data object */\n partNumber?: number, \n/** Part size in bytes */\n size?: number, \n/** State of the data part upload */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string, \n/** Part number for a large data object */\n partNumber?: number, \n/** Part size in bytes */\n size?: number, \n/** State of the data part upload */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.md5": {
        "rendered": "\n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.partNumber": {
        "rendered": "\n/** Part number for a large data object */\n partNumber?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.size": {
        "rendered": "\n/** Part size in bytes */\n size?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.status": {
        "rendered": "\n/** State of the data part upload */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"failed\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/largedata/v4/{dataId}/parts/{partNumber}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.md5": {
        "rendered": "\n/** MD5 digest of the data (hexadecimal representation) */\n md5?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: File,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".dataId": {
        "rendered": "\n/** Large data object identifier */\n dataId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".partNumber": {
        "rendered": "\n/** Part number for a large data object */\n partNumber: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The number of items to return per page */\n limit?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Filter locations by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Filter locations by street address. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n street?: string, \n/** Filter locations by city. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n city?: string, \n/** Filter locations by postal code. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n postalCode?: string, \n/** Filter locations by state. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n state?: string, \n/** Filter locations by country. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n country?: string, \n/** Filter locations by locationId wildcard.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n locationId?: string, \n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'steet:desc' sort by street in descending order.\nAllowed fields to sort by:\nlocationId, name, street, city, postalCode, state, country.\n */\n sort?: string | (string)[], \n/** External location id in external cloud */\n externalLocationId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter locations by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.street": {
        "rendered": "\n/** Filter locations by street address. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n street?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.city": {
        "rendered": "\n/** Filter locations by city. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n city?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.postalCode": {
        "rendered": "\n/** Filter locations by postal code. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n postalCode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.state": {
        "rendered": "\n/** Filter locations by state. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n state?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.country": {
        "rendered": "\n/** Filter locations by country. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n country?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.locationId": {
        "rendered": "\n/** Filter locations by locationId wildcard.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'steet:desc' sort by street in descending order.\nAllowed fields to sort by:\nlocationId, name, street, city, postalCode, state, country.\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.externalLocationId": {
        "rendered": "\n/** External location id in external cloud */\n externalLocationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, }, \n/** Description of the location. */\n description?: string, \n/** External location id in external cloud */\n externalLocationId?: string, \n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string, \n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Location ID */\n locationId?: string, \n/** Name of the location. */\n name?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Total number of locations for query */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, }, \n/** Description of the location. */\n description?: string, \n/** External location id in external cloud */\n externalLocationId?: string, \n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string, \n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Location ID */\n locationId?: string, \n/** Name of the location. */\n name?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, }, \n/** Description of the location. */\n description?: string, \n/** External location id in external cloud */\n externalLocationId?: string, \n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string, \n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Location ID */\n locationId?: string, \n/** Name of the location. */\n name?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address": {
        "rendered": "\n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address.city": {
        "rendered": "\n/** City */\n city?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address.country": {
        "rendered": "\n/** Country */\n country?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address.postalCode": {
        "rendered": "\n/** Postal code */\n postalCode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address.state": {
        "rendered": "\n/** State */\n state?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.address.street": {
        "rendered": "\n/** Street address */\n street?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.description": {
        "rendered": "\n/** Description of the location. */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalLocationId": {
        "rendered": "\n/** External location id in external cloud */\n externalLocationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.geofenceId": {
        "rendered": "\n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.location": {
        "rendered": "\n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.location.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.location.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.locationId": {
        "rendered": "\n/** Location ID */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** Name of the location. */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** Total number of locations for query */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/locations/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: CreateLocationBody,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Location ID */\n locationId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.locationId": {
        "rendered": "\n/** Location ID */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/locations/v4/{locationId}": {
    "query": {},
    "body": {},
    "path": {
      ".locationId": {
        "rendered": "\n/** Location ID */\n locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/locations/v4/{locationId}": {
    "query": {},
    "body": {},
    "path": {
      ".locationId": {
        "rendered": " locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, }, \n/** Description of the location. */\n description?: string, \n/** External location id in external cloud */\n externalLocationId?: string, \n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string, \n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Location ID */\n locationId?: string, \n/** Name of the location. */\n name?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address": {
        "rendered": "\n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.city": {
        "rendered": "\n/** City */\n city?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.country": {
        "rendered": "\n/** Country */\n country?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.postalCode": {
        "rendered": "\n/** Postal code */\n postalCode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.state": {
        "rendered": "\n/** State */\n state?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.street": {
        "rendered": "\n/** Street address */\n street?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the location. */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.externalLocationId": {
        "rendered": "\n/** External location id in external cloud */\n externalLocationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.geofenceId": {
        "rendered": "\n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location": {
        "rendered": "\n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.locationId": {
        "rendered": "\n/** Location ID */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the location. */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/locations/v4/{locationId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: CreateLocationBody,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".locationId": {
        "rendered": " locationId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, }, \n/** Description of the location. */\n description?: string, \n/** External location id in external cloud */\n externalLocationId?: string, \n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string, \n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** Location ID */\n locationId?: string, \n/** Name of the location. */\n name?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address": {
        "rendered": "\n/** Location address. */\n address?: { \n/** City */\n city?: string, \n/** Country */\n country?: string, \n/** Postal code */\n postalCode?: string, \n/** State */\n state?: string, \n/** Street address */\n street?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.city": {
        "rendered": "\n/** City */\n city?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.country": {
        "rendered": "\n/** Country */\n country?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.postalCode": {
        "rendered": "\n/** Postal code */\n postalCode?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.state": {
        "rendered": "\n/** State */\n state?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.address.street": {
        "rendered": "\n/** Street address */\n street?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the location. */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.externalLocationId": {
        "rendered": "\n/** External location id in external cloud */\n externalLocationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.geofenceId": {
        "rendered": "\n/** Optional geofenceId associated with the location. Has to match an existing geofenceId. */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location": {
        "rendered": "\n/** Location coordinates. */\n location: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.location.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.locationId": {
        "rendered": "\n/** Location ID */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the location. */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/devices/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Geofences,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Data,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/geofences/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Geofences,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Geofence ID */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {},
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Geofence ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Geofence ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/geofences/{geofenceId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Data,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".geofenceId": {
        "rendered": " geofenceId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Geofence ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Geofence ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/metadata/v2/sensorRules/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Geofences,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Sensor rule ID */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Sensor rule ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Sensor rule ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/metadata/v2/sensorRules/{sensorRuleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Data,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue, \n/** Sensor rule ID */\n id?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.data": {
        "rendered": "\n/** Metadata JSON object\n */\n data?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.id": {
        "rendered": "\n/** Sensor rule ID */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/metadata/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/notifications/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {},
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {},
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, }, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.registration": {
        "rendered": " registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/notifications/v3/registration/{channelId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The type of notification channel. */\n    channelType: \"webhook\" | \"email\" | \"browserPull\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /** A webhook URL that will receive notifications POST requests. */\n    url?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".channelId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n channelId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, }, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.registration": {
        "rendered": " registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Filter result by channelType.\n\nExample: `channelType[]=webhook`, `channelType[]=browserPull,email`\n */\n channelType?: (\"webhook\" | \"email\" | \"browserPull\")[], \n/** The HERE Account ID of a user. */\n userId?: string, \n/** Filters by `emailBounce` property. When set to `true`, returns the email channels which are not active anymore\ndue to email bounce. When set to `false`, returns all the channels which are active (and not only email channels).\n */\n emailBounce?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channelType": {
        "rendered": "\n/** Filter result by channelType.\n\nExample: `channelType[]=webhook`, `channelType[]=browserPull,email`\n */\n channelType?: (\"webhook\" | \"email\" | \"browserPull\")[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.channelType.__no_name": {
        "rendered": "\"webhook\" | \"email\" | \"browserPull\"",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.emailBounce": {
        "rendered": "\n/** Filters by `emailBounce` property. When set to `true`, returns the email channels which are not active anymore\ndue to email bounce. When set to `false`, returns all the channels which are active (and not only email channels).\n */\n emailBounce?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/notifications/v3/registrations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** The HERE Account ID of a user. */\n userId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The type of notification channel. */\n    channelType: \"webhook\" | \"email\" | \"browserPull\",\n  /** The event source rule type. */\n    eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\",\n  /**\n   * Type of the event.\n   * \n   * An event is created every time an associated rule or geofence is triggered by a device ingestion.\n   * The event type depends on the data the device sends.\n   * \n   * Sensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\n   * generate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\n   * This produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n   * \n   * Sensors that report boolean data (such as attach and tamper sensors), generate events when the device \n   * transitions from one state to another, either from `false` to `true` or vice versa.\n   * This produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\n   * The same event types are also generated by the online rule when the device state changes from `offline` \n   * (when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \n   * or vice versa.\n   * \n   * The acceleration sensor generates events whenever the reported sensor reading \n   * crosses the acceleration threshold (for example, when the device was dropped).\n   * This produces events of the type EVENT. \n   * Such events are stateless.\n   * \n   * Events of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\n   * a geofence associated with the device.\n   * \n   * Events of DWELLING_STARTED type are generated when the device has\n   * stayed inside an associated geofence for longer than the threshold duration. \n   * DWELLING_ENDED type events are generated when dwelling of the device has ended.\n   * \n   * Events of DETENTION_STARTED type are generated when the device has been\n   * stationary for longer than the threshold duration, regardless whether the device is inside \n   * or outside of any geofence. \n   * DETENTION_ENDED type events will be generated when the device starts moving again.\n   * \n   * Events of UNUTILIZED type are generated when the device has been stationary for longer than the\n   * threshold duration.\n   * UTILIZED type events are generated when the device starts moving again after having been stationary.\n   * \n   * Events of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\n   * inside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n   * \n   * Events of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\n   * is too early, on time or delayed.\n   */\n    eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\",\n  /**\n   * Events with the `initialState` property set as `true` are generated when the rule is \n   * evaluated for the first time. It indicates the fact that this is the initial evaluation \n   * state, which would serve as a starting point for the subsequent rule evaluations.\n   * The rest of the rule events would represent a transition of a device or a shipment or \n   * a geofence from one state to another and their `initialState` property will be set to `false`.\n   */\n    initialState?: boolean,\n  /**\n   * Must be a valid UUIDv4.\n   * @format uuid\n   */\n    ruleId?: string,\n  /** A webhook URL that will receive notifications POST requests. */\n    url?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{  registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, }, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.registration": {
        "rendered": " registration?: { \n/** channel ID\n */\n channelId?: string,  channelType?: \"webhook\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** A URL for webhook notifications capable of receiving POST requests.\n */\n url?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"email\", \n/** emailBounce property is set `true` if emails to the user's email address bounce. For those\nemails the notifications can no longer be sent. Such channel cannot be re-activated but it needs\nto be deleted and created again after the email has been changed in HERE Account.\n */\n emailBounce?: boolean, \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, } | { \n/** channel ID\n */\n channelId?: string,  channelType?: \"browserPull\", \n/** The event source rule type.\n */\n eventSource?: \"attach\" | \"battery\" | \"geofence\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\" | \"dwelling\" | \"stock\" | \"detention\" | \"utilization\" | \"online\" | \"shipmentSchedule\", \n/** Type of the event.\n\nAn event is created every time an associated rule or geofence is triggered by a device ingestion.\nThe event type depends on the data the device sends.\n\nSensors that report numerical data (such as battery, humidity, pressure and temperature sensors),\ngenerate an event when the reported sensor reading of the device goes in or out of range, which is configured in the rule.\nThis produces events of BELOW_RANGE, IN_RANGE and ABOVE_RANGE types.\n\nSensors that report boolean data (such as attach and tamper sensors), generate events when the device \ntransitions from one state to another, either from `false` to `true` or vice versa.\nThis produces events of FALSE_TO_TRUE and TRUE_TO_FALSE types.\nThe same event types are also generated by the online rule when the device state changes from `offline` \n(when the device has stopped ingesting data) to `online` (when the device data ingestion has resumed) \nor vice versa.\n\nThe acceleration sensor generates events whenever the reported sensor reading \ncrosses the acceleration threshold (for example, when the device was dropped).\nThis produces events of the type EVENT. \nSuch events are stateless.\n\nEvents of INSIDE_GEOFENCE and OUTSIDE_GEOFENCE types are generated when the device enters or exits\na geofence associated with the device.\n\nEvents of DWELLING_STARTED type are generated when the device has\nstayed inside an associated geofence for longer than the threshold duration. \nDWELLING_ENDED type events are generated when dwelling of the device has ended.\n\nEvents of DETENTION_STARTED type are generated when the device has been\nstationary for longer than the threshold duration, regardless whether the device is inside \nor outside of any geofence. \nDETENTION_ENDED type events will be generated when the device starts moving again.\n\nEvents of UNUTILIZED type are generated when the device has been stationary for longer than the\nthreshold duration.\nUTILIZED type events are generated when the device starts moving again after having been stationary.\n\nEvents of OVERSTOCK, NORMAL_VOLUME and UNDERSTOCK types are generated when the number of assets\ninside a geofence crosses the `minVolume` and `maxVolume` thresholds of an associated stock rule.\n\nEvents of SHIPMENT_EARLY, SHIPMENT_ON_TIME and SHIPMENT_DELAYED types are generated when a shipment\nis too early, on time or delayed.\n */\n eventType?: \"BELOW_RANGE\" | \"IN_RANGE\" | \"ABOVE_RANGE\" | \"FALSE_TO_TRUE\" | \"TRUE_TO_FALSE\" | \"EVENT\" | \"INSIDE_GEOFENCE\" | \"OUTSIDE_GEOFENCE\" | \"OVERSTOCK\" | \"NORMAL_VOLUME\" | \"UNDERSTOCK\" | \"DWELLING_STARTED\" | \"DWELLING_ENDED\" | \"DETENTION_STARTED\" | \"DETENTION_ENDED\" | \"UTILIZED\" | \"UNUTILIZED\" | \"SHIPMENT_EARLY\" | \"SHIPMENT_ON_TIME\" | \"SHIPMENT_DELAYED\", \n/** Events with the `initialState` property set as `true` are generated when the rule is \nevaluated for the first time. It indicates the fact that this is the initial evaluation \nstate, which would serve as a starting point for the subsequent rule evaluations.\nThe rest of the rule events would represent a transition of a device or a shipment or \na geofence from one state to another and their `initialState` property will be set to `false`.\n */\n initialState?: boolean, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, \n/** User Id.\n */\n userId?: string, },",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/notifications/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/registry/v2/devices/{deviceOrExternalId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data?: {\n  /**\n   * (Deprecated) Application identifier which specifies device owner's application to which the device is associated with.\n   * @minLength 8\n   */\n    ownerAppId?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".deviceOrExternalId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceOrExternalId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/licenses": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Start of returned block from a list. Default 0. */\n startIndex?: number, \n/** End of returned block from a list. Default 100. */\n endIndex?: number,  projectIds?: string | (string)[],  projectTypes?: \"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\" | (\"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\")[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.startIndex": {
        "rendered": "\n/** Start of returned block from a list. Default 0. */\n startIndex?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endIndex": {
        "rendered": "\n/** End of returned block from a list. Default 100. */\n endIndex?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectIds": {
        "rendered": " projectIds?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectTypes": {
        "rendered": " projectTypes?: \"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\" | (\"indoor\" | \"tracking\" | \"trackingAzure\" | \"lastmile\")[],",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** End of returned block from a list. Default 100. */\n end?: number, \n/** Developer plan licenses for HERE Tracking */\n licenses?: ({ \n/** A project application id. */\n appId?: string, \n/** True if a license has expired. */\n expired?: boolean, \n/** A license expiration date. */\n expiryDate?: string, \n/** Features supported by the license plan. */\n features?: (string)[], \n/** Project description */\n projectDescription?: string, \n/** Project HRN */\n projectHrn?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Project name */\n projectName?: string,  quota?: { \n/** The number of devices that can still be provisioned. */\n provisioning?: number, }, \n/** Platform application realm. */\n realm?: string, \n/** A license type. */\n type?: \"evaluation\" | \"commercial\" | \"platformApp\" | \"platform\", })[], \n/** Start of returned block from a list. Default 0. */\n start?: number, \n/** Total number of elements that can be received with current query. */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.end": {
        "rendered": "\n/** End of returned block from a list. Default 100. */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses": {
        "rendered": "\n/** Developer plan licenses for HERE Tracking */\n licenses?: ({ \n/** A project application id. */\n appId?: string, \n/** True if a license has expired. */\n expired?: boolean, \n/** A license expiration date. */\n expiryDate?: string, \n/** Features supported by the license plan. */\n features?: (string)[], \n/** Project description */\n projectDescription?: string, \n/** Project HRN */\n projectHrn?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Project name */\n projectName?: string,  quota?: { \n/** The number of devices that can still be provisioned. */\n provisioning?: number, }, \n/** Platform application realm. */\n realm?: string, \n/** A license type. */\n type?: \"evaluation\" | \"commercial\" | \"platformApp\" | \"platform\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.licenses.__no_name": {
        "rendered": "{ \n/** A project application id. */\n appId?: string, \n/** True if a license has expired. */\n expired?: boolean, \n/** A license expiration date. */\n expiryDate?: string, \n/** Features supported by the license plan. */\n features?: (string)[], \n/** Project description */\n projectDescription?: string, \n/** Project HRN */\n projectHrn?: string, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** Project name */\n projectName?: string,  quota?: { \n/** The number of devices that can still be provisioned. */\n provisioning?: number, }, \n/** Platform application realm. */\n realm?: string, \n/** A license type. */\n type?: \"evaluation\" | \"commercial\" | \"platformApp\" | \"platform\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.licenses.__no_name.appId": {
        "rendered": "\n/** A project application id. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.expired": {
        "rendered": "\n/** True if a license has expired. */\n expired?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.expiryDate": {
        "rendered": "\n/** A license expiration date. */\n expiryDate?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.features": {
        "rendered": "\n/** Features supported by the license plan. */\n features?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.features.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.projectDescription": {
        "rendered": "\n/** Project description */\n projectDescription?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.projectHrn": {
        "rendered": "\n/** Project HRN */\n projectHrn?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.projectName": {
        "rendered": "\n/** Project name */\n projectName?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.quota": {
        "rendered": " quota?: { \n/** The number of devices that can still be provisioned. */\n provisioning?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.quota.provisioning": {
        "rendered": "\n/** The number of devices that can still be provisioned. */\n provisioning?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.realm": {
        "rendered": "\n/** Platform application realm. */\n realm?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.licenses.__no_name.type": {
        "rendered": "\n/** A license type. */\n type?: \"evaluation\" | \"commercial\" | \"platformApp\" | \"platform\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.start": {
        "rendered": "\n/** Start of returned block from a list. Default 0. */\n start?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** Total number of elements that can be received with current query. */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{appId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** The provisioned device ID */\n deviceId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** Provisioning time in milliseconds elapsed since 1 January 1970 00:00:00 UTC. */\n timestamp?: number, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/registry/v2/{appId}/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, the licenses are created and devices are immediately claimed by the same user. Supported only with `deviceId` array in body, and not with the `count` parameter. */\n autoclaim?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.autoclaim": {
        "rendered": "\n/** If set to `true`, the licenses are created and devices are immediately claimed by the same user. Supported only with `deviceId` array in body, and not with the `count` parameter. */\n autoclaim?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /**\n   * Number of device credentials requested\n   * @min 1\n   * @max 1000\n   */\n    count: number,\n\n} | {\n  /**\n   * @maxItems 100\n   * @minItems 1\n   */\n    devices: ({\n  /**\n   * The external ID for the device\n   * @minLength 1\n   * @maxLength 50\n   */\n    id?: string,\n\n})[],\n\n}),",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The batch job ID, needed for subsequent requests. Valid for 24 hours. */\n jobId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.jobId": {
        "rendered": "\n/** The batch job ID, needed for subsequent requests. Valid for 24 hours. */\n jobId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{appId}/licenseCount": {
    "query": {},
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of created device licenses for given `appId` */\n count?: number, \n/** Timestamp of the last `count` update */\n updatedAt?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.count": {
        "rendered": "\n/** The number of created device licenses for given `appId` */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.updatedAt": {
        "rendered": "\n/** Timestamp of the last `count` update */\n updatedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/registry/v2/{appId}/one-device": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, the device license is created and the device is immediately claimed by the same user. */\n autoclaim?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.autoclaim": {
        "rendered": "\n/** If set to `true`, the device license is created and the device is immediately claimed by the same user. */\n autoclaim?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".appId": {
        "rendered": "\n/** Project appId of the user's project */\n appId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A newly created device ID. */\n deviceId?: string, \n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.deviceId": {
        "rendered": "\n/** A newly created device ID. */\n deviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.deviceSecret": {
        "rendered": "\n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{jobId}/results": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** An asynchronous job ID. UUID v.4.0. */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** A newly created device ID. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceId?: string, \n/** A newly created device secret. A physical device license is a `deviceId` and `deviceSecret` credential pair. */\n deviceSecret?: string, \n/** Virtual device external ID, only present when provisioning virtual devices. */\n externalId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[],  errors?: ({  error: { \n/** An HTTP status code */\n code?: number,  \n/** An HTTP error description */\n error?: string, \n/** An error ID that allows you to trace the error details */\n id?: string, \n/** Descriptive text that explains the error */\n message?: string, }, \n/** ID for the device to which error occurred */\n id?: string, })[], }",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{jobId}/status": {
    "query": {},
    "body": {},
    "path": {
      ".jobId": {
        "rendered": "\n/** An asynchronous job ID. UUID v.4.0. */\n jobId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The percentage of the job that was completed at the time of the request. */\n percent?: number, \n/** The status of the batch job. When the job status is `complete`, use the `/registry/v2/{jobId}/results` endpoint to get the device licenses */\n status?: \"started\" | \"complete\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.percent": {
        "rendered": "\n/** The percentage of the job that was completed at the time of the request. */\n percent?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** The status of the batch job. When the job status is `complete`, use the `/registry/v2/{jobId}/results` endpoint to get the device licenses */\n status?: \"started\" | \"complete\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/registry/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/registry/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Device ID of a provisioned device */\n deviceId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.deviceId": {
        "rendered": "\n/** Device ID of a provisioned device */\n deviceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/registry/v4/resources/{resourceType}/find": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * @maxItems 10\n   * @minItems 1\n   */\n    filters: (({\n    key: \"onlyShipments\" | \"onlyShipmentPlans\",\n\n} | {\n  /**\n   * aliasType|labelKey\n   * @minLength 1\n   */\n    key: string,\n    storage: \"aliases\" | \"labels\",\n  /**\n   * value with wildcards\n   * @minLength 1\n   */\n    value: string,\n\n}))[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".resourceType": {
        "rendered": "\n/** The resource type, for example \"device\", \"geofence\". */\n resourceType: \"device\" | \"geofence\" | \"location\" | \"rule\" | \"sensorRule\" | \"shipment\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** number of items returned in the response */\n count?: number, \n/** Array of matching resource ids */\n items?: ({  resourceId?: string, })[], \n/** number of items as specified in request */\n limit?: number, \n/** token to fetch the next page */\n nextPageToken?: string, \n/** total number of items at the moment when the first page was requested */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.count": {
        "rendered": "\n/** number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": "\n/** Array of matching resource ids */\n items?: ({  resourceId?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name": {
        "rendered": "{  resourceId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.resourceId": {
        "rendered": " resourceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** token to fetch the next page */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** total number of items at the moment when the first page was requested */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/reports/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * End date of the report period. The end date should be greater than the start date.\n   * @format date-time\n   */\n    end: string,\n  /**\n   * Rule ID of a dwelling or detention rule.\n   * @format uuid\n   */\n    ruleId: string,\n  /**\n   * Start date and time of the report period. When getting reports per interval, this timestamp\n   * defines the start of the interval day, week or month.\n   * \n   * For example, to make the report week start on Monday midnight 1st March 2021 in timezone UTC+1:00,\n   * set the `start` parameter to be `2021-02-28T23:00:00.000Z` (GMT). Now when getting interval reports,\n   * the first week would contain data between `2021-02-28T23:00:00.000Z` and `2021-03-07T23:00:00.000Z` (GMT).\n   * @format date-time\n   */\n    start: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Report ID */\n reportId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reportId": {
        "rendered": "\n/** Report ID */\n reportId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/reports/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/reports/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/reports/v4/{reportId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Defines the report metric to be calculated. \nThe metrics are always calculated over a time period, either over each interval specified \nby the `interval` parameter (for example, over a week) or over the whole time period of the report.\n\n* `duration`: duration of the event\n  * _\"The asset dwelled for 45 hours during week 2. It was in detention for 4 hours.\"_\n* `occurrence`: total number of the event occurrences\n  * _\"During week 3, the asset was in detention 2 times. During the past month it had 7 individual dwelling periods.\"_\n* `day`: the number of days the event lasted\n  * _\"The asset was utilized for 3 days during week 4.\"_\n* `asset`: the number of assets that generated the event\n  * _\"On Monday 5 assets were in detention. On Tuesday 16 assets were in detention.\"_\n */\n measure?: \"duration\" | \"occurrence\" | \"day\" | \"asset\", \n/** Defines an interval, which can be a day, a week or a month, that will be used to group \nthe report results.\n\nWhen the `interval` parameter is provided, the response will be an array of `timestamp`-`value` \npairs where the `timestamp` defines the beginning of the interval and the `value` is the specified \nreport metric's value calculated over the interval time.\n */\n interval?: \"day\" | \"week\" | \"month\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Defines whether the report metrics, such as cumulative or average, \nare calculated per asset or per geofence.\n\nThe parameter can have a value 'geofence' only with reports created for a dwelling rule.\n\nTo get a report on how many times on average assets were in detention during each time interval,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a detention rule\n* `groupBy`: 'asset'\n* `method`: 'average'\n* `measure`: 'occurrence'\n\nTo get a report on how long all assets dwelled inside each geofence during the report period,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'geofence'\n* `measure`: 'duration'\n\nTo get a report on how long each asset dwelled (inside any geofence) during the report period, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'asset'\n* `measure`: 'duration'\n */\n groupBy?: \"asset\" | \"geofence\", \n/** Defines the calculation method. \nThe parameter `method` can only be provided along with `interval`.\n\nThe parameter value can be `percentage` only when `measure` is 'asset'.\n\nFor example, to get a report on percentage of all assets that were in use during each week,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'week'\n* `method`: 'percentage'\n* `measure`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'duration' or 'occurrence',\nthe `groupBy` parameter needs to be provided also. \nFor example, to get a report on how long all assets dwelled in total in the specified geofence during\neach week, create a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `geofenceId`: ID of a geofence\n* `interval`: 'week'\n* `method`: 'cumulative'\n* `measure`: 'duration'\n* `groupBy`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'day',\nthe `groupBy` parameter is automatically set to 'asset'. \nFor example, to get a report on how many days on average assets were in use during each month, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'month'\n* `method`: 'average'\n* `measure`: 'day'\n* `groupBy`: 'asset'\n */\n method?: \"average\" | \"cumulative\" | \"percentage\", \n/** Defines how the items are sorted.\n* If `interval` is provided, the default is `sort`=`timestamp:asc`\n* If `interval` is not provided, the default is `sort`=`value:desc`\n */\n sort?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.measure": {
        "rendered": "\n/** Defines the report metric to be calculated. \nThe metrics are always calculated over a time period, either over each interval specified \nby the `interval` parameter (for example, over a week) or over the whole time period of the report.\n\n* `duration`: duration of the event\n  * _\"The asset dwelled for 45 hours during week 2. It was in detention for 4 hours.\"_\n* `occurrence`: total number of the event occurrences\n  * _\"During week 3, the asset was in detention 2 times. During the past month it had 7 individual dwelling periods.\"_\n* `day`: the number of days the event lasted\n  * _\"The asset was utilized for 3 days during week 4.\"_\n* `asset`: the number of assets that generated the event\n  * _\"On Monday 5 assets were in detention. On Tuesday 16 assets were in detention.\"_\n */\n measure?: \"duration\" | \"occurrence\" | \"day\" | \"asset\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.interval": {
        "rendered": "\n/** Defines an interval, which can be a day, a week or a month, that will be used to group \nthe report results.\n\nWhen the `interval` parameter is provided, the response will be an array of `timestamp`-`value` \npairs where the `timestamp` defines the beginning of the interval and the `value` is the specified \nreport metric's value calculated over the interval time.\n */\n interval?: \"day\" | \"week\" | \"month\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.geofenceId": {
        "rendered": "\n/** Geofence ID */\n geofenceId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.groupBy": {
        "rendered": "\n/** Defines whether the report metrics, such as cumulative or average, \nare calculated per asset or per geofence.\n\nThe parameter can have a value 'geofence' only with reports created for a dwelling rule.\n\nTo get a report on how many times on average assets were in detention during each time interval,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a detention rule\n* `groupBy`: 'asset'\n* `method`: 'average'\n* `measure`: 'occurrence'\n\nTo get a report on how long all assets dwelled inside each geofence during the report period,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'geofence'\n* `measure`: 'duration'\n\nTo get a report on how long each asset dwelled (inside any geofence) during the report period, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `groupBy`: 'asset'\n* `measure`: 'duration'\n */\n groupBy?: \"asset\" | \"geofence\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.method": {
        "rendered": "\n/** Defines the calculation method. \nThe parameter `method` can only be provided along with `interval`.\n\nThe parameter value can be `percentage` only when `measure` is 'asset'.\n\nFor example, to get a report on percentage of all assets that were in use during each week,\ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'week'\n* `method`: 'percentage'\n* `measure`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'duration' or 'occurrence',\nthe `groupBy` parameter needs to be provided also. \nFor example, to get a report on how long all assets dwelled in total in the specified geofence during\neach week, create a request specifying the following:\n* `reportId`: ID of a report created for a dwelling rule\n* `geofenceId`: ID of a geofence\n* `interval`: 'week'\n* `method`: 'cumulative'\n* `measure`: 'duration'\n* `groupBy`: 'asset'\n\nWhen `method` is set to 'cumulative' or 'average' and `measure` is set to 'day',\nthe `groupBy` parameter is automatically set to 'asset'. \nFor example, to get a report on how many days on average assets were in use during each month, \ncreate a request specifying the following:\n* `reportId`: ID of a report created for a utilization rule\n* `interval`: 'month'\n* `method`: 'average'\n* `measure`: 'day'\n* `groupBy`: 'asset'\n */\n method?: \"average\" | \"cumulative\" | \"percentage\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.sort": {
        "rendered": "\n/** Defines how the items are sorted.\n* If `interval` is provided, the default is `sort`=`timestamp:asc`\n* If `interval` is not provided, the default is `sort`=`value:desc`\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".reportId": {
        "rendered": "\n/** Report ID */\n reportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Timestamp of the beginning of the interval\n */\n timestamp?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Tracking ID on which the `value` is calculated\n */\n trackingId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Geofence ID on which the `value` is calculated\n */\n geofenceId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Timestamp of the beginning of the event\n */\n timestamp?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Duration of the event in seconds */\n value?: number, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Status of the report creation. \nWhen the status is `pending` or `started`, re-check the status later again. \nThe actual reports can be queried only when the report creation status is 'completed'.\n */\n status?: \"pending\" | \"started\" | \"completed\" | \"failed\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Timestamp of the beginning of the interval\n */\n timestamp?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Tracking ID on which the `value` is calculated\n */\n trackingId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Geofence ID on which the `value` is calculated\n */\n geofenceId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Timestamp of the beginning of the event\n */\n timestamp?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Duration of the event in seconds */\n value?: number, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Timestamp of the beginning of the interval\n */\n timestamp?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Tracking ID on which the `value` is calculated\n */\n trackingId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Geofence ID on which the `value` is calculated\n */\n geofenceId?: string, \n/** The value of the report metric, which was specified in the `measure` parameter.\n\n* `measure`: `duration` => `value`: duration of the event in seconds over the time frame\n* `measure`: `occurrence` => `value`: number of event occurrences during the time frame\n* `measure`: `day` => `value`: the number of days the event lasted over the time frame\n* `measure`: `asset` => `value`: the number of assets that generated the event over the time frame\n\nWhen `value` is provided along with `timestamp`, the time frame is the specified interval.\nWhen `value` is provided with `trackingId` or `geofenceId`, the time frame is the whole report period.\n\nAdditionally, if `method` parameter was given, the `value` represents\naverage/cumulative/percentage of the calculated metric.\n */\n value?: number, } | { \n/** Timestamp of the beginning of the event\n */\n timestamp?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Duration of the event in seconds */\n value?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the report creation. \nWhen the status is `pending` or `started`, re-check the status later again. \nThe actual reports can be queried only when the report creation status is 'completed'.\n */\n status?: \"pending\" | \"started\" | \"completed\" | \"failed\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "delete__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.rule": {
        "rendered": " rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/rules/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Rule,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/rules/v4/{ruleId}": {
    "query": {},
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/rules/v4/{ruleId}": {
    "query": {},
    "body": {},
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.rule": {
        "rendered": " rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/rules/v4/{ruleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Rule,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", }, \n/** Must be a valid UUIDv4.\n */\n ruleId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.rule": {
        "rendered": " rule?: { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Utilization event is triggered when the asset starts moving\nindicating that the asset is utilized, and also when the asset stops\nmoving and has been stationary for longer than the threshold duration\nindicating that the asset is unutilized.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"utilization\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Detention event is triggered when the asset has been continuously stationary for longer\nthan the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"detention\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** Dwelling event is triggered when the asset has been continuously inside a geofence\nfor longer than the threshold duration.\n */\n threshold: { \n/** Duration in seconds */\n durationS?: number, }, \n/** The rule type */\n type?: \"dwelling\", } | { \n/** Rule description */\n description?: string, \n/** Geofence ID */\n geofenceId?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** A maximum volume of stock */\n maxVolume?: number, \n/** A minimum volume of stock */\n minVolume?: number, }, \n/** The rule type */\n type?: \"stock\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string, \n/** The rule type */\n type?: \"online\", } | { \n/** Rule description */\n description?: string, \n/** Rule name */\n name?: string,  threshold?: { \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is behind the schedule */\n after?: number, \n/** Allowed time deviation in seconds from the planned ETD/ETA in case the shipment is ahead of schedule */\n before?: number, }, \n/** The rule type */\n type?: \"shipmentSchedule\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.ruleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n ruleId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  description?: string, \n/** Must be a valid UUIDv4.\n */\n id?: string,  name?: string,  range: { \n/** The lower threshold value. */\n begin?: number, \n/** The upper threshold value. */\n end?: number, },  threshold: { \n/** Threshold value */\n value?: number, }, \n/** The sensor type. */\n type?: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\", })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/sensors/v3": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: SensorRule,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Must be a valid UUIDv4.\n */\n id?: string, \n/** Set to `created` if the sensor rule creation was successful. */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.id": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Set to `created` if the sensor rule creation was successful. */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {},
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  description?: string, \n/** Must be a valid UUIDv4.\n */\n id?: string,  name?: string,  range: { \n/** The lower threshold value. */\n begin?: number, \n/** The upper threshold value. */\n end?: number, },  threshold: { \n/** Threshold value */\n value?: number, }, \n/** The sensor type. */\n type?: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.description": {
        "rendered": " description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.id": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": " name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.range": {
        "rendered": " range: { \n/** The lower threshold value. */\n begin?: number, \n/** The upper threshold value. */\n end?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.range.begin": {
        "rendered": "\n/** The lower threshold value. */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.range.end": {
        "rendered": "\n/** The upper threshold value. */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.threshold": {
        "rendered": " threshold: { \n/** Threshold value */\n value?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.threshold.value": {
        "rendered": "\n/** Threshold value */\n value?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.type": {
        "rendered": "\n/** The sensor type. */\n type?: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "put__/sensors/v3/{sensorRuleId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: SensorRule,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".sensorRuleId": {
        "rendered": "\n/** Must be a valid UUIDv4.\n */\n sensorRuleId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The message text is \"updated\" if the sensor rule update was successful. */\n message?: string, } & {  description?: string, \n/** Must be a valid UUIDv4.\n */\n id?: string,  name?: string,  range: { \n/** The lower threshold value. */\n begin?: number, \n/** The upper threshold value. */\n end?: number, },  threshold: { \n/** Threshold value */\n value?: number, }, \n/** The sensor type. */\n type?: \"attach\" | \"battery\" | \"humidity\" | \"pressure\" | \"tamper\" | \"temperature\" | \"acceleration\", }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "post__/shadows/v2/batch": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: Geofences,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** The data that Shadows persists for each device.\n */\n body?: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, }, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,  statusCode?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[]",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name": {
        "rendered": "{ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** The data that Shadows persists for each device.\n */\n body?: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, }, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,  statusCode?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.appId": {
        "rendered": "\n/** Virtual device application ID, only present when the device is virtual */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body": {
        "rendered": "\n/** The data that Shadows persists for each device.\n */\n body?: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired": {
        "rendered": "\n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.desired.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported": {
        "rendered": "\n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.reported.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.reported.position": {
        "rendered": "\n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.accuracy": {
        "rendered": "\n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.alt": {
        "rendered": "\n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.altaccuracy": {
        "rendered": "\n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.confidence": {
        "rendered": "\n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.floor": {
        "rendered": "\n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.floor.id": {
        "rendered": "\n/** The building id */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.floor.level": {
        "rendered": "\n/** The floor in the building in integer format */\n level?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.floor.name": {
        "rendered": "\n/** The building name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.heading": {
        "rendered": "\n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.satellitecount": {
        "rendered": "\n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.speed": {
        "rendered": "\n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.timestamp": {
        "rendered": "\n/** Timestamp of the position */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.type": {
        "rendered": "\n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.position.wlancount": {
        "rendered": "\n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system": {
        "rendered": "\n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.reported.system.client": {
        "rendered": "\n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.accelerometerSensorRange": {
        "rendered": "\n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.accelerometerSensorRange.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.diagnosticscode": {
        "rendered": "\n/** Device diagnostics code. */\n diagnosticscode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.diskquota": {
        "rendered": "\n/** Available disk quota in kilobytes. */\n diskquota?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.firmware": {
        "rendered": "\n/** Device firmware version information */\n firmware?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasAccelerometerSensor": {
        "rendered": "\n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasAttachSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasHumiditySensor": {
        "rendered": "\n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasNoBattery": {
        "rendered": "\n/** False if a device has a battery. */\n hasNoBattery?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasPressureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasTamperSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.hasTemperatureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork": {
        "rendered": "\n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork.__no_name": {
        "rendered": "{ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork.__no_name.mcc": {
        "rendered": "\n/** Mobile Country Code */\n mcc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork.__no_name.mnc": {
        "rendered": "\n/** Mobile Network Code */\n mnc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork.__no_name.nid": {
        "rendered": "\n/** Network Id, NID */\n nid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.homenetwork.__no_name.sid": {
        "rendered": "\n/** System Id, SID */\n sid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.manufacturer": {
        "rendered": "\n/** Manufacturer of the device (hardware) */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.model": {
        "rendered": "\n/** Model of the device (hardware) */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.modules": {
        "rendered": "\n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.modules.__no_name": {
        "rendered": "{ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.modules.__no_name.firmwareVersion": {
        "rendered": "\n/** Installed firmware version */\n firmwareVersion?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.modules.__no_name.manufacturer": {
        "rendered": "\n/** Manufacturer name */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.modules.__no_name.model": {
        "rendered": "\n/** Model or chip name */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.name": {
        "rendered": "\n/** Name of the client software accessing the HERE API */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.platform": {
        "rendered": "\n/** Software platform information of the device, for example operating system name and version. */\n platform?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.client.version": {
        "rendered": "\n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.computed": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.iccid": {
        "rendered": "\n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.imsi": {
        "rendered": "\n/** The IMSI of the device's SIM card.\n */\n imsi?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.__no_name.body.reported.system.phoneNumber": {
        "rendered": "\n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData": {
        "rendered": "\n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.accelerationG": {
        "rendered": "\n/** A g-force value of acceleration. */\n accelerationG?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.batteryIsCharging": {
        "rendered": "\n/** True if device battery is charging. */\n batteryIsCharging?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.batteryLevel": {
        "rendered": "\n/** A value of percentage battery level. */\n batteryLevel?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.deviceIsAttached": {
        "rendered": "\n/** True if device is attached to an object. */\n deviceIsAttached?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.deviceIsStationary": {
        "rendered": "\n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.deviceIsTampered": {
        "rendered": "\n/** True if device is tampered. */\n deviceIsTampered?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.pressureHpa": {
        "rendered": "\n/** A value of pressure in hectopascal. */\n pressureHpa?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.relativeHumidity": {
        "rendered": "\n/** A value of relative humidity in percent. */\n relativeHumidity?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.temperatureC": {
        "rendered": "\n/** A value of temperature in celcius. */\n temperatureC?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.reportedSensorData.tiltDegree": {
        "rendered": "\n/** A value of tilt in degrees. */\n tiltDegree?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.body.reported.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.externalId": {
        "rendered": "\n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.statusCode": {
        "rendered": " statusCode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** If `true`, all the values of the `desired` shadow will be cleared */\n desired?: boolean, \n/** If `true`, all the values of the `reported` shadow will be cleared */\n reported?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.desired": {
        "rendered": "\n/** If `true`, all the values of the `desired` shadow will be cleared */\n desired?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.reported": {
        "rendered": "\n/** If `true`, all the values of the `reported` shadow will be cleared */\n reported?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired": {
        "rendered": "\n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported": {
        "rendered": "\n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.position": {
        "rendered": "\n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.accuracy": {
        "rendered": "\n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.alt": {
        "rendered": "\n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.altaccuracy": {
        "rendered": "\n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.confidence": {
        "rendered": "\n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor": {
        "rendered": "\n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.id": {
        "rendered": "\n/** The building id */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.level": {
        "rendered": "\n/** The floor in the building in integer format */\n level?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.name": {
        "rendered": "\n/** The building name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.heading": {
        "rendered": "\n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.satellitecount": {
        "rendered": "\n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.speed": {
        "rendered": "\n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.timestamp": {
        "rendered": "\n/** Timestamp of the position */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.type": {
        "rendered": "\n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.wlancount": {
        "rendered": "\n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system": {
        "rendered": "\n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.system.client": {
        "rendered": "\n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.accelerometerSensorRange": {
        "rendered": "\n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.accelerometerSensorRange.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.diagnosticscode": {
        "rendered": "\n/** Device diagnostics code. */\n diagnosticscode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.diskquota": {
        "rendered": "\n/** Available disk quota in kilobytes. */\n diskquota?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.firmware": {
        "rendered": "\n/** Device firmware version information */\n firmware?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasAccelerometerSensor": {
        "rendered": "\n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasAttachSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasHumiditySensor": {
        "rendered": "\n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasNoBattery": {
        "rendered": "\n/** False if a device has a battery. */\n hasNoBattery?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasPressureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasTamperSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasTemperatureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork": {
        "rendered": "\n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name": {
        "rendered": "{ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.mcc": {
        "rendered": "\n/** Mobile Country Code */\n mcc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.mnc": {
        "rendered": "\n/** Mobile Network Code */\n mnc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.nid": {
        "rendered": "\n/** Network Id, NID */\n nid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.sid": {
        "rendered": "\n/** System Id, SID */\n sid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.manufacturer": {
        "rendered": "\n/** Manufacturer of the device (hardware) */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.model": {
        "rendered": "\n/** Model of the device (hardware) */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules": {
        "rendered": "\n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name": {
        "rendered": "{ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.firmwareVersion": {
        "rendered": "\n/** Installed firmware version */\n firmwareVersion?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.manufacturer": {
        "rendered": "\n/** Manufacturer name */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.model": {
        "rendered": "\n/** Model or chip name */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.name": {
        "rendered": "\n/** Name of the client software accessing the HERE API */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.platform": {
        "rendered": "\n/** Software platform information of the device, for example operating system name and version. */\n platform?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.version": {
        "rendered": "\n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.computed": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.iccid": {
        "rendered": "\n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.imsi": {
        "rendered": "\n/** The IMSI of the device's SIM card.\n */\n imsi?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.system.phoneNumber": {
        "rendered": "\n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData": {
        "rendered": "\n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.accelerationG": {
        "rendered": "\n/** A g-force value of acceleration. */\n accelerationG?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.batteryIsCharging": {
        "rendered": "\n/** True if device battery is charging. */\n batteryIsCharging?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.batteryLevel": {
        "rendered": "\n/** A value of percentage battery level. */\n batteryLevel?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsAttached": {
        "rendered": "\n/** True if device is attached to an object. */\n deviceIsAttached?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsStationary": {
        "rendered": "\n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsTampered": {
        "rendered": "\n/** True if device is tampered. */\n deviceIsTampered?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.pressureHpa": {
        "rendered": "\n/** A value of pressure in hectopascal. */\n pressureHpa?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.relativeHumidity": {
        "rendered": "\n/** A value of relative humidity in percent. */\n relativeHumidity?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.temperatureC": {
        "rendered": "\n/** A value of temperature in celcius. */\n temperatureC?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.tiltDegree": {
        "rendered": "\n/** A value of tilt in degrees. */\n tiltDegree?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "put__/shadows/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The desired shadow of the device. */\n    desired: {\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /**\n   * Contains values for the device configuration. HERE Tracking uses these values\n   * for various application flows.\n   */\n    system?: {\n  /** A boolean value that sets outlier detection on or off */\n    detectOutliers?: boolean,\n  /**\n   * Tracking can be disabled and enabled by defining disableTracking object.\n   * In order to disable tracking, one must at least provide the begin time of the disabling\n   * period and define either position or sensor properties one wants to disable. One can also\n   * disable both position and sensors at the same time. By default tracking is enabled.\n   */\n    disableTracking?: {\n  /**\n   * Array of periods\n   * Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n   * @maxItems 1\n   * @minItems 0\n   */\n    periods?: ({\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * Begin time of the tracking disabling period.\n   * \n   * Begin must be smaller than end. Begin must be greater or equal to current time.\n   * Begin can be set without end. If there exists already end time which is earlier\n   * than given new begin time, the existing end time will be deleted.\n   * @min 2\n   * @max 4102448400000\n   */\n    begin?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n   * \n   * End time of the tracking disabling period.\n   * \n   * End must be greater than begin. End must be greater or equal to current time.\n   * End can be set without begin if begin is already set.\n   * @min 2\n   * @max 4102448400000\n   */\n    end?: number,\n\n})[],\n  /** Define position methods to be disabled */\n    position?: (\"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\"),\n  /** Define sensors to be disabled */\n    sensors?: (\"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\"),\n\n},\n  /** This can be used to specify the rates at which the device performs certain tasks. */\n    rate?: {\n  /**\n   * Send an update if the device has moved farther than the specified distance in meters\n   * @min 0\n   */\n    distanceM?: number,\n  /**\n   * The rate at which to sample signals in milliseconds\n   * @min 0\n   */\n    sampleMs?: number,\n  /**\n   * The rate at which to send sample results in milliseconds\n   * @min 0\n   */\n    sendMs?: number,\n\n},\n  /**\n   * An array of objects that holds sensor logging configurations\n   * @maxItems 5\n   * @minItems 0\n   */\n    sensorLoggingConfigurations?: ({\n  /**\n   * Sampling frequrency of single sensor loggin configuration (in milliseconds)\n   * @min 1\n   */\n    samplingFrequency?: number,\n  /** Type of single sensor logging configuration */\n    type: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",\n\n})[],\n  /** Flag that sets sensor logging on or off */\n    sensorLoggingEnabled?: boolean,\n  /** A boolean value that sets efficient geofencing on or off */\n    syncGeofences?: boolean,\n  /**\n   * An array of objects that holds wlan configurations\n   * @maxItems 10\n   * @minItems 0\n   */\n    wlanConfigurations?: ({\n  /**\n   * WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'.\n   * @minLength 8\n   * @maxLength 63\n   */\n    password?: string,\n  /** Selected security mode */\n    securityMode: \"none\" | \"wpa2psk\",\n  /**\n   * Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity.\n   * @minLength 1\n   * @maxLength 32\n   */\n    ssid: string,\n  /** Flag that informs if SSID is hidden */\n    ssidIsHidden?: boolean,\n\n})[],\n  /** A boolean value that sets wlan connectivity on or off */\n    wlanConnectivityEnabled?: boolean,\n\n},\n\n},\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired": {
        "rendered": "\n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.desired.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported": {
        "rendered": "\n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.position": {
        "rendered": "\n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.accuracy": {
        "rendered": "\n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.alt": {
        "rendered": "\n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.altaccuracy": {
        "rendered": "\n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.confidence": {
        "rendered": "\n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor": {
        "rendered": "\n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.id": {
        "rendered": "\n/** The building id */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.level": {
        "rendered": "\n/** The floor in the building in integer format */\n level?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.floor.name": {
        "rendered": "\n/** The building name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.heading": {
        "rendered": "\n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.satellitecount": {
        "rendered": "\n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.speed": {
        "rendered": "\n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.timestamp": {
        "rendered": "\n/** Timestamp of the position */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.type": {
        "rendered": "\n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.position.wlancount": {
        "rendered": "\n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system": {
        "rendered": "\n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.system.client": {
        "rendered": "\n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.accelerometerSensorRange": {
        "rendered": "\n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.accelerometerSensorRange.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.diagnosticscode": {
        "rendered": "\n/** Device diagnostics code. */\n diagnosticscode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.diskquota": {
        "rendered": "\n/** Available disk quota in kilobytes. */\n diskquota?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.firmware": {
        "rendered": "\n/** Device firmware version information */\n firmware?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasAccelerometerSensor": {
        "rendered": "\n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasAttachSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasHumiditySensor": {
        "rendered": "\n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasNoBattery": {
        "rendered": "\n/** False if a device has a battery. */\n hasNoBattery?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasPressureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasTamperSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.hasTemperatureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork": {
        "rendered": "\n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name": {
        "rendered": "{ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.mcc": {
        "rendered": "\n/** Mobile Country Code */\n mcc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.mnc": {
        "rendered": "\n/** Mobile Network Code */\n mnc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.nid": {
        "rendered": "\n/** Network Id, NID */\n nid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.homenetwork.__no_name.sid": {
        "rendered": "\n/** System Id, SID */\n sid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.manufacturer": {
        "rendered": "\n/** Manufacturer of the device (hardware) */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.model": {
        "rendered": "\n/** Model of the device (hardware) */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules": {
        "rendered": "\n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name": {
        "rendered": "{ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.firmwareVersion": {
        "rendered": "\n/** Installed firmware version */\n firmwareVersion?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.manufacturer": {
        "rendered": "\n/** Manufacturer name */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.modules.__no_name.model": {
        "rendered": "\n/** Model or chip name */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.name": {
        "rendered": "\n/** Name of the client software accessing the HERE API */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.platform": {
        "rendered": "\n/** Software platform information of the device, for example operating system name and version. */\n platform?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.client.version": {
        "rendered": "\n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.computed": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.iccid": {
        "rendered": "\n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.imsi": {
        "rendered": "\n/** The IMSI of the device's SIM card.\n */\n imsi?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.reported.system.phoneNumber": {
        "rendered": "\n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData": {
        "rendered": "\n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.accelerationG": {
        "rendered": "\n/** A g-force value of acceleration. */\n accelerationG?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.batteryIsCharging": {
        "rendered": "\n/** True if device battery is charging. */\n batteryIsCharging?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.batteryLevel": {
        "rendered": "\n/** A value of percentage battery level. */\n batteryLevel?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsAttached": {
        "rendered": "\n/** True if device is attached to an object. */\n deviceIsAttached?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsStationary": {
        "rendered": "\n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.deviceIsTampered": {
        "rendered": "\n/** True if device is tampered. */\n deviceIsTampered?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.pressureHpa": {
        "rendered": "\n/** A value of pressure in hectopascal. */\n pressureHpa?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.relativeHumidity": {
        "rendered": "\n/** A value of relative humidity in percent. */\n relativeHumidity?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.temperatureC": {
        "rendered": "\n/** A value of temperature in celcius. */\n temperatureC?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.reportedSensorData.tiltDegree": {
        "rendered": "\n/** A value of tilt in degrees. */\n tiltDegree?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.reported.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shadows/v2/{trackingId}/{state}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".state": {
        "rendered": "\n/** Desired or reported state object of a device to query. */\n state: \"desired\" | \"reported\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, } | { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/shadows/v2/{trackingId}/{state}/{selector}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".state": {
        "rendered": "\n/** Desired or reported state object of a device to query. */\n state: \"desired\" | \"reported\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".selector": {
        "rendered": "\n/** A JSON selector that specifies the property. */\n selector: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue | ()[]",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/shadows/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** If provided returns the shadows for which `reported.timestamp` is greater than given `after` parameter. */\n after?: string, \n/** Defines how the items are sorted.\nThe default sort is `sort=trackingId:asc`\n */\n sort?: string, \n/** Limit search to shadows, whose position intersects the given bounding box.\nThe `bbox` array consist of latitude and longitude of Northwest and Southeast corners.\n */\n bbox?: (number)[], },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** If provided returns the shadows for which `reported.timestamp` is greater than given `after` parameter. */\n after?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** Defines how the items are sorted.\nThe default sort is `sort=trackingId:asc`\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox": {
        "rendered": "\n/** Limit search to shadows, whose position intersects the given bounding box.\nThe `bbox` array consist of latitude and longitude of Northwest and Southeast corners.\n */\n bbox?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bbox.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,  shadow: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** The time of the last update to the desired shadow.\n */\n timestamp?: string, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** This describes when the reported measurements were taken.\n */\n timestamp?: string, }, }, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,  shadow: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** The time of the last update to the desired shadow.\n */\n timestamp?: string, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** This describes when the reported measurements were taken.\n */\n timestamp?: string, }, }, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,  shadow: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** The time of the last update to the desired shadow.\n */\n timestamp?: string, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** This describes when the reported measurements were taken.\n */\n timestamp?: string, }, }, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.appId": {
        "rendered": "\n/** Virtual device application ID, only present when the device is virtual */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.externalId": {
        "rendered": "\n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow": {
        "rendered": " shadow: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** The time of the last update to the desired shadow.\n */\n timestamp?: string, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** This describes when the reported measurements were taken.\n */\n timestamp?: string, }, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired": {
        "rendered": "\n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** The time of the last update to the desired shadow.\n */\n timestamp?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string, \n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Begin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** End time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** The time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.desired.timestamp": {
        "rendered": "\n/** The time of the last update to the desired shadow.\n */\n timestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported": {
        "rendered": "\n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** This describes when the reported measurements were taken.\n */\n timestamp?: string, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.reported.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.reported.position": {
        "rendered": "\n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: string, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.accuracy": {
        "rendered": "\n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.alt": {
        "rendered": "\n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.altaccuracy": {
        "rendered": "\n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.confidence": {
        "rendered": "\n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.floor": {
        "rendered": "\n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.floor.id": {
        "rendered": "\n/** The building id */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.floor.level": {
        "rendered": "\n/** The floor in the building in integer format */\n level?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.floor.name": {
        "rendered": "\n/** The building name */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.heading": {
        "rendered": "\n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.lat": {
        "rendered": "\n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.lng": {
        "rendered": "\n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.satellitecount": {
        "rendered": "\n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.speed": {
        "rendered": "\n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.timestamp": {
        "rendered": "\n/** Timestamp of the position */\n timestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.type": {
        "rendered": "\n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.position.wlancount": {
        "rendered": "\n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system": {
        "rendered": "\n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.reported.system.client": {
        "rendered": "\n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.accelerometerSensorRange": {
        "rendered": "\n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.accelerometerSensorRange.__no_name": {
        "rendered": "number",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.diagnosticscode": {
        "rendered": "\n/** Device diagnostics code. */\n diagnosticscode?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.diskquota": {
        "rendered": "\n/** Available disk quota in kilobytes. */\n diskquota?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.firmware": {
        "rendered": "\n/** Device firmware version information */\n firmware?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasAccelerometerSensor": {
        "rendered": "\n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasAttachSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasHumiditySensor": {
        "rendered": "\n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasNoBattery": {
        "rendered": "\n/** False if a device has a battery. */\n hasNoBattery?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasPressureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasTamperSensor": {
        "rendered": "\n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.hasTemperatureSensor": {
        "rendered": "\n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork": {
        "rendered": "\n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork.__no_name": {
        "rendered": "{ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork.__no_name.mcc": {
        "rendered": "\n/** Mobile Country Code */\n mcc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork.__no_name.mnc": {
        "rendered": "\n/** Mobile Network Code */\n mnc?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork.__no_name.nid": {
        "rendered": "\n/** Network Id, NID */\n nid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.homenetwork.__no_name.sid": {
        "rendered": "\n/** System Id, SID */\n sid?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.manufacturer": {
        "rendered": "\n/** Manufacturer of the device (hardware) */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.model": {
        "rendered": "\n/** Model of the device (hardware) */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.modules": {
        "rendered": "\n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.modules.__no_name": {
        "rendered": "{ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.modules.__no_name.firmwareVersion": {
        "rendered": "\n/** Installed firmware version */\n firmwareVersion?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.modules.__no_name.manufacturer": {
        "rendered": "\n/** Manufacturer name */\n manufacturer?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.modules.__no_name.model": {
        "rendered": "\n/** Model or chip name */\n model?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.name": {
        "rendered": "\n/** Name of the client software accessing the HERE API */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.platform": {
        "rendered": "\n/** Software platform information of the device, for example operating system name and version. */\n platform?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.client.version": {
        "rendered": "\n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.computed": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.iccid": {
        "rendered": "\n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.imsi": {
        "rendered": "\n/** The IMSI of the device's SIM card.\n */\n imsi?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shadow.reported.system.phoneNumber": {
        "rendered": "\n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData": {
        "rendered": "\n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.accelerationG": {
        "rendered": "\n/** A g-force value of acceleration. */\n accelerationG?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.batteryIsCharging": {
        "rendered": "\n/** True if device battery is charging. */\n batteryIsCharging?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.batteryLevel": {
        "rendered": "\n/** A value of percentage battery level. */\n batteryLevel?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.deviceIsAttached": {
        "rendered": "\n/** True if device is attached to an object. */\n deviceIsAttached?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.deviceIsStationary": {
        "rendered": "\n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.deviceIsTampered": {
        "rendered": "\n/** True if device is tampered. */\n deviceIsTampered?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.pressureHpa": {
        "rendered": "\n/** A value of pressure in hectopascal. */\n pressureHpa?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.relativeHumidity": {
        "rendered": "\n/** A value of relative humidity in percent. */\n relativeHumidity?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.temperatureC": {
        "rendered": "\n/** A value of temperature in celcius. */\n temperatureC?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.reportedSensorData.tiltDegree": {
        "rendered": "\n/** A value of tilt in degrees. */\n tiltDegree?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shadow.reported.timestamp": {
        "rendered": "\n/** This describes when the reported measurements were taken.\n */\n timestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipment-reports/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Include successfully completed shipments of each shipment plan into the shipment report generation\n   * which ended after the provided date.\n   * @format date-time\n   */\n    endedAfter?: string,\n  /**\n   * Include successfully completed shipments of each shipment plan into the shipment report generation\n   * which ended before the provided date.\n   * @format date-time\n   */\n    endedBefore?: string,\n  /**\n   * Provide array of shipment plan ids to include into the shipment report. If just a single shipment plan id is\n   * given, then the shipment report will include only metrics and shipments for the given shipment plan. If none\n   * is given, then the shipment report will include all shipment plans.\n   * @maxItems 100\n   * @minItems 1\n   */\n    shipmentPlanIds?: (string)[],\n  /**\n   * Include successfully completed shipments of each shipment plan into the shipment report generation\n   * which started after the provided date.\n   * @format date-time\n   */\n    startedAfter?: string,\n  /**\n   * Include successfully completed shipments of each shipment plan into the shipment report generation\n   * which started before the provided date.\n   * @format date-time\n   */\n    startedBefore?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Shipment report ID */\n shipmentReportId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/status": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{  error: { \n/** An HTTP status code */\n code?: number,  \n/** An HTTP error description */\n error?: string, \n/** An error ID that allows you to trace the error details */\n id?: string, \n/** Descriptive text that explains the error */\n message?: string, },  status?: \"completed\" | \"failed\" | \"ongoing\" | \"pending\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.error": {
        "rendered": " error: { \n/** An HTTP status code */\n code?: number,  \n/** An HTTP error description */\n error?: string, \n/** An error ID that allows you to trace the error details */\n id?: string, \n/** Descriptive text that explains the error */\n message?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.error.code": {
        "rendered": "\n/** An HTTP status code */\n code?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.error.details": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.error.error": {
        "rendered": "\n/** An HTTP error description */\n error?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.error.id": {
        "rendered": "\n/** An error ID that allows you to trace the error details */\n id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.error.message": {
        "rendered": "\n/** Descriptive text that explains the error */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": " status?: \"completed\" | \"failed\" | \"ongoing\" | \"pending\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/summary": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** When generation of the shipment report was completed.\n */\n completedAt?: string, \n/** When generation of the shipment report was started.\n */\n createdAt?: string, \n/** Count of locations over all segment plans in the shipment report.\n */\n totalLocationCount?: number, \n/** Count of segment plans in the shipments report.\n */\n totalSegmentPlanCount?: number, \n/** Count of segments over all segment plans in the shipment report.\n */\n totalSegmentsCount?: number, \n/** Count of shipment plans in the shipments report.\n */\n totalShipmentPlanCount?: number, \n/** Count of shipments over all shipment plans in the shipment report.\n */\n totalShipmentsCount?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.completedAt": {
        "rendered": "\n/** When generation of the shipment report was completed.\n */\n completedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.createdAt": {
        "rendered": "\n/** When generation of the shipment report was started.\n */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.totalLocationCount": {
        "rendered": "\n/** Count of locations over all segment plans in the shipment report.\n */\n totalLocationCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.totalSegmentPlanCount": {
        "rendered": "\n/** Count of segment plans in the shipments report.\n */\n totalSegmentPlanCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.totalSegmentsCount": {
        "rendered": "\n/** Count of segments over all segment plans in the shipment report.\n */\n totalSegmentsCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.totalShipmentPlanCount": {
        "rendered": "\n/** Count of shipment plans in the shipments report.\n */\n totalShipmentPlanCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.totalShipmentsCount": {
        "rendered": "\n/** Count of shipments over all shipment plans in the shipment report.\n */\n totalShipmentsCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipment-reports/v4/{shipmentReportId}/{metric}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** The response items can be sorted to ascending or descending order by their statistics properties. E.g for\n`shipmentPlanPunctualityAtOrigin` it could be `avg:desc`.\nDefault is ascending sort order.\n */\n sort?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** The response items can be sorted to ascending or descending order by their statistics properties. E.g for\n`shipmentPlanPunctualityAtOrigin` it could be `avg:desc`.\nDefault is ascending sort order.\n */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".metric": {
        "rendered": "\n/** Metric for which results to include in the response.\n */\n metric: \"shipmentPlanPunctualityAtOrigin\" | \"shipmentPlanPunctualityAtDestination\" | \"segmentPlanPunctualityAtOrigin\" | \"segmentPlanPunctualityAtDestination\" | \"shipmentPunctualityAtOrigin\" | \"shipmentPunctualityAtDestination\" | \"segmentPunctualityAtOrigin\" | \"segmentPunctualityAtDestination\" | \"locationDwelling\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".shipmentReportId": {
        "rendered": "\n/** Shipment report ID */\n shipmentReportId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Combination of shipmentId, shipmentPlanId, segmentId, segmentPlanId or locationId based on\nthe given metric.\n */\n ids?: { \n/** Location ID */\n locationId?: string, \n/** Segment ID */\n segmentId?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, }, \n/** Calculated statistics of the given metric.\n */\n statistics?: { \n/** Average value taken over metric values.\n */\n avg?: number, \n/** Value of a metric.\n */\n val?: number, }, \n/** How many inputs were used to calculate the given metric.\n */\n statisticsCount?: number, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Total number of items */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Combination of shipmentId, shipmentPlanId, segmentId, segmentPlanId or locationId based on\nthe given metric.\n */\n ids?: { \n/** Location ID */\n locationId?: string, \n/** Segment ID */\n segmentId?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, }, \n/** Calculated statistics of the given metric.\n */\n statistics?: { \n/** Average value taken over metric values.\n */\n avg?: number, \n/** Value of a metric.\n */\n val?: number, }, \n/** How many inputs were used to calculate the given metric.\n */\n statisticsCount?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Combination of shipmentId, shipmentPlanId, segmentId, segmentPlanId or locationId based on\nthe given metric.\n */\n ids?: { \n/** Location ID */\n locationId?: string, \n/** Segment ID */\n segmentId?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, }, \n/** Calculated statistics of the given metric.\n */\n statistics?: { \n/** Average value taken over metric values.\n */\n avg?: number, \n/** Value of a metric.\n */\n val?: number, }, \n/** How many inputs were used to calculate the given metric.\n */\n statisticsCount?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids": {
        "rendered": "\n/** Combination of shipmentId, shipmentPlanId, segmentId, segmentPlanId or locationId based on\nthe given metric.\n */\n ids?: { \n/** Location ID */\n locationId?: string, \n/** Segment ID */\n segmentId?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids.locationId": {
        "rendered": "\n/** Location ID */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids.segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids.segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids.shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ids.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.statistics": {
        "rendered": "\n/** Calculated statistics of the given metric.\n */\n statistics?: { \n/** Average value taken over metric values.\n */\n avg?: number, \n/** Value of a metric.\n */\n val?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.statistics.avg": {
        "rendered": "\n/** Average value taken over metric values.\n */\n avg?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.statistics.val": {
        "rendered": "\n/** Value of a metric.\n */\n val?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.statisticsCount": {
        "rendered": "\n/** How many inputs were used to calculate the given metric.\n */\n statisticsCount?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** Total number of items */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter the results by shipment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Return only shipments that started before the specified timestamp */\n startedBefore?: string, \n/** Return only shipments that started after the specified timestamp */\n startedAfter?: string, \n/** Return only shipments that ended before the specified timestamp */\n endedBefore?: string, \n/** Return only shipments that ended after the specified timestamp */\n endedAfter?: string, \n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Filter shipments by `shipmentId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentId?: string, \n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean, \n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string, \n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string, \n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'shipmentId:desc' sort by shipmentId in descending order.\nAllowed fields to sort by:\nshipmentId, name, status, startedAt, createdAt, endedAt, providedEtd,\nprovidedEta, calculatedEtd.\n */\n sort?: string | (string)[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.status": {
        "rendered": "\n/** Filter the results by shipment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.startedBefore": {
        "rendered": "\n/** Return only shipments that started before the specified timestamp */\n startedBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.startedAfter": {
        "rendered": "\n/** Return only shipments that started after the specified timestamp */\n startedAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endedBefore": {
        "rendered": "\n/** Return only shipments that ended before the specified timestamp */\n endedBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.endedAfter": {
        "rendered": "\n/** Return only shipments that ended after the specified timestamp */\n endedAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentId": {
        "rendered": "\n/** Filter shipments by `shipmentId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.isSubShipment": {
        "rendered": "\n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdBefore": {
        "rendered": "\n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdAfter": {
        "rendered": "\n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nThe following format can be used:\n'name:asc' sort by name in ascending order,\n'shipmentId:desc' sort by shipmentId in descending order.\nAllowed fields to sort by:\nshipmentId, name, status, startedAt, createdAt, endedAt, providedEtd,\nprovidedEta, calculatedEtd.\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Calculated  ETA for the shipment */\n calculatedEta?: string, \n/** Calculated ETD for the shipment */\n calculatedEtd?: string, \n/** Timestamp indicating when the shipment has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Timestamp indicating when the shipment ended */\n endedAt?: string, \n/** Name of the shipment */\n name?: string, \n/** User provided ETA for the shipment */\n providedEta?: string, \n/** User provided ETD for the shipment */\n providedEtd?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment ID */\n shipmentId?: string, \n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string, \n/** Timestamp indicating when the shipment started */\n startedAt?: string, \n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Total number of shipments for query */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Calculated  ETA for the shipment */\n calculatedEta?: string, \n/** Calculated ETD for the shipment */\n calculatedEtd?: string, \n/** Timestamp indicating when the shipment has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Timestamp indicating when the shipment ended */\n endedAt?: string, \n/** Name of the shipment */\n name?: string, \n/** User provided ETA for the shipment */\n providedEta?: string, \n/** User provided ETD for the shipment */\n providedEtd?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment ID */\n shipmentId?: string, \n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string, \n/** Timestamp indicating when the shipment started */\n startedAt?: string, \n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Calculated  ETA for the shipment */\n calculatedEta?: string, \n/** Calculated ETD for the shipment */\n calculatedEtd?: string, \n/** Timestamp indicating when the shipment has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Timestamp indicating when the shipment ended */\n endedAt?: string, \n/** Name of the shipment */\n name?: string, \n/** User provided ETA for the shipment */\n providedEta?: string, \n/** User provided ETD for the shipment */\n providedEtd?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment ID */\n shipmentId?: string, \n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string, \n/** Timestamp indicating when the shipment started */\n startedAt?: string, \n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.autoStart": {
        "rendered": "\n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the shipment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the shipment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when the shipment has been created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.description": {
        "rendered": "\n/** Description of the shipment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when the shipment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** Name of the shipment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the shipment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the shipment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ruleIds": {
        "rendered": "\n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ruleIds.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments": {
        "rendered": "\n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.segments.__no_name": {
        "rendered": "{ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.segments.__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the segment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the segment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when this segment created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when this segment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the segment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the segment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when this segment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.status": {
        "rendered": "\n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.segments.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shipmentPlanId": {
        "rendered": "\n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when the shipment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.status": {
        "rendered": "\n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.subShipment": {
        "rendered": "\n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** Total number of shipments for query */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipments/v4": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: CreateShipmentBody,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Shipment ID */\n shipmentId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string, \n/** Return only shipment plans that have been instantiated from the specified `shipmentPlanId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentPlanId?: string, \n/** Return only shipments that have been instantiated from the specified `locationId`\n */\n locationId?: string, \n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string, \n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string, \n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean, \n/** A paramater to specify field to sort by and order.\nAllowed fields to sort by: shipmentPlanId, name, createdAt\n */\n sort?: string | (string)[], },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.name": {
        "rendered": "\n/** Filter shipments by name. Matching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.shipmentPlanId": {
        "rendered": "\n/** Return only shipment plans that have been instantiated from the specified `shipmentPlanId`\nMatching is case-insensitive.\nThe following wildcards can be used:\n'*' matches any number of any characters,\n'?' matches any single character.\n */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.locationId": {
        "rendered": "\n/** Return only shipments that have been instantiated from the specified `locationId`\n */\n locationId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdBefore": {
        "rendered": "\n/** Return only shipments that have been created before specified timestamp */\n createdBefore?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.createdAfter": {
        "rendered": "\n/** Return only shipments that have been created after specified timestamp */\n createdAfter?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.isSubShipment": {
        "rendered": "\n/** Returns only shipments marked as subShipments */\n isSubShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** A paramater to specify field to sort by and order.\nAllowed fields to sort by: shipmentPlanId, name, createdAt\n */\n sort?: string | (string)[],",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Name of the shipment */\n name?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, \n/** Total count of matching results */\n total?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Name of the shipment */\n name?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Name of the shipment */\n name?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.autoStart": {
        "rendered": "\n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.description": {
        "rendered": "\n/** Description of the shipment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** Name of the shipment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ruleIds": {
        "rendered": "\n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.ruleIds.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments": {
        "rendered": "\n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.segments.__no_name": {
        "rendered": "{ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.segments.__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.durationS": {
        "rendered": "\n/** Segment duration in seconds. */\n durationS?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segments.__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.subShipment": {
        "rendered": "\n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.total": {
        "rendered": "\n/** Total count of matching results */\n total?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/shipments/v4/plans": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: CreateShipmentPlanBody,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Shipment plan ID */\n shipmentPlanId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Name of the shipment */\n name?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment plan ID */\n shipmentPlanId?: string, \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.autoStart": {
        "rendered": "\n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when the shipment plan has been created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the shipment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the shipment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ruleIds": {
        "rendered": "\n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ruleIds.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments": {
        "rendered": "\n/** Array of objects each defining the origin and destination of the segment */\n segments?: ({ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.segments.__no_name": {
        "rendered": "{ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.segments.__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.durationS": {
        "rendered": "\n/** Segment duration in seconds. */\n durationS?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.subShipment": {
        "rendered": "\n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/plans/{shipmentPlanId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   */\n    autoStart?: boolean,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /** Flag telling if shipment is a subShipment. */\n    subShipment?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/plans/{shipmentPlanId}/{segmentPlanId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Segment duration in seconds. */\n durationS?: number, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** Segment plan ID */\n segmentPlanId?: string, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.durationS": {
        "rendered": "\n/** Segment duration in seconds. */\n durationS?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "patch__/shipments/v4/plans/{shipmentPlanId}/{segmentPlanId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Segment duration in seconds.\n   * @min 0\n   */\n    durationS?: number,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * ID of the tracking device that produces data for this segment\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".shipmentPlanId": {
        "rendered": "\n/** Shipment plan ID */\n shipmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentPlanId": {
        "rendered": "\n/** Segment plan ID */\n segmentPlanId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean, \n/** Calculated  ETA for the shipment */\n calculatedEta?: string, \n/** Calculated ETD for the shipment */\n calculatedEtd?: string, \n/** Timestamp indicating when the shipment has been created */\n createdAt?: string, \n/** Description of the shipment */\n description?: string, \n/** Timestamp indicating when the shipment ended */\n endedAt?: string, \n/** Name of the shipment */\n name?: string, \n/** User provided ETA for the shipment */\n providedEta?: string, \n/** User provided ETD for the shipment */\n providedEtd?: string, \n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[], \n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Shipment ID */\n shipmentId?: string, \n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string, \n/** Timestamp indicating when the shipment started */\n startedAt?: string, \n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.autoStart": {
        "rendered": "\n/** A boolean parameter defining whether the shipment starts upon exiting the first origin\nlocation.\n */\n autoStart?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the shipment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the shipment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when the shipment has been created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the shipment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when the shipment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the shipment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the shipment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the shipment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ruleIds": {
        "rendered": "\n/** Array of `ruleId`s to associate with the shipment */\n ruleIds?: (string)[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.ruleIds.__no_name": {
        "rendered": "string",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments": {
        "rendered": "\n/** Array containing the segment details */\n segments?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.segments.__no_name": {
        "rendered": "{ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.segments.__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the segment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the segment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when this segment created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when this segment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the segment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the segment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when this segment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.status": {
        "rendered": "\n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.segments.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segments.__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.shipmentPlanId": {
        "rendered": "\n/** A shipment plan's id that the shipment was generated from. */\n shipmentPlanId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when the shipment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the shipment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.subShipment": {
        "rendered": "\n/** Flag telling if shipment is a subShipment. */\n subShipment?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "patch__/shipments/v4/{shipmentId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * A boolean parameter defining whether the shipment starts upon exiting the first origin\n   * location.\n   */\n    autoStart?: boolean,\n  /**\n   * Description of the shipment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Name of the shipment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * ETA for the shipment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * ETD for the shipment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * Array of `ruleId`s to associate with the shipment\n   * @maxItems 10\n   */\n    ruleIds?: (string)[],\n  /**\n   * Array of objects each defining the origin and destination of the segment\n   * @maxItems 20\n   * @minItems 1\n   */\n    segments?: ({\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Destination location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    destination: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Origin location of this segment\n   * @pattern ^LOC-[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\n   */\n    origin: string,\n  /**\n   * ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /**\n   * ID of the tracking device that produces data for this segment\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n})[],\n  /** Status of the shipment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /** Flag telling if shipment is a subShipment. */\n    subShipment?: boolean,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/{shipmentId}/{segmentId}": {
    "query": {},
    "body": {},
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the segment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the segment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when this segment created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when this segment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the segment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the segment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when this segment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.status": {
        "rendered": "\n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "patch__/shipments/v4/{shipmentId}/{segmentId}": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * Description of the segment\n   * @maxLength 1000\n   */\n    description?: string,\n  /**\n   * Name of the segment\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * ETA for the segment\n   * @format date-time\n   */\n    providedEta?: string,\n  /**\n   * ETD for the segment\n   * @format date-time\n   */\n    providedEtd?: string,\n  /** Status of the segment */\n    status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",\n  /**\n   * ID of the tracking device that produces data for the segment\n   * @minLength 1\n   * @maxLength 50\n   */\n    trackingId?: string,\n  /** Transport mode of the segment */\n    transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {
      ".shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/shipments/v4/{trackingId}/segments": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page */\n limit?: number, \n/** Filter the results by segment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of items to return per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.status": {
        "rendered": "\n/** Filter the results by segment status */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Number of items returned in the response */\n count?: number,  items?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[], \n/** Maximum number of items as specified in request */\n limit?: number, \n/** Token to fetch the next page (if exists) */\n nextPageToken?: string, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.count": {
        "rendered": "\n/** Number of items returned in the response */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items": {
        "rendered": " items?: ({ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name": {
        "rendered": "{ \n/** Calculated  ETA for the segment */\n calculatedEta?: string, \n/** Calculated ETD for the segment */\n calculatedEtd?: string, \n/** Timestamp indicating when this segment created */\n createdAt?: string, \n/** Description of the segment */\n description?: string, \n/** Destination location of this segment */\n destination?: string, \n/** Timestamp indicating when this segment ended */\n endedAt?: string, \n/** Name of the segment */\n name?: string, \n/** Origin location of this segment */\n origin?: string, \n/** User provided ETA for the segment */\n providedEta?: string, \n/** User provided ETD for the segment */\n providedEtd?: string, \n/** Segment ID */\n segmentId?: string, \n/** Shipment ID */\n shipmentId?: string, \n/** Timestamp indicating when this segment started */\n startedAt?: string, \n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\", \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string, \n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.calculatedEta": {
        "rendered": "\n/** Calculated  ETA for the segment */\n calculatedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.calculatedEtd": {
        "rendered": "\n/** Calculated ETD for the segment */\n calculatedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.createdAt": {
        "rendered": "\n/** Timestamp indicating when this segment created */\n createdAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.description": {
        "rendered": "\n/** Description of the segment */\n description?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.destination": {
        "rendered": "\n/** Destination location of this segment */\n destination?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.endedAt": {
        "rendered": "\n/** Timestamp indicating when this segment ended */\n endedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.name": {
        "rendered": "\n/** Name of the segment */\n name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.origin": {
        "rendered": "\n/** Origin location of this segment */\n origin?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.providedEta": {
        "rendered": "\n/** User provided ETA for the segment */\n providedEta?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.providedEtd": {
        "rendered": "\n/** User provided ETD for the segment */\n providedEtd?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.segmentId": {
        "rendered": "\n/** Segment ID */\n segmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.shipmentId": {
        "rendered": "\n/** Shipment ID */\n shipmentId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.startedAt": {
        "rendered": "\n/** Timestamp indicating when this segment started */\n startedAt?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.status": {
        "rendered": "\n/** Status of the segment */\n status?: \"pending\" | \"ongoing\" | \"completed\" | \"cancelled\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.items.__no_name.trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.items.__no_name.transportMode": {
        "rendered": "\n/** Transport mode of the segment */\n transportMode?: \"car\" | \"truck\" | \"sea\" | \"air\" | \"undefined\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.limit": {
        "rendered": "\n/** Maximum number of items as specified in request */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.nextPageToken": {
        "rendered": "\n/** Token to fetch the next page (if exists) */\n nextPageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/traces/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/traces/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "delete__/traces/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/traces/v2/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** Flag specifying if only outliers (`true`) or only nonoutliers (`false`)\nare to be returned. If the parameter is not present both nonoutlier\nand outlier traces are returned.\n */\n outliers?: boolean, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** Flag telling if smoothed traces (true) or non-smoothed (false)\ntraces should get returned. By default the traces are not smoothed.\n\nThe smoothing will have an effect on to the stationary trace points only.\n */\n smooth?: boolean, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of records per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.outliers": {
        "rendered": "\n/** Flag specifying if only outliers (`true`) or only nonoutliers (`false`)\nare to be returned. If the parameter is not present both nonoutlier\nand outlier traces are returned.\n */\n outliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.mode": {
        "rendered": "\n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".query.smooth": {
        "rendered": "\n/** Flag telling if smoothed traces (true) or non-smoothed (false)\ntraces should get returned. By default the traces are not smoothed.\n\nThe smoothing will have an effect on to the stationary trace points only.\n */\n smooth?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of records per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. Alternatively, a valid `shipmentId` may be used. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  } & {  data?: ({ \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThis describes when the measurements were processed by the backend.\n */\n serverTimestamp?: number, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nSpecifies the time the device telemetry measurements were taken.\n */\n timestamp?: number, \n/** Array containing the properties that were removed from the original device data as per disableTracking property in the device shadow. `position` refers to all positioning data and `sensors` to all reported sensor data.\n */\n trackingDisabled?: (\"position\" | \"sensors\" | \"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\" | \"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[], })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/transitions/v2/devices/{trackingId}": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.appId": {
        "rendered": "\n/** Application identifier. Used together with an external ID to identify a virtual device. */\n appId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 1 to the current time.\n */\n before?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.after": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\nThe accepted range is from 0 to the current time.\n */\n after?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {
      ".trackingId": {
        "rendered": "\n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({  geofence?: { \n/** An object that defines the area of a circular geofence */\n definition: { \n/** The coordinates of the center point of the circle. */\n center: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** The radius of the circle in meters. */\n radius?: number, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"circle\", } | { \n/** An object that defines the area of a polygonal geofence. */\n definition: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** An array of points that define the polygon. A minimum of three and a maximum of ten points is required. */\n points?: ({ \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, })[], }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"polygon\", } | { \n/** An object that defines the area of a POI geofence. */\n definition?: { \n/** The building associated with the geofence */\n floor: { \n/** The building ID */\n id?: string, \n/** The floor of the geofence in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** Details of the geofence location */\n location?: { \n/** Address */\n address?: string, \n/** Country */\n country?: string, \n/** Coordinates for visualization purposes */\n position: { \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, }, \n/** The room ID */\n room?: string, }, }, \n/** A description of the area that the geofence encloses and the purpose of the geofence. */\n description?: string, \n/** A human-readable name of the geofence. */\n name?: string, \n/** The geofence type. */\n type?: \"poi\", }, \n/** Must be a valid UUIDv4.\n */\n geofenceId?: string,  inOut?: \"PING_OUTSIDE_FENCE\" | \"PING_IN_FENCE\",  notificationStatus?: \"SENT\" | \"NOT_SENT\", \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC. */\n timestamp?: number, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/transitions/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/transitions/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/users/v2/devices": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string, \n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string, \n/** The number of items to return per page. */\n count?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.projectId": {
        "rendered": "\n/** Project ID.\nAny HERE Tracking user must be a member of a Tracking project.\nThe project ID can be implicitly resolved if the user calling the API is a member of a single project.\nIf the user is a member of multiple projects, the `projectId` query parameter needs to be specified explicitly.\n */\n projectId?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.pageToken": {
        "rendered": "\n/** A token from the previously returned response to retrieve the specified page. */\n pageToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** The number of items to return per page. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** The number of items in the response. */\n count?: number, \n/** A token that can be used to retrieve the next page of the response. */\n pageToken?: string, } & {  data?: ({ \n/** Virtual device application ID, only present when the device is virtual */\n appId?: string, \n/** Virtual device external ID, only present when the device is virtual */\n externalId?: string, \n/** The data that Shadows persists for each device.\n */\n shadow?: { \n/** The desired shadow of the device.\n */\n desired?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }, \n/** The `reported` shadow contains the most recent position, sensor readings and settings that the\ndevice has sent. The reported shadow may also contain additional properties generated by HERE \nTracking based on the device-ingested telemetry.\nSuch properties are stored in `system.computed` property of the shadow.\n\nIn case the most recent telemetry did not contain all the possible\nfields, the last known information will remain in the shadow. This means that one can\nsee, for example, the last reported temperature or tracker firmware information in the reported shadow,\neven if the device did not send that information in the latest telemetry.\n */\n reported?: { \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** The device location */\n position: { \n/** Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter). */\n accuracy?: number, \n/** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n alt?: number, \n/** Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter). */\n altaccuracy?: number, \n/** Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level). */\n confidence?: number, \n/** The building where the measurements were taken */\n floor: { \n/** The building id */\n id?: string, \n/** The floor in the building in integer format */\n level?: number, \n/** The building name */\n name?: string, }, \n/** GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed. */\n heading?: number, \n/** Latitude in WGS-84 format, decimal representation ranging from -90 to 90. */\n lat?: number, \n/** Longitude in WGS-84 format, decimal representation ranging from -180 to 180. */\n lng?: number, \n/** Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only) */\n satellitecount?: number, \n/** GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading. */\n speed?: number, \n/** Timestamp of the position */\n timestamp?: number, \n/** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n type?: string, \n/** The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only) */\n wlancount?: number, }, \n/** Contains device-reported sensor data and device configuration settings.\n`stateVersion` property contains the version of the last\nknown `desired` state seen by the device.\n */\n system?: { \n/** Information about the client device.\n */\n client?: { \n/** Specifies the range of measurable acceleration, representation\nunit g (9.8 m/s^2). If more than one accelerometer is available,\neach element in the list will represent individual accelerometer.\nEach value represents a single \"+/-\" range.\nFor example, value 2 means that sensor is capable to measure\nacceleration within the range of [-2 g, +2 g].\n */\n accelerometerSensorRange?: (number)[], \n/** Device diagnostics code. */\n diagnosticscode?: number, \n/** Available disk quota in kilobytes. */\n diskquota?: number, \n/** Device firmware version information */\n firmware?: string, \n/** True if a device has a sensor to measure acceleration. */\n hasAccelerometerSensor?: boolean, \n/** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n hasAttachSensor?: boolean, \n/** True if a device has a sensor to measure humidity. */\n hasHumiditySensor?: boolean, \n/** False if a device has a battery. */\n hasNoBattery?: boolean, \n/** True if a device has a sensor to measure pressure. */\n hasPressureSensor?: boolean, \n/** True if a device has a sensor to detect if device is disassembled. */\n hasTamperSensor?: boolean, \n/** True if a device has a sensor to measure temperature. */\n hasTemperatureSensor?: boolean, \n/** Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions. */\n homenetwork?: ({ \n/** Mobile Country Code */\n mcc?: number, \n/** Mobile Network Code */\n mnc?: number, \n/** Network Id, NID */\n nid?: number, \n/** System Id, SID */\n sid?: number, })[], \n/** Manufacturer of the device (hardware) */\n manufacturer?: string, \n/** Model of the device (hardware) */\n model?: string, \n/** Software information of all updateable chips. */\n modules?: ({ \n/** Installed firmware version */\n firmwareVersion?: string, \n/** Manufacturer name */\n manufacturer?: string, \n/** Model or chip name */\n model?: string, })[], \n/** Name of the client software accessing the HERE API */\n name?: string, \n/** Software platform information of the device, for example operating system name and version. */\n platform?: string, \n/** Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client. */\n version?: string, },  \n/** SIM card integrated circuit card identifier (ICCID) */\n iccid?: string, \n/** The IMSI of the device's SIM card.\n */\n imsi?: string, \n/** Tracker mode status of the device. When a tracker is in a normal mode, it\ncan send telemetry and, for example, use its GNSS receiver if it has one.\nA tracker switches into flight mode once it detects that it's in an\nairplane, and leaves that mode once airplane lands. Transport mode has to\nbe triggered by the user, and it's used, for example, during shipping from\ncontinent to another. Sleep mode is used when a tracker is stored in\na warehouse, and it's triggered by entering or leaving some defined\ngeofence.\n */\n mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\", \n/** The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n */\n phoneNumber?: string, \n/** The last known device sensor data reported by the device.\n */\n reportedSensorData?: { \n/** A g-force value of acceleration. */\n accelerationG?: number, \n/** True if device battery is charging. */\n batteryIsCharging?: boolean, \n/** A value of percentage battery level. */\n batteryLevel?: number, \n/** True if device is attached to an object. */\n deviceIsAttached?: boolean, \n/** True if device hasn't detected movement. */\n deviceIsStationary?: boolean, \n/** True if device is tampered. */\n deviceIsTampered?: boolean, \n/** A value of pressure in hectopascal. */\n pressureHpa?: number, \n/** A value of relative humidity in percent. */\n relativeHumidity?: number, \n/** A value of temperature in celcius. */\n temperatureC?: number, \n/** A value of tilt in degrees. */\n tiltDegree?: number, }, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe timestamp of the newest telemetry sent by the device. Note that this is not necessarily\nthe timestamp of all the reported values in the reported shadow since the shadow retains\nvalues from previous ingestions if the latest telemetry did not conatain them.\n */\n timestamp?: number, }, }, \n/** This is a unique ID associated with the device data in HERE Tracking. For physical devices the `trackingId` gets assigned to a device when the device is claimed by a user, and for virtual devices it is an external device ID along with the device project `appId`. */\n trackingId?: string, })[], }",
        "requiresRelaxedTypeAnnotation": true
      }
    }
  },
  "get__/users/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/login": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * The email address of the user\n   * @minLength 1\n   */\n    email: string,\n  /**\n   * The password of the user\n   * @minLength 1\n   */\n    password: string,\n  /**\n   * A case-insensitive requested realm ID\n   * @minLength 1\n   */\n    realm?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{  accessToken?: string, \n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number, \n/** Current realm ID */\n realm?: string,  refreshToken?: string, \n/** The token type is bearer */\n tokenType?: string, \n/** The HERE Account ID of a user. */\n userId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.accessToken": {
        "rendered": " accessToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.expiresIn": {
        "rendered": "\n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.realm": {
        "rendered": "\n/** Current realm ID */\n realm?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.refreshToken": {
        "rendered": " refreshToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.tokenType": {
        "rendered": "\n/** The token type is bearer */\n tokenType?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/refresh": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * The access token obtained in a previous login\n   * @minLength 1\n   */\n    accessToken: string,\n  /**\n   * The refresh token obtained in a previous login\n   * @minLength 1\n   */\n    refreshToken: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{  accessToken?: string, \n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number, \n/** Current realm ID */\n realm?: string,  refreshToken?: string, \n/** The token type is bearer */\n tokenType?: string, \n/** The HERE Account ID of a user. */\n userId?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.accessToken": {
        "rendered": " accessToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.expiresIn": {
        "rendered": "\n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.realm": {
        "rendered": "\n/** Current realm ID */\n realm?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.refreshToken": {
        "rendered": " refreshToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.tokenType": {
        "rendered": "\n/** The token type is bearer */\n tokenType?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.userId": {
        "rendered": "\n/** The HERE Account ID of a user. */\n userId?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/users/v2/tokenExchange": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /**\n   * HERE Account user access token, obtained from login endpoint.\n   * @minLength 1\n   */\n    accessToken: string,\n  /**\n   * Requested scope of the access token. Must be an HRN identifying a project that the identified user has access to.\n   * @minLength 1\n   */\n    scope: string,\n\n},",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Project-scoped access token. */\n accessToken?: string, \n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number, \n/** The type of token issued when grantType is \"urn:ietf:params:oauth:grant-type:token-exchange\". */\n issuedTokenType?: string, \n/** Requested scope of the access token. Must be an HRN identifying a project that the identified user has access to. */\n scope?: string, \n/** The token type is 'Bearer'. */\n tokenType?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.accessToken": {
        "rendered": "\n/** Project-scoped access token. */\n accessToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.expiresIn": {
        "rendered": "\n/** The lifetime in seconds of the access token.\nFor example 86400 means the token will expire in 24 hours from the time the response was generated.\n */\n expiresIn?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.issuedTokenType": {
        "rendered": "\n/** The type of token issued when grantType is \"urn:ietf:params:oauth:grant-type:token-exchange\". */\n issuedTokenType?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.scope": {
        "rendered": "\n/** Requested scope of the access token. Must be an HRN identifying a project that the identified user has access to. */\n scope?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.tokenType": {
        "rendered": "\n/** The token type is 'Bearer'. */\n tokenType?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/users/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v2/": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.async": {
        "rendered": "\n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: ({\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /** Radio measurements used for positioning or radio map contribution. */\n    scan?: {\n  /**\n   * Bluetooth access points\n   * @maxItems 128\n   */\n    bt?: ({\n  /**\n   * Full Identifier as Base64 string. A combination of 10-byte Namespace component and a 6-byte Instance component\n   * @minLength 24\n   * @maxLength 24\n   */\n    eddystoneId?: string,\n  /**\n   * Full Identifier as Base64 string. A combination of 16-byte UUID + 2-byte major + 2-byte minor\n   * @minLength 28\n   * @maxLength 28\n   */\n    iBeaconId?: string,\n  /**\n   * The MAC address of the Bluetooth access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. For privacy reasons positioning based on a single Bluetooth AP is not possible. There must be at least one other matching WLAN or Bluetooth access point. Either MAC, EddystoneId, or iBeaconId is required.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac?: string,\n  /**\n   * Received signal strength (dBm) at the terminal\n   * @min -128\n   * @max 0\n   */\n    rss: number,\n  /**\n   * Time of the measurement (UTC)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * CDMA cells\n   * @maxItems 16\n   */\n    cdma?: ({\n  /**\n   * Base station latitude (Optional)\n   * @min -90\n   * @max 90\n   */\n    baselat?: number,\n  /**\n   * Base station longitude (Optional)\n   * @min -180\n   * @max 180\n   */\n    baselng?: number,\n  /**\n   * Base Station ID, BID\n   * @min 0\n   * @max 65535\n   */\n    bsid: number,\n  /**\n   * CDMA channel frequency (Optional, you must specify a value for this item when you specify a value for pnoffset)\n   * @min 0\n   * @max 2047\n   */\n    channel?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid: number,\n  /**\n   * CDMA Network measurements (Optional)\n   * @maxItems 32\n   */\n    nmr?: ({\n  /**\n   * Base Station ID (Optional)\n   * @min 0\n   * @max 65535\n   */\n    bsid?: number,\n  /**\n   * CDMA channel frequency\n   * @min 0\n   * @max 2047\n   */\n    channel: number,\n  /**\n   * Deprecated. Use 'channel' instead.\n   * @min 0\n   * @max 2047\n   */\n    frequency?: number,\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset\n   * @min 0\n   * @max 511\n   */\n    pnoffset: number,\n\n})[],\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset (Optional, you must specify a value for this item when you specify a value for channel)\n   * @min 0\n   * @max 511\n   */\n    pnoffset?: number,\n  /**\n   * Registration zone (Optional)\n   * @min 0\n   * @max 4095\n   */\n    rz?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /** Indicates in which country the WLAN APs are located (in case cell data is not present in radio_observations) */\n    country?: {\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n\n},\n  /**\n   * Optionally supply this to improve HERE Tracking's positioning service by\n   * contributing the scan data along with a GPS position.\n   */\n    gps?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /**\n   * GSM cells (GERAN)\n   * @maxItems 16\n   */\n    gsm?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel) (Optional, you must specify a value for this item when you specify a value for bsic).\n   * @min 0\n   * @max 1023\n   */\n    bcch?: number,\n  /**\n   * Base Station Identity Code (for instance, color code) (Optional, you must specify a value for this item when you specify a value for bcch).\n   * @min 0\n   * @max 63\n   */\n    bsic?: number,\n  /**\n   * Cell Identifier, 16 bits. Mcc+mnc+lac+cid uniquely identifies the GSM cell.\n   * @min 0\n   * @max 65535\n   */\n    cid: number,\n  /**\n   * Location Area Code\n   * @min 1\n   * @max 65535\n   */\n    lac: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel)\n   * @min 0\n   * @max 1023\n   */\n    bcch: number,\n  /**\n   * Base Station Identity Code (for instance, color code)\n   * @min 0\n   * @max 63\n   */\n    bsic: number,\n  /**\n   * Cell Identifier (Optional)\n   * @min 0\n   * @max 65535\n   */\n    cid?: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n\n})[],\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n  /**\n   * Timing advance (Optional). Expressed in the units of GSM bits equaling to 48/13 s ~ 1107 meters.\n   * @min 0\n   * @max 63\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * LTE cells (E-UTRA, 4G)\n   * @maxItems 16\n   */\n    lte?: ({\n  /**\n   * E-UTRA Cell Identifier, 28 bits (20 bits eNodeB and 8 bits Cell id). Mcc+mnc+cid uniquely identifies the LTE cell, tac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel (Optional, you must specify a value for this item when you specify a value for pci)\n   * @min 0\n   * @max 65535\n   */\n    earfcn?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * E-UTRA Cell Identifier (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel\n   * @min 0\n   * @max 65535\n   */\n    earfcn: number,\n  /**\n   * Physical Cell Identity\n   * @min 0\n   * @max 503\n   */\n    pci: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n\n})[],\n  /**\n   * Physical Cell Identity (Optional, you must specify a value for this item when you specify a value for earfcn)\n   * @min 0\n   * @max 503\n   */\n    pci?: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n  /**\n   * Timing Advance (Optional). Expressed in the units of 16*Ts (16 Basic time units) = 16/(15000*2048) seconds ~ 156meters. For reference see TS 36.213 and 36.211.\n   * @min 0\n   * @max 1282\n   */\n    ta?: number,\n  /**\n   * Tracking Area Code (Optional)\n   * @min 0\n   * @max 65535\n   */\n    tac?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * TD-SCDMA cell (UTRA-TDD, 3G UMTS TDD)\n   * @maxItems 16\n   */\n    tdscdma?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID) (Optional, you must specify a value for this item when you specify a value for uarfcn).\n   * @min 0\n   * @max 127\n   */\n    cellparams?: number,\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the TDSCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID)\n   * @min 0\n   * @max 127\n   */\n    cellparams: number,\n  /**\n   * Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcn: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Timing advance (Optional). Round-Trip distance presented in the units of 4*c/7.68e6 ~156 meters. That is, the scaling factor is 4 times the chip length at chip rate of 7.68 Mchips/s. Note that at chip rates 1.28 Mchips/s and 3.84 Mchips/s you need to scale according to chip length of 7.68 Mchips/s, that is, multiply by 6 or 2 if needed.\n   * @min 0\n   * @max 1530\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell (Optional, you must specify a value for this item when you specify a value for cellparams).\n   * @min 0\n   * @max 16383\n   */\n    uarfcn?: number,\n\n})[],\n  /**\n   * WCDMA cells (UTRA-FDD, 3G UMTS)\n   * @maxItems 16\n   */\n    wcdma?: ({\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the WCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * UTRAN Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel)\n   * @min 0\n   * @max 511\n   */\n    psc: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel) (Optional, you must specify a value for this item when you specify a value for uarfcndl).\n   * @min 0\n   * @max 511\n   */\n    psc?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell (Optional, you must specify a value for this item when you specify a value for psc).\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl?: number,\n\n})[],\n  /**\n   * WLAN access points\n   * @maxItems 128\n   */\n    wlan?: ({\n  /** Frequency range (GHz). Allowed values are 2.4, 3.65, and 5. (Possible future values include 4.9, 5.9, 60, and 900.) */\n    band?: 2.4 | 3.65 | 5,\n  /**\n   * The MAC address of the WLAN access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. Note that if the SSID contains postfix '_nomap', the AP should not be used for positioning. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac: string,\n  /**\n   * Received signal level (dBm) at the terminal (Optional)\n   * @min -128\n   * @max 0\n   */\n    powrx?: number,\n  /**\n   * Time of the wlan measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * Specifies the time the device telemetry measurements were taken.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n\n})[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/timestamp": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Seconds elapsed since 1 January 1970 00:00:00 UTC. */\n timestamp?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.timestamp": {
        "rendered": "\n/** Seconds elapsed since 1 January 1970 00:00:00 UTC. */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v2/token": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{  accessToken?: string,  expiresIn?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.accessToken": {
        "rendered": " accessToken?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.expiresIn": {
        "rendered": " expiresIn?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v2/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v3/": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.async": {
        "rendered": "\n/** If set to `true`, ingests the device data and responds immediately with an empty response body. */\n async?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The user's project appId. Used together with an external ID to identify the virtual device. */\n    appId?: string,\n    data: ({\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /** Radio measurements used for positioning or radio map contribution. */\n    scan?: {\n  /**\n   * Bluetooth access points\n   * @maxItems 128\n   */\n    bt?: ({\n  /**\n   * Full Identifier as Base64 string. A combination of 10-byte Namespace component and a 6-byte Instance component\n   * @minLength 24\n   * @maxLength 24\n   */\n    eddystoneId?: string,\n  /**\n   * Full Identifier as Base64 string. A combination of 16-byte UUID + 2-byte major + 2-byte minor\n   * @minLength 28\n   * @maxLength 28\n   */\n    iBeaconId?: string,\n  /**\n   * The MAC address of the Bluetooth access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. For privacy reasons positioning based on a single Bluetooth AP is not possible. There must be at least one other matching WLAN or Bluetooth access point. Either MAC, EddystoneId, or iBeaconId is required.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac?: string,\n  /**\n   * Received signal strength (dBm) at the terminal\n   * @min -128\n   * @max 0\n   */\n    rss: number,\n  /**\n   * Time of the measurement (UTC)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * CDMA cells\n   * @maxItems 16\n   */\n    cdma?: ({\n  /**\n   * Base station latitude (Optional)\n   * @min -90\n   * @max 90\n   */\n    baselat?: number,\n  /**\n   * Base station longitude (Optional)\n   * @min -180\n   * @max 180\n   */\n    baselng?: number,\n  /**\n   * Base Station ID, BID\n   * @min 0\n   * @max 65535\n   */\n    bsid: number,\n  /**\n   * CDMA channel frequency (Optional, you must specify a value for this item when you specify a value for pnoffset)\n   * @min 0\n   * @max 2047\n   */\n    channel?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid: number,\n  /**\n   * CDMA Network measurements (Optional)\n   * @maxItems 32\n   */\n    nmr?: ({\n  /**\n   * Base Station ID (Optional)\n   * @min 0\n   * @max 65535\n   */\n    bsid?: number,\n  /**\n   * CDMA channel frequency\n   * @min 0\n   * @max 2047\n   */\n    channel: number,\n  /**\n   * Deprecated. Use 'channel' instead.\n   * @min 0\n   * @max 2047\n   */\n    frequency?: number,\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset\n   * @min 0\n   * @max 511\n   */\n    pnoffset: number,\n\n})[],\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset (Optional, you must specify a value for this item when you specify a value for channel)\n   * @min 0\n   * @max 511\n   */\n    pnoffset?: number,\n  /**\n   * Registration zone (Optional)\n   * @min 0\n   * @max 4095\n   */\n    rz?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /** Indicates in which country the WLAN APs are located (in case cell data is not present in radio_observations) */\n    country?: {\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n\n},\n  /**\n   * Optionally supply this to improve HERE Tracking's positioning service by\n   * contributing the scan data along with a GPS position.\n   */\n    gps?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /**\n   * GSM cells (GERAN)\n   * @maxItems 16\n   */\n    gsm?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel) (Optional, you must specify a value for this item when you specify a value for bsic).\n   * @min 0\n   * @max 1023\n   */\n    bcch?: number,\n  /**\n   * Base Station Identity Code (for instance, color code) (Optional, you must specify a value for this item when you specify a value for bcch).\n   * @min 0\n   * @max 63\n   */\n    bsic?: number,\n  /**\n   * Cell Identifier, 16 bits. Mcc+mnc+lac+cid uniquely identifies the GSM cell.\n   * @min 0\n   * @max 65535\n   */\n    cid: number,\n  /**\n   * Location Area Code\n   * @min 1\n   * @max 65535\n   */\n    lac: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel)\n   * @min 0\n   * @max 1023\n   */\n    bcch: number,\n  /**\n   * Base Station Identity Code (for instance, color code)\n   * @min 0\n   * @max 63\n   */\n    bsic: number,\n  /**\n   * Cell Identifier (Optional)\n   * @min 0\n   * @max 65535\n   */\n    cid?: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n\n})[],\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n  /**\n   * Timing advance (Optional). Expressed in the units of GSM bits equaling to 48/13 s ~ 1107 meters.\n   * @min 0\n   * @max 63\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * LTE cells (E-UTRA, 4G)\n   * @maxItems 16\n   */\n    lte?: ({\n  /**\n   * E-UTRA Cell Identifier, 28 bits (20 bits eNodeB and 8 bits Cell id). Mcc+mnc+cid uniquely identifies the LTE cell, tac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel (Optional, you must specify a value for this item when you specify a value for pci)\n   * @min 0\n   * @max 65535\n   */\n    earfcn?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * E-UTRA Cell Identifier (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel\n   * @min 0\n   * @max 65535\n   */\n    earfcn: number,\n  /**\n   * Physical Cell Identity\n   * @min 0\n   * @max 503\n   */\n    pci: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n\n})[],\n  /**\n   * Physical Cell Identity (Optional, you must specify a value for this item when you specify a value for earfcn)\n   * @min 0\n   * @max 503\n   */\n    pci?: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n  /**\n   * Timing Advance (Optional). Expressed in the units of 16*Ts (16 Basic time units) = 16/(15000*2048) seconds ~ 156meters. For reference see TS 36.213 and 36.211.\n   * @min 0\n   * @max 1282\n   */\n    ta?: number,\n  /**\n   * Tracking Area Code (Optional)\n   * @min 0\n   * @max 65535\n   */\n    tac?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * TD-SCDMA cell (UTRA-TDD, 3G UMTS TDD)\n   * @maxItems 16\n   */\n    tdscdma?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID) (Optional, you must specify a value for this item when you specify a value for uarfcn).\n   * @min 0\n   * @max 127\n   */\n    cellparams?: number,\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the TDSCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID)\n   * @min 0\n   * @max 127\n   */\n    cellparams: number,\n  /**\n   * Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcn: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Timing advance (Optional). Round-Trip distance presented in the units of 4*c/7.68e6 ~156 meters. That is, the scaling factor is 4 times the chip length at chip rate of 7.68 Mchips/s. Note that at chip rates 1.28 Mchips/s and 3.84 Mchips/s you need to scale according to chip length of 7.68 Mchips/s, that is, multiply by 6 or 2 if needed.\n   * @min 0\n   * @max 1530\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell (Optional, you must specify a value for this item when you specify a value for cellparams).\n   * @min 0\n   * @max 16383\n   */\n    uarfcn?: number,\n\n})[],\n  /**\n   * WCDMA cells (UTRA-FDD, 3G UMTS)\n   * @maxItems 16\n   */\n    wcdma?: ({\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the WCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * UTRAN Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel)\n   * @min 0\n   * @max 511\n   */\n    psc: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel) (Optional, you must specify a value for this item when you specify a value for uarfcndl).\n   * @min 0\n   * @max 511\n   */\n    psc?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell (Optional, you must specify a value for this item when you specify a value for psc).\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl?: number,\n\n})[],\n  /**\n   * WLAN access points\n   * @maxItems 128\n   */\n    wlan?: ({\n  /** Frequency range (GHz). Allowed values are 2.4, 3.65, and 5. (Possible future values include 4.9, 5.9, 60, and 900.) */\n    band?: 2.4 | 3.65 | 5,\n  /**\n   * The MAC address of the WLAN access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. Note that if the SSID contains postfix '_nomap', the AP should not be used for positioning. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac: string,\n  /**\n   * Received signal level (dBm) at the terminal (Optional)\n   * @min -128\n   * @max 0\n   */\n    powrx?: number,\n  /**\n   * Time of the wlan measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * Specifies the time the device telemetry measurements were taken.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n\n})[],\n  /**\n   * Tracking ID or application specific external ID, needed only if ingesting on behalf of another device.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id?: string,\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue, \n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.payload": {
        "rendered": "\n/** A free format JSON object.\nThe maximum size is 1000B.\n */\n payload?: hasuraSdk.JSONValue,",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system": {
        "rendered": "\n/** Contains device configuration settings.\n */\n system: { \n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean, \n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", }, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number, \n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, }, \n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, }, \n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[], \n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean, \n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number, \n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean, \n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[], \n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.detectOutliers": {
        "rendered": "\n/** A boolean value that sets outlier detection on or off */\n detectOutliers?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking": {
        "rendered": "\n/** Tracking can be disabled and enabled by defining disableTracking object.\nIn order to disable tracking, one must at least provide the begin time of the disabling\nperiod and define either position or sensor properties one wants to disable. One can also\ndisable both position and sensors at the same time. By default tracking is enabled.\n */\n disableTracking?: { \n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[], \n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\", \n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\", },",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.disableTracking.periods": {
        "rendered": "\n/** Define begin and end of the disabling period. All trace points with timestamp that falls between begin and end times will be disabled according to the settings defined in the position and sensors properties.\n */\n periods?: ({ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, })[],",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name": {
        "rendered": "{ \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number, \n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name.begin": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nBegin time of the tracking disabling period.\n\nBegin must be smaller than end. Begin must be greater or equal to current time.\nBegin can be set without end. If there exists already end time which is earlier\nthan given new begin time, the existing end time will be deleted.\n */\n begin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.periods.__no_name.end": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC\n\nEnd time of the tracking disabling period.\n\nEnd must be greater than begin. End must be greater or equal to current time.\nEnd can be set without begin if begin is already set.\n */\n end?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.disableTracking.position": {
        "rendered": "\n/** Define position methods to be disabled */\n position?: \"all\" | (\"bt\" | \"country\" | \"gsm\" | \"wcdma\" | \"tdscdma\" | \"lte\" | \"cdma\" | \"wlan\" | \"gps\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.disableTracking.sensors": {
        "rendered": "\n/** Define sensors to be disabled */\n sensors?: \"all\" | (\"accelerationG\" | \"deviceIsAttached\" | \"deviceIsStationary\" | \"batteryIsCharging\" | \"batteryLevel\" | \"pressureHpa\" | \"relativeHumidity\" | \"deviceIsTampered\" | \"temperatureC\" | \"tiltDegree\")[] | \"\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.lastModifiedGeofenceTimestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to geofences that device is associated\nwith. This value is zero when device hasn't yet been associated with\nany geofence. This is set by HERE Tracking when any geofences\nassociated with the device is modified or removed. Also adding and\nremoving geofence associations update this value.\n */\n lastModifiedGeofenceTimestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate": {
        "rendered": "\n/** This can be used to specify the rates at which the device performs certain tasks. */\n rate?: { \n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number, \n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number, \n/** The rate at which to send sample results in milliseconds */\n sendMs?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.distanceM": {
        "rendered": "\n/** Send an update if the device has moved farther than the specified distance in meters */\n distanceM?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.sampleMs": {
        "rendered": "\n/** The rate at which to sample signals in milliseconds */\n sampleMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.rate.sendMs": {
        "rendered": "\n/** The rate at which to send sample results in milliseconds */\n sendMs?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig": {
        "rendered": "\n/** The device sensors alarm configuration.\n */\n sensorAlarmConfig?: { \n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number, \n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number, \n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number, \n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number, \n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number, \n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number, \n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number, \n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number, \n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number, \n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number, \n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number, \n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number, \n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean, \n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertAccelerationGMax": {
        "rendered": "\n/** An upper threshold value for acceleration in g-forces. */\n alertAccelerationGMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertAccelerationGMin": {
        "rendered": "\n/** A lower threshold value for acceleration in g-forces. */\n alertAccelerationGMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertBatteryLevelPMax": {
        "rendered": "\n/** An upper threshold value for battery level percentage. */\n alertBatteryLevelPMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertBatteryLevelPMin": {
        "rendered": "\n/** A lower threshold value for battery level percentage. */\n alertBatteryLevelPMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertPressureHpaMax": {
        "rendered": "\n/** An upper threshold value for pressure in hectopascals. */\n alertPressureHpaMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertPressureHpaMin": {
        "rendered": "\n/** A lower threshold value for pressure in hectopascals. */\n alertPressureHpaMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertRelativeHumidityMax": {
        "rendered": "\n/** An upper threshold value for relative humidity percentage. */\n alertRelativeHumidityMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertRelativeHumidityMin": {
        "rendered": "\n/** A lower threshold value for relative humidity percentage. */\n alertRelativeHumidityMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTemperatureCMax": {
        "rendered": "\n/** An upper threshold value for temperature in degrees Celsius. */\n alertTemperatureCMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTemperatureCMin": {
        "rendered": "\n/** A lower threshold value for temperature in degrees Celsius. */\n alertTemperatureCMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTiltDegreeMax": {
        "rendered": "\n/** An upper threshold value for tilt in degrees. */\n alertTiltDegreeMax?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.alertTiltDegreeMin": {
        "rendered": "\n/** A lower threshold value for tilt in degrees. */\n alertTiltDegreeMin?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.isAttachAlertEnabled": {
        "rendered": "\n/** True if attach sensor alert in device is enabled. */\n isAttachAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorAlarmConfig.isTamperAlertEnabled": {
        "rendered": "\n/** True if tamper sensor alert in device is enabled. */\n isTamperAlertEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorLoggingConfigurations": {
        "rendered": "\n/** An array of objects that holds sensor logging configurations */\n sensorLoggingConfigurations?: ({ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name": {
        "rendered": "{ \n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number, \n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\", }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name.samplingFrequency": {
        "rendered": "\n/** Sampling frequrency of single sensor loggin configuration (in milliseconds) */\n samplingFrequency?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.sensorLoggingConfigurations.__no_name.type": {
        "rendered": "\n/** Type of single sensor logging configuration */\n type?: \"acceleration\" | \"pressure\" | \"temperature\" | \"humidity\" | \"gnss\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.sensorLoggingEnabled": {
        "rendered": "\n/** Flag that sets sensor logging on or off */\n sensorLoggingEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.stateVersion": {
        "rendered": "\n/** The version of the state of a device. This should be incremented only by HERE Tracking.\n */\n stateVersion?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.syncGeofences": {
        "rendered": "\n/** A boolean value that sets efficient geofencing on or off */\n syncGeofences?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations": {
        "rendered": "\n/** An array of objects that holds wlan configurations */\n wlanConfigurations?: ({ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, })[],",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name": {
        "rendered": "{ \n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string, \n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\", \n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string, \n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean, }",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name.password": {
        "rendered": "\n/** WLAN password. Please note that the password is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. Password is required if security mode is other then 'none'. */\n password?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations.__no_name.securityMode": {
        "rendered": "\n/** Selected security mode */\n securityMode?: \"none\" | \"wpa2psk\",",
        "requiresRelaxedTypeAnnotation": true
      },
      ".__no_name.system.wlanConfigurations.__no_name.ssid": {
        "rendered": "\n/** Name given to a WLAN that is used by the client to access a WLAN network. Please note that the SSID is stored to the device unencrypted. Do not use secure private networks, such as Intranet, for tracker WLAN connectivity. */\n ssid?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConfigurations.__no_name.ssidIsHidden": {
        "rendered": "\n/** Flag that informs if SSID is hidden */\n ssidIsHidden?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.system.wlanConnectivityEnabled": {
        "rendered": "\n/** A boolean value that sets wlan connectivity on or off */\n wlanConnectivityEnabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.timestamp": {
        "rendered": "\n/** Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n\nThe time of the last update to the desired shadow.\n */\n timestamp?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "post__/v3/batch": {
    "query": {},
    "body": {
      ".data": {
        "rendered": "\n/** Request body */\n data: {\n  /** The user's project appId. Used together with an external ID to identify the virtual devices. */\n    appId?: string,\n    data: (({\n  /**\n   * A free format JSON object.\n   * The maximum size is 1000B.\n   */\n    payload?: hasuraSdk.JSONValue,\n  /** The device location */\n    position?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * Confidence level in percent for the accuracy/uncertainty. If not specified, the default is 68 (this corresponds to a 68% probability that the true position is within the accuracy/uncertainty radius of the position; the higher the number, the greater the confidence level).\n   * @min 50\n   * @max 95\n   */\n    confidence?: number,\n  /** The building where the measurements were taken */\n    floor?: {\n  /**\n   * The building id\n   * @min 1\n   * @max 100\n   */\n    id: string,\n  /**\n   * The floor in the building in integer format\n   * @min -999\n   * @max 999\n   */\n    level: number,\n  /**\n   * The building name\n   * @min 1\n   * @max 255\n   */\n    name: string,\n\n},\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Timestamp of the position\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n  /** Position type, 'gnss' (satellite based), 'cell' or 'wlan' (network based) */\n    type?: string,\n  /**\n   * The total number of observed WLAN APs in the scan used for producing the position. ('wlan' position type only)\n   * @min 1\n   * @max 254\n   */\n    wlancount?: number,\n\n},\n  /** Radio measurements used for positioning or radio map contribution. */\n    scan?: {\n  /**\n   * Bluetooth access points\n   * @maxItems 128\n   */\n    bt?: ({\n  /**\n   * Full Identifier as Base64 string. A combination of 10-byte Namespace component and a 6-byte Instance component\n   * @minLength 24\n   * @maxLength 24\n   */\n    eddystoneId?: string,\n  /**\n   * Full Identifier as Base64 string. A combination of 16-byte UUID + 2-byte major + 2-byte minor\n   * @minLength 28\n   * @maxLength 28\n   */\n    iBeaconId?: string,\n  /**\n   * The MAC address of the Bluetooth access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. For privacy reasons positioning based on a single Bluetooth AP is not possible. There must be at least one other matching WLAN or Bluetooth access point. Either MAC, EddystoneId, or iBeaconId is required.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac?: string,\n  /**\n   * Received signal strength (dBm) at the terminal\n   * @min -128\n   * @max 0\n   */\n    rss: number,\n  /**\n   * Time of the measurement (UTC)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * CDMA cells\n   * @maxItems 16\n   */\n    cdma?: ({\n  /**\n   * Base station latitude (Optional)\n   * @min -90\n   * @max 90\n   */\n    baselat?: number,\n  /**\n   * Base station longitude (Optional)\n   * @min -180\n   * @max 180\n   */\n    baselng?: number,\n  /**\n   * Base Station ID, BID\n   * @min 0\n   * @max 65535\n   */\n    bsid: number,\n  /**\n   * CDMA channel frequency (Optional, you must specify a value for this item when you specify a value for pnoffset)\n   * @min 0\n   * @max 2047\n   */\n    channel?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid: number,\n  /**\n   * CDMA Network measurements (Optional)\n   * @maxItems 32\n   */\n    nmr?: ({\n  /**\n   * Base Station ID (Optional)\n   * @min 0\n   * @max 65535\n   */\n    bsid?: number,\n  /**\n   * CDMA channel frequency\n   * @min 0\n   * @max 2047\n   */\n    channel: number,\n  /**\n   * Deprecated. Use 'channel' instead.\n   * @min 0\n   * @max 2047\n   */\n    frequency?: number,\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset\n   * @min 0\n   * @max 511\n   */\n    pnoffset: number,\n\n})[],\n  /**\n   * Pilot Power (dBm) (Optional). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49.\n   * @min -142\n   * @max -49\n   */\n    pilotpower?: number,\n  /**\n   * Pseudonoise offset (Optional, you must specify a value for this item when you specify a value for channel)\n   * @min 0\n   * @max 511\n   */\n    pnoffset?: number,\n  /**\n   * Registration zone (Optional)\n   * @min 0\n   * @max 4095\n   */\n    rz?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /** Indicates in which country the WLAN APs are located (in case cell data is not present in radio_observations) */\n    country?: {\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n\n},\n  /**\n   * Optionally supply this to improve HERE Tracking's positioning service by\n   * contributing the scan data along with a GPS position.\n   */\n    gps?: {\n  /**\n   * Uncertainty circle radius in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    accuracy: number,\n  /** Altitude in meters (referenced to the WGS-84 ellipsoid) negative or positive. */\n    alt?: number,\n  /**\n   * Uncertainty of the altitude estimate in meters (degree of confidence according to the 'confidence' parameter).\n   * @min 0\n   */\n    altaccuracy?: number,\n  /**\n   * GPS/GNSS heading in degrees, clockwise from true north. You must specify a value for this item when you specify a value for speed.\n   * @min 0\n   * @max 359\n   */\n    heading?: number,\n  /**\n   * Latitude in WGS-84 format, decimal representation ranging from -90 to 90.\n   * @min -90\n   * @max 90\n   */\n    lat: number,\n  /**\n   * Longitude in WGS-84 format, decimal representation ranging from -180 to 180.\n   * @min -180\n   * @max 180\n   */\n    lng: number,\n  /**\n   * Number of GPS/GNSS satellites used for the calculation of the position fix. ('gnss' position type only)\n   * @min 1\n   * @max 50\n   */\n    satellitecount?: number,\n  /**\n   * GPS/GNSS speed of the device (m/s). One must specify a value for this item when one specifies a value for heading.\n   * @min 0\n   */\n    speed?: number,\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp?: number,\n\n},\n  /**\n   * GSM cells (GERAN)\n   * @maxItems 16\n   */\n    gsm?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel) (Optional, you must specify a value for this item when you specify a value for bsic).\n   * @min 0\n   * @max 1023\n   */\n    bcch?: number,\n  /**\n   * Base Station Identity Code (for instance, color code) (Optional, you must specify a value for this item when you specify a value for bcch).\n   * @min 0\n   * @max 63\n   */\n    bsic?: number,\n  /**\n   * Cell Identifier, 16 bits. Mcc+mnc+lac+cid uniquely identifies the GSM cell.\n   * @min 0\n   * @max 65535\n   */\n    cid: number,\n  /**\n   * Location Area Code\n   * @min 1\n   * @max 65535\n   */\n    lac: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * Broadcast Control Channel (Synonymous to ARFCN = Absolute Radio Frequency Channel)\n   * @min 0\n   * @max 1023\n   */\n    bcch: number,\n  /**\n   * Base Station Identity Code (for instance, color code)\n   * @min 0\n   * @max 63\n   */\n    bsic: number,\n  /**\n   * Cell Identifier (Optional)\n   * @min 0\n   * @max 65535\n   */\n    cid?: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n\n})[],\n  /**\n   * Received Signal power (dBm) (Optional). Power less than -110dBm should be mapped to -110. Power greater than -25dBm should be mapped to -25.\n   * @min -110\n   * @max -25\n   */\n    rxlevel?: number,\n  /**\n   * Timing advance (Optional). Expressed in the units of GSM bits equaling to 48/13 s ~ 1107 meters.\n   * @min 0\n   * @max 63\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * LTE cells (E-UTRA, 4G)\n   * @maxItems 16\n   */\n    lte?: ({\n  /**\n   * E-UTRA Cell Identifier, 28 bits (20 bits eNodeB and 8 bits Cell id). Mcc+mnc+cid uniquely identifies the LTE cell, tac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel (Optional, you must specify a value for this item when you specify a value for pci)\n   * @min 0\n   * @max 65535\n   */\n    earfcn?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional)\n   * @maxItems 16\n   */\n    nmr?: ({\n  /**\n   * E-UTRA Cell Identifier (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * Evolved Absolute Radio Frequency Channel\n   * @min 0\n   * @max 65535\n   */\n    earfcn: number,\n  /**\n   * Physical Cell Identity\n   * @min 0\n   * @max 503\n   */\n    pci: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n\n})[],\n  /**\n   * Physical Cell Identity (Optional, you must specify a value for this item when you specify a value for earfcn)\n   * @min 0\n   * @max 503\n   */\n    pci?: number,\n  /**\n   * Reference Signal Received Power = RSRP (dBm) (Optional, you must specify a value for this item when you specify a value for rsrq). Power less than -140dBm should be mapped to -140. Power greater than -44dBm should be mapped to -44.\n   * @min -140\n   * @max -44\n   */\n    rsrp?: number,\n  /**\n   * Reference Signal Received Quality = RSRQ (dB) (Optional). Values less than -19.5dB should be mapped to -19.5, and values greater than -3dB should be mapped to -3dB.\n   * @min -19.5\n   * @max -3\n   */\n    rsrq?: number,\n  /**\n   * Timing Advance (Optional). Expressed in the units of 16*Ts (16 Basic time units) = 16/(15000*2048) seconds ~ 156meters. For reference see TS 36.213 and 36.211.\n   * @min 0\n   * @max 1282\n   */\n    ta?: number,\n  /**\n   * Tracking Area Code (Optional)\n   * @min 0\n   * @max 65535\n   */\n    tac?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n  /**\n   * TD-SCDMA cell (UTRA-TDD, 3G UMTS TDD)\n   * @maxItems 16\n   */\n    tdscdma?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID) (Optional, you must specify a value for this item when you specify a value for uarfcn).\n   * @min 0\n   * @max 127\n   */\n    cellparams?: number,\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the TDSCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * Cell Parameters ID (CDMA Spreading Code ID)\n   * @min 0\n   * @max 127\n   */\n    cellparams: number,\n  /**\n   * Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcn: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional, you must specify a value for this item when you specify a value for rscp).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional, you must specify a value for this item when you specify a value for pathloss). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Timing advance (Optional). Round-Trip distance presented in the units of 4*c/7.68e6 ~156 meters. That is, the scaling factor is 4 times the chip length at chip rate of 7.68 Mchips/s. Note that at chip rates 1.28 Mchips/s and 3.84 Mchips/s you need to scale according to chip length of 7.68 Mchips/s, that is, multiply by 6 or 2 if needed.\n   * @min 0\n   * @max 1530\n   */\n    ta?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Carrier frequency of a UTRA-TDD Serving Cell (Optional, you must specify a value for this item when you specify a value for cellparams).\n   * @min 0\n   * @max 16383\n   */\n    uarfcn?: number,\n\n})[],\n  /**\n   * WCDMA cells (UTRA-FDD, 3G UMTS)\n   * @maxItems 16\n   */\n    wcdma?: ({\n  /**\n   * UTRAN Cell Identifier, 28 bits (12 bits RNC and 16 bits Cell id). Mcc+mnc+cid uniquely identifies the WCDMA cell, lac is optional.\n   * @min 0\n   * @max 268435455\n   */\n    cid: number,\n  /**\n   * Location Area Code (Optional)\n   * @min 1\n   * @max 65535\n   */\n    lac?: number,\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc: number,\n  /**\n   * Network measurements (Optional). Maximum of 8 uarfcndl times maximum of 32 psc.\n   * @maxItems 256\n   */\n    nmr?: ({\n  /**\n   * UTRAN Cell Identifier (uc-id) (Optional)\n   * @min 0\n   * @max 268435455\n   */\n    cid?: number,\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel)\n   * @min 0\n   * @max 511\n   */\n    psc: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl: number,\n\n})[],\n  /**\n   * UTRAN path loss (dB) (Optional).\n   * @min 46\n   * @max 158\n   */\n    pathloss?: number,\n  /**\n   * Primary Scrambling Code (Primary CPICH, Primary Control Pilot Channel) (Optional, you must specify a value for this item when you specify a value for uarfcndl).\n   * @min 0\n   * @max 511\n   */\n    psc?: number,\n  /**\n   * Received Signal Code Power = RSCP (dBm) (Optional). Power less than -120dBm should be mapped to -120. Power greater than -25dBm should be mapped to -25.\n   * @min -120\n   * @max -25\n   */\n    rscp?: number,\n  /**\n   * Time of the cell measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n  /**\n   * Downlink frequency of a UTRA-FDD Serving Cell (Optional, you must specify a value for this item when you specify a value for psc).\n   * @min 0\n   * @max 16383\n   */\n    uarfcndl?: number,\n\n})[],\n  /**\n   * WLAN access points\n   * @maxItems 128\n   */\n    wlan?: ({\n  /** Frequency range (GHz). Allowed values are 2.4, 3.65, and 5. (Possible future values include 4.9, 5.9, 60, and 900.) */\n    band?: 2.4 | 3.65 | 5,\n  /**\n   * The MAC address of the WLAN access point. MAC-48 address with colon (:) or hyphen (-) separators, upper or lower case hex digits. Note that if the SSID contains postfix '_nomap', the AP should not be used for positioning. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell.\n   * @pattern ^(([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})|(([a-fA-F0-9]{2}-){5}[a-fA-F0-9]{2})$\n   */\n    mac: string,\n  /**\n   * Received signal level (dBm) at the terminal (Optional)\n   * @min -128\n   * @max 0\n   */\n    powrx?: number,\n  /**\n   * Time of the wlan measurement (UTC) (Optional)\n   * @format date-time\n   */\n    timestamp?: string,\n\n})[],\n\n},\n  /**\n   * Contains device-reported sensor data and device configuration settings.\n   * `stateVersion` property contains the version of the last\n   * known `desired` state seen by the device.\n   */\n    system?: {\n  /**\n   * Information about the client device.\n   * @example {\"accelerometerSensorRange\":[2],\"diagnosticscode\":0,\"diskquota\":256,\"firmware\":\"heroltexx...\",\"hasAccelerometerSensor\":true,\"hasAttachSensor\":true,\"hasHumiditySensor\":true,\"hasNoBattery\":false,\"hasPressureSensor\":true,\"hasTamperSensor\":true,\"hasTemperatureSensor\":true,\"homenetwork\":[],\"manufacturer\":\"Samsung\",\"model\":\"SM-G930F\",\"name\":\"HERE Tracker\",\"platform\":\"Android\",\"version\":\"1.6.1\"}\n   */\n    client?: {\n  /**\n   * Specifies the range of measurable acceleration, representation\n   * unit g (9.8 m/s^2). If more than one accelerometer is available,\n   * each element in the list will represent individual accelerometer.\n   * Each value represents a single \"+/-\" range.\n   * For example, value 2 means that sensor is capable to measure\n   * acceleration within the range of [-2 g, +2 g].\n   * @maxItems 5\n   */\n    accelerometerSensorRange?: (number)[],\n  /** Device diagnostics code. */\n    diagnosticscode?: number,\n  /**\n   * Available disk quota in kilobytes.\n   * @min 0\n   */\n    diskquota?: number,\n  /**\n   * Device firmware version information\n   * @minLength 1\n   * @maxLength 150\n   */\n    firmware?: string,\n  /** True if a device has a sensor to measure acceleration. */\n    hasAccelerometerSensor?: boolean,\n  /** True if a device has a sensor to detect if the device is attached to or detached from an object. */\n    hasAttachSensor?: boolean,\n  /** True if a device has a sensor to measure humidity. */\n    hasHumiditySensor?: boolean,\n  /** False if a device has a battery. */\n    hasNoBattery?: boolean,\n  /** True if a device has a sensor to measure pressure. */\n    hasPressureSensor?: boolean,\n  /** True if a device has a sensor to detect if device is disassembled. */\n    hasTamperSensor?: boolean,\n  /** True if a device has a sensor to measure temperature. */\n    hasTemperatureSensor?: boolean,\n  /**\n   * Information about subscriber home network - 3GPP MCC+MNC or 3GPP2 SID+NID. Dual-SIM devices can provide information on both subscriptions.\n   * @maxItems 2\n   */\n    homenetwork?: ({\n  /**\n   * Mobile Country Code\n   * @min 200\n   * @max 999\n   */\n    mcc?: number,\n  /**\n   * Mobile Network Code\n   * @min 0\n   * @max 999\n   */\n    mnc?: number,\n  /**\n   * Network Id, NID\n   * @min 0\n   * @max 65535\n   */\n    nid?: number,\n  /**\n   * System Id, SID\n   * @min 1\n   * @max 32767\n   */\n    sid?: number,\n\n})[],\n  /**\n   * Manufacturer of the device (hardware)\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model of the device (hardware)\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n  /**\n   * Software information of all updateable chips.\n   * @maxItems 10\n   */\n    modules?: ({\n  /**\n   * Installed firmware version\n   * @minLength 3\n   * @maxLength 60\n   */\n    firmwareVersion?: string,\n  /**\n   * Manufacturer name\n   * @minLength 2\n   * @maxLength 50\n   */\n    manufacturer?: string,\n  /**\n   * Model or chip name\n   * @minLength 1\n   * @maxLength 50\n   */\n    model?: string,\n\n})[],\n  /**\n   * Name of the client software accessing the HERE API\n   * @minLength 3\n   * @maxLength 50\n   */\n    name?: string,\n  /**\n   * Software platform information of the device, for example operating system name and version.\n   * @minLength 3\n   * @maxLength 50\n   */\n    platform?: string,\n  /**\n   * Version of the client software in format X.Y.Z, where X [0..255] is a major, Y [0..255] is a minor, and Z [0..65535] is a build version number. Increase the version/build number for each release of the client.\n   * @minLength 3\n   * @maxLength 60\n   */\n    version?: string,\n\n},\n  /**\n   * SIM card integrated circuit card identifier (ICCID)\n   * @minLength 18\n   * @maxLength 22\n   */\n    iccid?: string,\n  /**\n   * The IMSI of the device's SIM card.\n   * @pattern ^[0-9]{1,15}$\n   * @example \"123456789012345\"\n   */\n    imsi?: string,\n  /**\n   * Tracker mode status of the device. When a tracker is in a normal mode, it\n   * can send telemetry and, for example, use its GNSS receiver if it has one.\n   * A tracker switches into flight mode once it detects that it's in an\n   * airplane, and leaves that mode once airplane lands. Transport mode has to\n   * be triggered by the user, and it's used, for example, during shipping from\n   * continent to another. Sleep mode is used when a tracker is stored in\n   * a warehouse, and it's triggered by entering or leaving some defined\n   * geofence.\n   */\n    mode?: \"unknown\" | \"normal\" | \"flight\" | \"transport\" | \"sleep\",\n  /**\n   * The phone number of the device's SIM card in the international E.164 format. All the country codes should be prefixed a with \"+\" instead of \"00\".\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   * @example \"+491234567890\"\n   */\n    phoneNumber?: string,\n  /** The last known device sensor data reported by the device. */\n    reportedSensorData?: {\n  /**\n   * A g-force value of acceleration.\n   * @min -100\n   * @max 100\n   */\n    accelerationG?: number,\n  /** True if device battery is charging. */\n    batteryIsCharging?: boolean,\n  /**\n   * A value of percentage battery level.\n   * @min 0\n   * @max 100\n   */\n    batteryLevel?: number,\n  /** True if device is attached to an object. */\n    deviceIsAttached?: boolean,\n  /** True if device hasn't detected movement. */\n    deviceIsStationary?: boolean,\n  /** True if device is tampered. */\n    deviceIsTampered?: boolean,\n  /**\n   * A value of pressure in hectopascal.\n   * @min 300\n   * @max 1500\n   */\n    pressureHpa?: number,\n  /**\n   * A value of relative humidity in percent.\n   * @min 0\n   * @max 100\n   */\n    relativeHumidity?: number,\n  /**\n   * A value of temperature in celcius.\n   * @min -70\n   * @max 100\n   */\n    temperatureC?: number,\n  /** A value of tilt in degrees. */\n    tiltDegree?: number,\n\n},\n  /**\n   * The version of the state of a device. This should be incremented only by HERE Tracking.\n   * @min 0\n   */\n    stateVersion?: number,\n\n},\n  /**\n   * Milliseconds elapsed since 1 January 1970 00:00:00 UTC.\n   * \n   * Specifies the time the device telemetry measurements were taken.\n   * @min 2\n   * @max 4102448400000\n   */\n    timestamp: number,\n\n} & {\n  /**\n   * Tracking ID or application specific external ID.\n   * @minLength 1\n   * @maxLength 50\n   */\n    id?: string,\n\n}))[],\n\n},",
        "requiresRelaxedTypeAnnotation": true
      },
      ".data.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      },
      ".data.__no_name.__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "hasuraSdk.JSONValue",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.__no_name": {
        "rendered": "__undefined",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v3/health": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "{ \n/** Health status */\n message?: string, }",
        "requiresRelaxedTypeAnnotation": false
      },
      ".__no_name.message": {
        "rendered": "\n/** Health status */\n message?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  },
  "get__/v3/version": {
    "query": {},
    "body": {},
    "path": {},
    "response": {
      ".__no_name": {
        "rendered": "",
        "requiresRelaxedTypeAnnotation": false
      }
    }
  }
}