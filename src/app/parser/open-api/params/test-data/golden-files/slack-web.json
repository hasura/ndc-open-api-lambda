{
  "post__/admin.apps.approve": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.apps.approved.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,  team_id?: string,  enterprise_id?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.enterprise_id": {
        "rendered": " enterprise_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.apps.requests.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,  team_id?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.apps.restrict": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.apps.restricted.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,  team_id?: string,  enterprise_id?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.apps:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.enterprise_id": {
        "rendered": " enterprise_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.archive": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.convertToPrivate": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.create": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.delete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.disconnectShared": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.conversations.ekm.listOriginalConnectedChannelInfo": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.conversations:read` */\n token: string, \n/** A comma-separated list of channels to filter to. */\n channel_ids?: string, \n/** A comma-separated list of the workspaces to which the channels you would like returned belong. */\n team_ids?: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.conversations:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel_ids": {
        "rendered": "\n/** A comma-separated list of channels to filter to. */\n channel_ids?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_ids": {
        "rendered": "\n/** A comma-separated list of the workspaces to which the channels you would like returned belong. */\n team_ids?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.conversations.getConversationPrefs": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** The channel to get preferences for. */\n channel_id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel_id": {
        "rendered": "\n/** The channel to get preferences for. */\n channel_id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.conversations.getTeams": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** The channel to determine connected workspaces within the organization for. */\n channel_id: string, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel_id": {
        "rendered": "\n/** The channel to determine connected workspaces within the organization for. */\n channel_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.invite": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.rename": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.restrictAccess.addGroup": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.conversations.restrictAccess.listGroups": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.conversations:read` */\n token: string,  channel_id: string, \n/** The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. */\n team_id?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.conversations:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel_id": {
        "rendered": " channel_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.restrictAccess.removeGroup": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.conversations.search": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Comma separated string of team IDs, signifying the workspaces to search through. */\n team_ids?: string, \n/** Name of the the channel to query by. */\n query?: string, \n/** Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string, \n/** The type of channel to include or exclude in the search. For example `private` will search private channels, while `private_exclude` will exclude them. For a full list of types, check the [Types section](#types). */\n search_channel_types?: string, \n/** Possible values are `relevant` (search ranking based on what we think is closest), `name` (alphabetical), `member_count` (number of users in the channel), and `created` (date channel was created). You can optionally pair this with the `sort_dir` arg to change how it is sorted  */\n sort?: string, \n/** Sort direction. Possible values are `asc` for ascending order like (1, 2, 3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b, a) */\n sort_dir?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_ids": {
        "rendered": "\n/** Comma separated string of team IDs, signifying the workspaces to search through. */\n team_ids?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.query": {
        "rendered": "\n/** Name of the the channel to query by. */\n query?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.search_channel_types": {
        "rendered": "\n/** The type of channel to include or exclude in the search. For example `private` will search private channels, while `private_exclude` will exclude them. For a full list of types, check the [Types section](#types). */\n search_channel_types?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** Possible values are `relevant` (search ranking based on what we think is closest), `name` (alphabetical), `member_count` (number of users in the channel), and `created` (date channel was created). You can optionally pair this with the `sort_dir` arg to change how it is sorted  */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort_dir": {
        "rendered": "\n/** Sort direction. Possible values are `asc` for ascending order like (1, 2, 3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b, a) */\n sort_dir?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.setConversationPrefs": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.setTeams": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.conversations.unarchive": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.emoji.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.emoji.addAlias": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.emoji.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.emoji.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.emoji.rename": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.inviteRequests.approve": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.inviteRequests.approved.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** ID for the workspace where the invite requests were made. */\n team_id?: string, \n/** Value of the `next_cursor` field sent as part of the previous API response */\n cursor?: string, \n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** ID for the workspace where the invite requests were made. */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Value of the `next_cursor` field sent as part of the previous API response */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.inviteRequests.denied.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** ID for the workspace where the invite requests were made. */\n team_id?: string, \n/** Value of the `next_cursor` field sent as part of the previous api response */\n cursor?: string, \n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** ID for the workspace where the invite requests were made. */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Value of the `next_cursor` field sent as part of the previous api response */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.inviteRequests.deny": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.inviteRequests.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** ID for the workspace where the invite requests were made. */\n team_id?: string, \n/** Value of the `next_cursor` field sent as part of the previous API response */\n cursor?: string, \n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** ID for the workspace where the invite requests were made. */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Value of the `next_cursor` field sent as part of the previous API response */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.teams.admins.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string, \n/** The maximum number of items to return. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,  team_id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.create": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.teams.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The maximum number of items to return. Must be between 1 - 100 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 100 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.teams.owners.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string,  team_id: string, \n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin.teams:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Must be between 1 - 1000 both inclusive. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.teams.settings.info": {
    "query": {
      ".query": {
        "rendered": " query?: {  team_id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": " team_id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.settings.setDefaultChannels": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.settings.setDescription": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.settings.setDiscoverability": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.settings.setIcon": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.teams.settings.setName": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.usergroups.addChannels": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.usergroups.addTeams": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.usergroups.listChannels": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** ID of the IDP group to list default channels for. */\n usergroup_id: string, \n/** ID of the the workspace. */\n team_id?: string, \n/** Flag to include or exclude the count of members per channel. */\n include_num_members?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.usergroup_id": {
        "rendered": "\n/** ID of the IDP group to list default channels for. */\n usergroup_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** ID of the the workspace. */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_num_members": {
        "rendered": "\n/** Flag to include or exclude the count of members per channel. */\n include_num_members?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.usergroups.removeChannels": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.assign": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.invite": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/admin.users.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** The ID (`T1234`) of the workspace. */\n team_id: string, \n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string, \n/** Limit for how many users to be retrieved per page */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** The ID (`T1234`) of the workspace. */\n team_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Set `cursor` to `next_cursor` returned by the previous call to list items in the next page. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** Limit for how many users to be retrieved per page */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.session.invalidate": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.session.reset": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.setAdmin": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.setExpiration": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.setOwner": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/admin.users.setRegular": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/api.test": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Error response to return */\n error?: string, \n/** example property to return */\n foo?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.error": {
        "rendered": "\n/** Error response to return */\n error?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.foo": {
        "rendered": "\n/** example property to return */\n foo?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.event.authorizations.list": {
    "query": {
      ".query": {
        "rendered": " query?: {  event_context: string,  cursor?: string,  limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.event_context": {
        "rendered": " event_context: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": " cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": " limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `none` */\n token?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.request": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** A comma separated list of scopes to request for */\n scopes: string, \n/** Token used to trigger the permissions API */\n trigger_id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.scopes": {
        "rendered": "\n/** A comma separated list of scopes to request for */\n scopes: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trigger_id": {
        "rendered": "\n/** Token used to trigger the permissions API */\n trigger_id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.resources.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, \n/** The maximum number of items to return. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.scopes.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.users.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, \n/** The maximum number of items to return. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.permissions.users.request": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** A comma separated list of user scopes to request for */\n scopes: string, \n/** Token used to trigger the request */\n trigger_id: string, \n/** The user this scope is being requested for */\n user: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.scopes": {
        "rendered": "\n/** A comma separated list of user scopes to request for */\n scopes: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trigger_id": {
        "rendered": "\n/** Token used to trigger the request */\n trigger_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** The user this scope is being requested for */\n user: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/apps.uninstall": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `none` */\n token?: string, \n/** Issued when you created your application. */\n client_id?: string, \n/** Issued when you created your application. */\n client_secret?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_id": {
        "rendered": "\n/** Issued when you created your application. */\n client_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_secret": {
        "rendered": "\n/** Issued when you created your application. */\n client_secret?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/auth.revoke": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** Setting this parameter to `1` triggers a _testing mode_ where the specified token will not actually be revoked. */\n test?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.test": {
        "rendered": "\n/** Setting this parameter to `1` triggers a _testing mode_ where the specified token will not actually be revoked. */\n test?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/auth.test": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/bots.info": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users:read` */\n token: string, \n/** Bot user to get info on */\n bot?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.bot": {
        "rendered": "\n/** Bot user to get info on */\n bot?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/calls.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/calls.end": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/calls.info": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** `id` of the Call returned by the [`calls.add`](/methods/calls.add) method. */\n id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.id": {
        "rendered": "\n/** `id` of the Call returned by the [`calls.add`](/methods/calls.add) method. */\n id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/calls.participants.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/calls.participants.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/calls.update": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.delete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.deleteScheduledMessage": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/chat.getPermalink": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `none` */\n token: string, \n/** The ID of the conversation or channel containing the message */\n channel: string, \n/** A message's `ts` value, uniquely identifying it within a channel */\n message_ts: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `none` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** The ID of the conversation or channel containing the message */\n channel: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.message_ts": {
        "rendered": "\n/** A message's `ts` value, uniquely identifying it within a channel */\n message_ts: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.meMessage": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.postEphemeral": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.postMessage": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.scheduleMessage": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/chat.scheduledMessages.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** The channel of the scheduled messages */\n channel?: string, \n/** A UNIX timestamp of the latest value in the time range */\n latest?: number, \n/** A UNIX timestamp of the oldest value in the time range */\n oldest?: number, \n/** Maximum number of original entries to return. */\n limit?: number, \n/** For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** The channel of the scheduled messages */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.latest": {
        "rendered": "\n/** A UNIX timestamp of the latest value in the time range */\n latest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.oldest": {
        "rendered": "\n/** A UNIX timestamp of the oldest value in the time range */\n oldest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** Maximum number of original entries to return. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.unfurl": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/chat.update": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.archive": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.close": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.create": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/conversations.history": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:history` */\n token?: string, \n/** Conversation ID to fetch history for. */\n channel?: string, \n/** End of time range of messages to include in results. */\n latest?: number, \n/** Start of time range of messages to include in results. */\n oldest?: number, \n/** Include messages with latest or oldest timestamp in results only when either timestamp is specified. */\n inclusive?: boolean, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:history` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Conversation ID to fetch history for. */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.latest": {
        "rendered": "\n/** End of time range of messages to include in results. */\n latest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.oldest": {
        "rendered": "\n/** Start of time range of messages to include in results. */\n oldest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.inclusive": {
        "rendered": "\n/** Include messages with latest or oldest timestamp in results only when either timestamp is specified. */\n inclusive?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/conversations.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:read` */\n token?: string, \n/** Conversation ID to learn more about */\n channel?: string, \n/** Set this to `true` to receive the locale for this conversation. Defaults to `false` */\n include_locale?: boolean, \n/** Set to `true` to include the member count for the specified conversation. Defaults to `false` */\n include_num_members?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Conversation ID to learn more about */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_locale": {
        "rendered": "\n/** Set this to `true` to receive the locale for this conversation. Defaults to `false` */\n include_locale?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_num_members": {
        "rendered": "\n/** Set to `true` to include the member count for the specified conversation. Defaults to `false` */\n include_num_members?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.invite": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.join": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.kick": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.leave": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/conversations.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:read` */\n token?: string, \n/** Set to `true` to exclude archived channels from the list */\n exclude_archived?: boolean, \n/** Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im` */\n types?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.exclude_archived": {
        "rendered": "\n/** Set to `true` to exclude archived channels from the list */\n exclude_archived?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.types": {
        "rendered": "\n/** Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im` */\n types?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.mark": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/conversations.members": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:read` */\n token?: string, \n/** ID of the conversation to retrieve members for */\n channel?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** ID of the conversation to retrieve members for */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.open": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.rename": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/conversations.replies": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:history` */\n token?: string, \n/** Conversation ID to fetch thread from. */\n channel?: string, \n/** Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message. */\n ts?: number, \n/** End of time range of messages to include in results. */\n latest?: number, \n/** Start of time range of messages to include in results. */\n oldest?: number, \n/** Include messages with latest or oldest timestamp in results only when either timestamp is specified. */\n inclusive?: boolean, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:history` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Conversation ID to fetch thread from. */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ts": {
        "rendered": "\n/** Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message. */\n ts?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.latest": {
        "rendered": "\n/** End of time range of messages to include in results. */\n latest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.oldest": {
        "rendered": "\n/** Start of time range of messages to include in results. */\n oldest?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.inclusive": {
        "rendered": "\n/** Include messages with latest or oldest timestamp in results only when either timestamp is specified. */\n inclusive?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.setPurpose": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.setTopic": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/conversations.unarchive": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/dialog.open": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** The dialog definition. This must be a JSON-encoded string. */\n dialog: string, \n/** Exchange a trigger to post to the user. */\n trigger_id: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.dialog": {
        "rendered": "\n/** The dialog definition. This must be a JSON-encoded string. */\n dialog: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trigger_id": {
        "rendered": "\n/** Exchange a trigger to post to the user. */\n trigger_id: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/dnd.endDnd": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/dnd.endSnooze": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/dnd.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `dnd:read` */\n token?: string, \n/** User to fetch status for (defaults to current user) */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `dnd:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** User to fetch status for (defaults to current user) */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/dnd.setSnooze": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/dnd.teamInfo": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `dnd:read` */\n token?: string, \n/** Comma-separated list of users to fetch Do Not Disturb status for */\n users?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `dnd:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.users": {
        "rendered": "\n/** Comma-separated list of users to fetch Do Not Disturb status for */\n users?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/emoji.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `emoji:read` */\n token: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `emoji:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.comments.delete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.delete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/files.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `files:read` */\n token?: string, \n/** Specify a file by providing its ID. */\n file?: string,  count?: string,  page?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number, \n/** Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `files:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.file": {
        "rendered": "\n/** Specify a file by providing its ID. */\n file?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/files.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `files:read` */\n token?: string, \n/** Filter files created by a single user. */\n user?: string, \n/** Filter files appearing in a specific channel, indicated by its ID. */\n channel?: string, \n/** Filter files created after this timestamp (inclusive). */\n ts_from?: number, \n/** Filter files created before this timestamp (inclusive). */\n ts_to?: number, \n/** Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list. */\n types?: string,  count?: string,  page?: string, \n/** Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit. */\n show_files_hidden_by_limit?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `files:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** Filter files created by a single user. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Filter files appearing in a specific channel, indicated by its ID. */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ts_from": {
        "rendered": "\n/** Filter files created after this timestamp (inclusive). */\n ts_from?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ts_to": {
        "rendered": "\n/** Filter files created before this timestamp (inclusive). */\n ts_to?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.types": {
        "rendered": "\n/** Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list. */\n types?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.show_files_hidden_by_limit": {
        "rendered": "\n/** Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit. */\n show_files_hidden_by_limit?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.remote.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/files.remote.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `remote_files:read` */\n token?: string, \n/** Specify a file by providing its ID. */\n file?: string, \n/** Creator defined GUID for the file. */\n external_id?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `remote_files:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.file": {
        "rendered": "\n/** Specify a file by providing its ID. */\n file?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.external_id": {
        "rendered": "\n/** Creator defined GUID for the file. */\n external_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/files.remote.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `remote_files:read` */\n token?: string, \n/** Filter files appearing in a specific channel, indicated by its ID. */\n channel?: string, \n/** Filter files created after this timestamp (inclusive). */\n ts_from?: number, \n/** Filter files created before this timestamp (inclusive). */\n ts_to?: number, \n/** The maximum number of items to return. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `remote_files:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Filter files appearing in a specific channel, indicated by its ID. */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ts_from": {
        "rendered": "\n/** Filter files created after this timestamp (inclusive). */\n ts_from?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.ts_to": {
        "rendered": "\n/** Filter files created before this timestamp (inclusive). */\n ts_to?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.remote.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/files.remote.share": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `remote_files:share` */\n token?: string, \n/** Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required. */\n file?: string, \n/** The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required. */\n external_id?: string, \n/** Comma-separated list of channel IDs where the file will be shared. */\n channels?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `remote_files:share` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.file": {
        "rendered": "\n/** Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required. */\n file?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.external_id": {
        "rendered": "\n/** The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required. */\n external_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channels": {
        "rendered": "\n/** Comma-separated list of channel IDs where the file will be shared. */\n channels?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.remote.update": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.revokePublicURL": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.sharedPublicURL": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/files.upload": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/migration.exchange": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `tokens.basic` */\n token: string, \n/** A comma-separated list of user ids, up to 400 per request */\n users: string, \n/** Specify team_id starts with `T` in case of Org Token */\n team_id?: string, \n/** Specify `true` to convert `W` global user IDs to workspace-specific `U` IDs. Defaults to `false`. */\n to_old?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `tokens.basic` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.users": {
        "rendered": "\n/** A comma-separated list of user ids, up to 400 per request */\n users: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team_id": {
        "rendered": "\n/** Specify team_id starts with `T` in case of Org Token */\n team_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.to_old": {
        "rendered": "\n/** Specify `true` to convert `W` global user IDs to workspace-specific `U` IDs. Defaults to `false`. */\n to_old?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/oauth.access": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Issued when you created your application. */\n client_id?: string, \n/** Issued when you created your application. */\n client_secret?: string, \n/** The `code` param returned via the OAuth callback. */\n code?: string, \n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string, \n/** Request the user to add your app only to a single channel. Only valid with a [legacy workspace app](https://api.slack.com/legacy-workspace-apps). */\n single_channel?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_id": {
        "rendered": "\n/** Issued when you created your application. */\n client_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_secret": {
        "rendered": "\n/** Issued when you created your application. */\n client_secret?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.code": {
        "rendered": "\n/** The `code` param returned via the OAuth callback. */\n code?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.redirect_uri": {
        "rendered": "\n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.single_channel": {
        "rendered": "\n/** Request the user to add your app only to a single channel. Only valid with a [legacy workspace app](https://api.slack.com/legacy-workspace-apps). */\n single_channel?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/oauth.token": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Issued when you created your application. */\n client_id?: string, \n/** Issued when you created your application. */\n client_secret?: string, \n/** The `code` param returned via the OAuth callback. */\n code?: string, \n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string, \n/** Request the user to add your app only to a single channel. */\n single_channel?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_id": {
        "rendered": "\n/** Issued when you created your application. */\n client_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_secret": {
        "rendered": "\n/** Issued when you created your application. */\n client_secret?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.code": {
        "rendered": "\n/** The `code` param returned via the OAuth callback. */\n code?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.redirect_uri": {
        "rendered": "\n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.single_channel": {
        "rendered": "\n/** Request the user to add your app only to a single channel. */\n single_channel?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/oauth.v2.access": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Issued when you created your application. */\n client_id?: string, \n/** Issued when you created your application. */\n client_secret?: string, \n/** The `code` param returned via the OAuth callback. */\n code: string, \n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_id": {
        "rendered": "\n/** Issued when you created your application. */\n client_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.client_secret": {
        "rendered": "\n/** Issued when you created your application. */\n client_secret?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.code": {
        "rendered": "\n/** The `code` param returned via the OAuth callback. */\n code: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.redirect_uri": {
        "rendered": "\n/** This must match the originally submitted URI (if one was sent). */\n redirect_uri?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/pins.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/pins.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `pins:read` */\n token: string, \n/** Channel to get pinned items for. */\n channel: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `pins:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Channel to get pinned items for. */\n channel: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/pins.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/reactions.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/reactions.get": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `reactions:read` */\n token: string, \n/** Channel where the message to get reactions for was posted. */\n channel?: string, \n/** File to get reactions for. */\n file?: string, \n/** File comment to get reactions for. */\n file_comment?: string, \n/** If true always return the complete reaction list. */\n full?: boolean, \n/** Timestamp of the message to get reactions for. */\n timestamp?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `reactions:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.channel": {
        "rendered": "\n/** Channel where the message to get reactions for was posted. */\n channel?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.file": {
        "rendered": "\n/** File to get reactions for. */\n file?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.file_comment": {
        "rendered": "\n/** File comment to get reactions for. */\n file_comment?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.full": {
        "rendered": "\n/** If true always return the complete reaction list. */\n full?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.timestamp": {
        "rendered": "\n/** Timestamp of the message to get reactions for. */\n timestamp?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/reactions.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `reactions:read` */\n token: string, \n/** Show reactions made by this user. Defaults to the authed user. */\n user?: string, \n/** If true always return the complete reaction list. */\n full?: boolean,  count?: number,  page?: number, \n/** Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more details. */\n cursor?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `reactions:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** Show reactions made by this user. Defaults to the authed user. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.full": {
        "rendered": "\n/** If true always return the complete reaction list. */\n full?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more details. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/reactions.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/reminders.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/reminders.complete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/reminders.delete": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/reminders.info": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `reminders:read` */\n token?: string, \n/** The ID of the reminder */\n reminder?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `reminders:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.reminder": {
        "rendered": "\n/** The ID of the reminder */\n reminder?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/reminders.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `reminders:read` */\n token?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `reminders:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/rtm.connect": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `rtm:stream` */\n token: string, \n/** Batch presence deliveries via subscription. Enabling changes the shape of `presence_change` events. See [batch presence](/docs/presence-and-status#batching). */\n batch_presence_aware?: boolean, \n/** Only deliver presence events when requested by subscription. See [presence subscriptions](/docs/presence-and-status#subscriptions). */\n presence_sub?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `rtm:stream` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.batch_presence_aware": {
        "rendered": "\n/** Batch presence deliveries via subscription. Enabling changes the shape of `presence_change` events. See [batch presence](/docs/presence-and-status#batching). */\n batch_presence_aware?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.presence_sub": {
        "rendered": "\n/** Only deliver presence events when requested by subscription. See [presence subscriptions](/docs/presence-and-status#subscriptions). */\n presence_sub?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/search.messages": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `search:read` */\n token: string, \n/** Pass the number of results you want per \"page\". Maximum of `100`. */\n count?: number, \n/** Pass a value of `true` to enable query highlight markers (see below). */\n highlight?: boolean,  page?: number, \n/** Search query. */\n query: string, \n/** Return matches sorted by either `score` or `timestamp`. */\n sort?: string, \n/** Change sort direction to ascending (`asc`) or descending (`desc`). */\n sort_dir?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `search:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": "\n/** Pass the number of results you want per \"page\". Maximum of `100`. */\n count?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.highlight": {
        "rendered": "\n/** Pass a value of `true` to enable query highlight markers (see below). */\n highlight?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.query": {
        "rendered": "\n/** Search query. */\n query: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort": {
        "rendered": "\n/** Return matches sorted by either `score` or `timestamp`. */\n sort?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.sort_dir": {
        "rendered": "\n/** Change sort direction to ascending (`asc`) or descending (`desc`). */\n sort_dir?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/stars.add": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/stars.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `stars:read` */\n token?: string,  count?: string,  page?: string, \n/** Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more details. */\n cursor?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `stars:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more details. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/stars.remove": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/team.accessLogs": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin` */\n token: string, \n/** End of time range of logs to include in results (inclusive). */\n before?: string,  count?: string,  page?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.before": {
        "rendered": "\n/** End of time range of logs to include in results (inclusive). */\n before?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/team.billableInfo": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin` */\n token: string, \n/** A user to retrieve the billable information for. Defaults to all users. */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** A user to retrieve the billable information for. Defaults to all users. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/team.info": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `team:read` */\n token: string, \n/** Team to get info on, if omitted, will return information about the current team. Will only return team that the authenticated token is allowed to see through external shared channels */\n team?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `team:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.team": {
        "rendered": "\n/** Team to get info on, if omitted, will return information about the current team. Will only return team that the authenticated token is allowed to see through external shared channels */\n team?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/team.integrationLogs": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `admin` */\n token: string, \n/** Filter logs to this Slack app. Defaults to all logs. */\n app_id?: string, \n/** Filter logs with this change type. Defaults to all logs. */\n change_type?: string,  count?: string,  page?: string, \n/** Filter logs to this service. Defaults to all logs. */\n service_id?: string, \n/** Filter logs generated by this user’s actions. Defaults to all logs. */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `admin` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.app_id": {
        "rendered": "\n/** Filter logs to this Slack app. Defaults to all logs. */\n app_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.change_type": {
        "rendered": "\n/** Filter logs with this change type. Defaults to all logs. */\n change_type?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.count": {
        "rendered": " count?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.page": {
        "rendered": " page?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.service_id": {
        "rendered": "\n/** Filter logs to this service. Defaults to all logs. */\n service_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** Filter logs generated by this user’s actions. Defaults to all logs. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/team.profile.get": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users.profile:read` */\n token: string, \n/** Filter by visibility. */\n visibility?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users.profile:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.visibility": {
        "rendered": "\n/** Filter by visibility. */\n visibility?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/usergroups.create": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/usergroups.disable": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/usergroups.enable": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/usergroups.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Include the list of users for each User Group. */\n include_users?: boolean, \n/** Authentication token. Requires scope: `usergroups:read` */\n token: string, \n/** Include the number of users in each User Group. */\n include_count?: boolean, \n/** Include disabled User Groups. */\n include_disabled?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_users": {
        "rendered": "\n/** Include the list of users for each User Group. */\n include_users?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `usergroups:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_count": {
        "rendered": "\n/** Include the number of users in each User Group. */\n include_count?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_disabled": {
        "rendered": "\n/** Include disabled User Groups. */\n include_disabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/usergroups.update": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/usergroups.users.list": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `usergroups:read` */\n token: string, \n/** Allow results that involve disabled User Groups. */\n include_disabled?: boolean, \n/** The encoded ID of the User Group to update. */\n usergroup: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `usergroups:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_disabled": {
        "rendered": "\n/** Allow results that involve disabled User Groups. */\n include_disabled?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.usergroup": {
        "rendered": "\n/** The encoded ID of the User Group to update. */\n usergroup: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/usergroups.users.update": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.conversations": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `conversations:read` */\n token?: string, \n/** Browse conversations by a specific user ID's membership. Non-public channels are restricted to those where the calling user shares membership. */\n user?: string, \n/** Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im` */\n types?: string, \n/** Set to `true` to exclude archived channels from the list */\n exclude_archived?: boolean, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `conversations:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** Browse conversations by a specific user ID's membership. Non-public channels are restricted to those where the calling user shares membership. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.types": {
        "rendered": "\n/** Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im` */\n types?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.exclude_archived": {
        "rendered": "\n/** Set to `true` to exclude archived channels from the list */\n exclude_archived?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/users.deletePhoto": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.getPresence": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users:read` */\n token: string, \n/** User to get presence info on. Defaults to the authed user. */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** User to get presence info on. Defaults to the authed user. */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.identity": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `identity.basic` */\n token?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `identity.basic` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.info": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users:read` */\n token: string, \n/** Set this to `true` to receive the locale for this user. Defaults to `false` */\n include_locale?: boolean, \n/** User to get info on */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_locale": {
        "rendered": "\n/** Set this to `true` to receive the locale for this user. Defaults to `false` */\n include_locale?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** User to get info on */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.list": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** Authentication token. Requires scope: `users:read` */\n token?: string, \n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. Providing no `limit` value will result in Slack attempting to deliver you the entire result set. If the collection is too large you may experience `limit_required` or HTTP 500 errors. */\n limit?: number, \n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string, \n/** Set this to `true` to receive the locale for users. Defaults to `false` */\n include_locale?: boolean, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users:read` */\n token?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.limit": {
        "rendered": "\n/** The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. Providing no `limit` value will result in Slack attempting to deliver you the entire result set. If the collection is too large you may experience `limit_required` or HTTP 500 errors. */\n limit?: number,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.cursor": {
        "rendered": "\n/** Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail. */\n cursor?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_locale": {
        "rendered": "\n/** Set this to `true` to receive the locale for users. Defaults to `false` */\n include_locale?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.lookupByEmail": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users:read.email` */\n token: string, \n/** An email address belonging to a user in the workspace */\n email: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users:read.email` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.email": {
        "rendered": "\n/** An email address belonging to a user in the workspace */\n email: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/users.profile.get": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Authentication token. Requires scope: `users.profile:read` */\n token: string, \n/** Include labels for each ID in custom profile fields */\n include_labels?: boolean, \n/** User to retrieve profile info for */\n user?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.token": {
        "rendered": "\n/** Authentication token. Requires scope: `users.profile:read` */\n token: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.include_labels": {
        "rendered": "\n/** Include labels for each ID in custom profile fields */\n include_labels?: boolean,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user": {
        "rendered": "\n/** User to retrieve profile info for */\n user?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/users.profile.set": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/users.setActive": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/users.setPhoto": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "post__/users.setPresence": {
    "query": {},
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/views.open": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Exchange a trigger to post to the user. */\n trigger_id: string, \n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trigger_id": {
        "rendered": "\n/** Exchange a trigger to post to the user. */\n trigger_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.view": {
        "rendered": "\n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/views.publish": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** `id` of the user you want publish a view to. */\n user_id: string, \n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string, \n/** A string that represents view state to protect against possible race conditions. */\n hash?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.user_id": {
        "rendered": "\n/** `id` of the user you want publish a view to. */\n user_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.view": {
        "rendered": "\n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.hash": {
        "rendered": "\n/** A string that represents view state to protect against possible race conditions. */\n hash?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/views.push": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Exchange a trigger to post to the user. */\n trigger_id: string, \n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.trigger_id": {
        "rendered": "\n/** Exchange a trigger to post to the user. */\n trigger_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.view": {
        "rendered": "\n/** A [view payload](/reference/surfaces/views). This must be a JSON-encoded string. */\n view: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/views.update": {
    "query": {
      ".query": {
        "rendered": " query: { \n/** A unique identifier of the view to be updated. Either `view_id` or `external_id` is required. */\n view_id?: string, \n/** A unique identifier of the view set by the developer. Must be unique for all views on a team. Max length of 255 characters. Either `view_id` or `external_id` is required. */\n external_id?: string, \n/** A [view object](/reference/surfaces/views). This must be a JSON-encoded string. */\n view?: string, \n/** A string that represents view state to protect against possible race conditions. */\n hash?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.view_id": {
        "rendered": "\n/** A unique identifier of the view to be updated. Either `view_id` or `external_id` is required. */\n view_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.external_id": {
        "rendered": "\n/** A unique identifier of the view set by the developer. Must be unique for all views on a team. Max length of 255 characters. Either `view_id` or `external_id` is required. */\n external_id?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.view": {
        "rendered": "\n/** A [view object](/reference/surfaces/views). This must be a JSON-encoded string. */\n view?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.hash": {
        "rendered": "\n/** A string that represents view state to protect against possible race conditions. */\n hash?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/workflows.stepCompleted": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Context identifier that maps to the correct workflow step execution. */\n workflow_step_execute_id: string, \n/** Key-value object of outputs from your step. Keys of this object reflect the configured `key` properties of your [`outputs`](/reference/workflows/workflow_step#output) array from your `workflow_step` object. */\n outputs?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.workflow_step_execute_id": {
        "rendered": "\n/** Context identifier that maps to the correct workflow step execution. */\n workflow_step_execute_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.outputs": {
        "rendered": "\n/** Key-value object of outputs from your step. Keys of this object reflect the configured `key` properties of your [`outputs`](/reference/workflows/workflow_step#output) array from your `workflow_step` object. */\n outputs?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/workflows.stepFailed": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** Context identifier that maps to the correct workflow step execution. */\n workflow_step_execute_id: string, \n/** A JSON-based object with a `message` property that should contain a human readable error message. */\n error: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.workflow_step_execute_id": {
        "rendered": "\n/** Context identifier that maps to the correct workflow step execution. */\n workflow_step_execute_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.error": {
        "rendered": "\n/** A JSON-based object with a `message` property that should contain a human readable error message. */\n error: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  },
  "get__/workflows.updateStep": {
    "query": {
      ".query": {
        "rendered": " query?: { \n/** A context identifier provided with `view_submission` payloads used to call back to `workflows.updateStep`. */\n workflow_step_edit_id: string, \n/** A JSON key-value map of inputs required from a user during configuration. This is the data your app expects to receive when the workflow step starts. **Please note**: the embedded variable format is set and replaced by the workflow system. You cannot create custom variables that will be replaced at runtime. [Read more about variables in workflow steps here](/workflows/steps#variables). */\n inputs?: string, \n/** An JSON array of output objects used during step execution. This is the data your app agrees to provide when your workflow step was executed. */\n outputs?: string, \n/** An optional field that can be used to override the step name that is shown in the Workflow Builder. */\n step_name?: string, \n/** An optional field that can be used to override app image that is shown in the Workflow Builder. */\n step_image_url?: string, },",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.workflow_step_edit_id": {
        "rendered": "\n/** A context identifier provided with `view_submission` payloads used to call back to `workflows.updateStep`. */\n workflow_step_edit_id: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.inputs": {
        "rendered": "\n/** A JSON key-value map of inputs required from a user during configuration. This is the data your app expects to receive when the workflow step starts. **Please note**: the embedded variable format is set and replaced by the workflow system. You cannot create custom variables that will be replaced at runtime. [Read more about variables in workflow steps here](/workflows/steps#variables). */\n inputs?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.outputs": {
        "rendered": "\n/** An JSON array of output objects used during step execution. This is the data your app agrees to provide when your workflow step was executed. */\n outputs?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.step_name": {
        "rendered": "\n/** An optional field that can be used to override the step name that is shown in the Workflow Builder. */\n step_name?: string,",
        "requiresRelaxedTypeAnnotation": false
      },
      ".query.step_image_url": {
        "rendered": "\n/** An optional field that can be used to override app image that is shown in the Workflow Builder. */\n step_image_url?: string,",
        "requiresRelaxedTypeAnnotation": false
      }
    },
    "body": {},
    "path": {},
    "response": {}
  }
}
