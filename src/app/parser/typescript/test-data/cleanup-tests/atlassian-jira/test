import {
  NotificationSchemeEventDetails,
  GroupName,
  FieldConfigurationToIssueTypeMapping,
  UserDetails,
  AttachmentArchiveEntry,
  AttachmentArchiveItemReadable,
  User,
  AssociatedItemBean,
  ChangedValueBean,
  AuditRecordBean,
  AutoCompleteSuggestion,
  AvailableDashboardGadget,
  Avatar,
  CustomFieldOptionCreate,
  CustomFieldOptionUpdate,
  IssueFilterForBulkPropertySet,
  ErrorCollection,
  BulkProjectPermissionGrants,
  BulkProjectPermissions,
  EntityProperty,
  ChangedWorklog,
  HistoryMetadata,
  ChangeDetails,
  Visibility,
  JqlQueryClause,
  TimeTrackingConfiguration,
  ConnectCustomFieldValue,
  ConnectModule,
  RuleConfiguration,
  WorkflowTransition,
  ProjectFeature,
  RegisteredWebhook,
  WorkflowSchemeAssociations,
  Scope,
  JQLQueryWithUnknownUsers,
  UiModificationContextDetails,
  CreateWorkflowCondition,
  CreateWorkflowStatusDetails,
  CreateWorkflowTransitionDetails,
  CreateWorkflowTransitionRulesDetails,
  CreateWorkflowTransitionScreenDetails,
  CreateWorkflowTransitionRule,
  NestedResponse,
  BulkOperationErrorResult,
  CreatedIssue,
  BaseCustomContextVariable,
  BaseCustomContextVariableTypeMapping,
  IssueContextVariable,
  JsonContextVariable,
  UserContextVariable,
  ContextualConfiguration,
  BaseCustomFieldContextDefaultValue,
  BaseCustomFieldContextDefaultValueTypeMapping,
  CustomFieldContextDefaultValueDate,
  CustomFieldContextDefaultValueDateTime,
  CustomFieldContextDefaultValueFloat,
  CustomFieldContextDefaultValueForgeDateTimeField,
  CustomFieldContextDefaultValueForgeGroupField,
  CustomFieldContextDefaultValueForgeMultiGroupField,
  CustomFieldContextDefaultValueForgeNumberField,
  CustomFieldContextDefaultValueForgeObjectField,
  CustomFieldContextDefaultValueForgeStringField,
  CustomFieldContextDefaultValueForgeMultiStringField,
  CustomFieldContextDefaultValueForgeUserField,
  CustomFieldContextDefaultValueForgeMultiUserField,
  CustomFieldContextDefaultValueMultipleGroupPicker,
  CustomFieldContextDefaultValueSingleGroupPicker,
  CustomFieldContextDefaultValueLabels,
  CustomFieldContextDefaultValueMultiUserPicker,
  CustomFieldContextDefaultValueCascadingOption,
  CustomFieldContextDefaultValueMultipleOption,
  CustomFieldContextDefaultValueSingleOption,
  CustomFieldContextDefaultValueProject,
  CustomFieldContextDefaultValueReadOnly,
  CustomFieldContextSingleUserPickerDefaults,
  CustomFieldContextDefaultValueTextArea,
  CustomFieldContextDefaultValueTextField,
  CustomFieldContextDefaultValueURL,
  CustomFieldContextDefaultValueMultipleVersionPicker,
  CustomFieldContextDefaultValueSingleVersionPicker,
  UserFilter,
  CustomFieldContextDefaultValue,
  CustomFieldContextOption,
  CustomFieldValueUpdate,
  SharePermission,
  UserBean,
  DashboardGadgetPosition,
  DashboardGadget,
  CustomFieldReplacement,
  FieldDetails,
  FailedWebhook,
  FieldLastUsed,
  JsonTypeBean,
  JqlQueryField,
  JqlQueryClauseTimePredicate,
  FieldConfigurationItem,
  FieldConfigurationScheme,
  JqlQueryClauseOperand,
  IssueTypeDetails,
  Priority,
  StatusDetails,
  TimeTrackingDetails,
  UserList,
  FilterSubscriptionsList,
  FilterSubscription,
  GroupLabel,
  FoundGroup,
  UserPickerUser,
  FoundGroups,
  FoundUsers,
  PagedListUserDetailsApplicationUser,
  SimplifiedHierarchyLevel,
  HistoryMetadataParticipant,
  PageOfChangelogs,
  IssueUpdateMetadata,
  IncludedFields,
  Operations,
  IssueTransition,
  ProjectIssueCreateMetadata,
  JsonNode,
  IssueFieldOptionConfiguration,
  IssueFieldOptionScopeBean,
  GlobalScopeBean,
  ProjectScopeBean,
  LinkedIssue,
  IssueLinkType,
  IssueMatchesForJQL,
  IssuePickerSuggestionsIssueType,
  SuggestedIssue,
  PermissionHolder,
  FieldMetadata,
  IssueTypeScheme,
  IssueTypeScreenSchemeMapping,
  IssueTypeScreenScheme,
  FieldUpdateOperation,
  IssuesJqlMetaDataBean,
  IssueUpdateDetails,
  FieldReferenceData,
  FunctionReferenceData,
  JexpJqlIssues,
  JiraExpressionComplexity,
  JiraExpressionValidationError,
  CustomContextVariable,
  IdOrKeyBean,
  JexpIssues,
  JiraExpressionEvalContextBean,
  JiraExpressionsComplexityBean,
  IssuesMetaBean,
  JiraExpressionEvaluationMetaDataBean,
  JiraExpressionAnalysis,
  JiraExpressionsComplexityValueBean,
  StatusScope,
  ProjectIssueTypes,
  JqlFunctionPrecomputationUpdateBean,
  JqlQueryToSanitize,
  JqlQueryOrderByClause,
  CompoundClause,
  FieldValueClause,
  FieldWasClause,
  FieldChangedClause,
  ListOperand,
  ValueOperand,
  FunctionOperand,
  KeywordOperand,
  JqlQueryFieldEntityProperty,
  JqlQueryOrderByClauseElement,
  LicensedApplication,
  LinkGroup,
  SimpleLink,
  Comment,
  Fields,
  JqlQueryUnitaryOperand,
  IssueEntityPropertiesForMultiUpdate,
  MultipleCustomFieldValuesUpdate,
  WarningCollection,
  NotificationRecipientsRestrictions,
  NotificationRecipients,
  NotificationEvent,
  RestrictedPermission,
  NotificationSchemeEvent,
  EventNotification,
  NotificationSchemeEventTypeId,
  NotificationSchemeNotificationDetails,
  Changelog,
  ComponentWithIssueCount,
  Context,
  ContextForProjectAndIssueType,
  CustomFieldContext,
  CustomFieldContextProjectMapping,
  Dashboard,
  Field,
  FieldConfigurationDetails,
  FieldConfigurationIssueTypeItem,
  FieldConfigurationSchemeProjects,
  FilterDetails,
  GroupDetails,
  IssueFieldOption,
  IssueSecurityLevelMember,
  IssueTypeSchemeMapping,
  IssueTypeSchemeProjects,
  IssueTypeScreenSchemeItem,
  IssueTypeScreenSchemesProjects,
  IssueTypeToContextMapping,
  JqlFunctionPrecomputationBean,
  NotificationScheme,
  NotificationSchemeAndProjectMappingJsonBean,
  Project,
  ProjectDetails,
  ResolutionJsonBean,
  Screen,
  ScreenScheme,
  ScreenWithTab,
  UiModificationDetails,
  UserKey,
  Version,
  Webhook,
  Workflow,
  WorkflowScheme,
  WorkflowTransitionRules,
  JiraStatus,
  Worklog,
  ParsedJqlQuery,
  JqlQuery,
  PermissionGrant,
  PermissionScheme,
  UserPermission,
  ProjectIdentifierBean,
  AvatarUrlsBean,
  ProjectComponent,
  ProjectInsight,
  Hierarchy,
  ProjectLandingPageInfo,
  ProjectPermissions,
  ProjectCategory,
  UpdatedProjectCategory,
  IssueTypeIssueCreateMetadata,
  SecurityLevel,
  ProjectIssueTypesHierarchyLevel,
  ProjectIssueTypeMapping,
  ProjectId,
  IssueTypeInfo,
  RoleActor,
  PropertyKey,
  StatusMapping,
  Application,
  RemoteObject,
  Icon,
  Status,
  SimpleErrorCollection,
  ProjectRoleGroup,
  ProjectRoleUser,
  SanitizedJqlQuery,
  PageBeanIssueTypeScreenScheme,
  ScreenTypes,
  ScreenableTab,
  IssueBean,
  SecurityScheme,
  HealthCheckResult,
  ListWrapperCallbackApplicationRole,
  ApplicationRole,
  ListWrapperCallbackGroupName,
  StatusCreate,
  StatusCategory,
  StatusUpdate,
  RemoveOptionFromIssuesResult,
  WorkflowRules,
  TransitionScreenDetails,
  UpdateScreenTypes,
  SimpleListWrapperApplicationRole,
  SimpleListWrapperGroupName,
  UserBeanAvatarUrls,
  VersionIssuesStatus,
  VersionUsageInCustomField,
  WebhookDetails,
  PublishedWorkflowId,
  WorkflowOperations,
  WorkflowSchemeIdName,
  WorkflowStatus,
  Transition,
  WorkflowCondition,
  BaseWorkflowCondition,
  BaseWorkflowConditionNodeTypeMapping,
  WorkflowCompoundCondition,
  WorkflowSimpleCondition,
  WorkflowTransitionRule,
  ConnectWorkflowTransitionRule,
  WorkflowId,
  WorkflowTransitionRulesUpdateErrorDetails,
  WorkflowTransitionRulesDetails,
  AnnouncementBannerConfiguration,
  ActorInputBean,
  ActorsMap,
  AddFieldBean,
  AddGroupBean,
  AddNotificationsDetails,
  AnnouncementBannerConfigurationUpdate,
  ApplicationProperty,
  AssociateFieldConfigurationsWithIssueTypesRequest,
  Attachment,
  AttachmentArchive,
  AttachmentArchiveImpl,
  AttachmentArchiveMetadataReadable,
  AttachmentMetadata,
  AttachmentSettings,
  AuditRecords,
  AutoCompleteSuggestions,
  AvailableDashboardGadgetsResponse,
  Avatars,
  BulkCustomFieldOptionCreateRequest,
  BulkCustomFieldOptionUpdateRequest,
  BulkIssueIsWatching,
  BulkIssuePropertyUpdateRequest,
  BulkPermissionGrants,
  BulkPermissionsRequestBean,
  ChangeFilterOwner,
  ChangedWorklogs,
  ColumnItem,
  ComponentIssuesCount,
  Configuration,
  ConnectCustomFieldValues,
  ConnectModules,
  ContainerForProjectFeatures,
  ContainerForRegisteredWebhooks,
  ContainerForWebhookIDs,
  ContainerOfWorkflowSchemeAssociations,
  ConvertedJQLQueries,
  CreateCustomFieldContext,
  CreateNotificationSchemeDetails,
  CreatePriorityDetails,
  CreateProjectDetails,
  CreateResolutionDetails,
  CreateUiModificationDetails,
  CreateUpdateRoleRequestBean,
  CreateWorkflowDetails,
  CreatedIssues,
  CustomFieldConfigurations,
  CustomFieldContextDefaultValueUpdate,
  CustomFieldContextUpdateDetails,
  CustomFieldCreatedContextOptionsList,
  CustomFieldDefinitionJsonBean,
  CustomFieldOption,
  CustomFieldUpdatedContextOptionsList,
  CustomFieldValueUpdateDetails,
  DashboardDetails,
  DashboardGadgetResponse,
  DashboardGadgetSettings,
  DashboardGadgetUpdateRequest,
  DefaultShareScope,
  DefaultWorkflow,
  DeleteAndReplaceVersionBean,
  DeprecatedWorkflow,
  EntityPropertyDetails,
  ErrorMessage,
  FailedWebhooks,
  FieldConfiguration,
  FieldConfigurationItemsDetails,
  FieldConfigurationSchemeProjectAssociation,
  Filter,
  FoundUsersAndGroups,
  IconBean,
  IdBean,
  IssueChangelogIds,
  IssueCommentListRequestBean,
  IssueCreateMetadata,
  IssueEntityProperties,
  IssueEvent,
  IssueFieldOptionCreateBean,
  IssueFilterForBulkPropertyDelete,
  IssueLink,
  IssueLinkTypes,
  IssueList,
  IssueMatches,
  IssuePickerSuggestions,
  IssueTypeCreateBean,
  IssueTypeIds,
  IssueTypeIdsToRemove,
  IssueTypeSchemeDetails,
  IssueTypeSchemeID,
  IssueTypeSchemeProjectAssociation,
  IssueTypeSchemeUpdateDetails,
  IssueTypeScreenSchemeDetails,
  IssueTypeScreenSchemeId,
  IssueTypeScreenSchemeMappingDetails,
  IssueTypeScreenSchemeProjectAssociation,
  IssueTypeScreenSchemeUpdateDetails,
  IssueTypeUpdateBean,
  IssueTypeWithStatus,
  IssueTypeWorkflowMapping,
  IssueTypesWorkflowMapping,
  IssuesAndJQLQueries,
  IssuesUpdateBean,
  JQLPersonalDataMigrationRequest,
  JQLReferenceData,
  JiraExpressionEvalRequestBean,
  JiraExpressionForAnalysis,
  JiraExpressionResult,
  JiraExpressionsAnalysis,
  JqlFunctionPrecomputationUpdateRequestBean,
  JqlQueriesToParse,
  JqlQueriesToSanitize,
  License,
  LicenseMetric,
  LinkIssueRequestJsonBean,
  Locale,
  MoveFieldBean,
  MultiIssueEntityProperties,
  MultipleCustomFieldValuesUpdateDetails,
  NewUserDetails,
  Notification,
  NotificationSchemeId,
  OperationMessage,
  OrderOfCustomFieldOptions,
  OrderOfIssueTypes,
  PageBeanChangelog,
  PageBeanComment,
  PageBeanComponentWithIssueCount,
  PageBeanContext,
  PageBeanContextForProjectAndIssueType,
  PageBeanContextualConfiguration,
  PageBeanCustomFieldContext,
  PageBeanCustomFieldContextDefaultValue,
  PageBeanCustomFieldContextOption,
  PageBeanCustomFieldContextProjectMapping,
  PageBeanDashboard,
  PageBeanField,
  PageBeanFieldConfigurationDetails,
  PageBeanFieldConfigurationIssueTypeItem,
  PageBeanFieldConfigurationItem,
  PageBeanFieldConfigurationScheme,
  PageBeanFieldConfigurationSchemeProjects,
  PageBeanFilterDetails,
  PageBeanGroupDetails,
  PageBeanIssueFieldOption,
  PageBeanIssueSecurityLevelMember,
  PageBeanIssueTypeScheme,
  PageBeanIssueTypeSchemeMapping,
  PageBeanIssueTypeSchemeProjects,
  PageBeanIssueTypeScreenSchemeItem,
  PageBeanIssueTypeScreenSchemesProjects,
  PageBeanIssueTypeToContextMapping,
  PageBeanJqlFunctionPrecomputationBean,
  PageBeanNotificationScheme,
  PageBeanNotificationSchemeAndProjectMappingJsonBean,
  PageBeanPriority,
  PageBeanProject,
  PageBeanProjectDetails,
  PageBeanResolutionJsonBean,
  PageBeanScreen,
  PageBeanScreenScheme,
  PageBeanScreenWithTab,
  PageBeanString,
  PageBeanUiModificationDetails,
  PageBeanUser,
  PageBeanUserDetails,
  PageBeanUserKey,
  PageBeanVersion,
  PageBeanWebhook,
  PageBeanWorkflow,
  PageBeanWorkflowScheme,
  PageBeanWorkflowTransitionRules,
  PageOfComments,
  PageOfDashboards,
  PageOfStatuses,
  PageOfWorklogs,
  PaginatedResponseComment,
  ParsedJqlQueries,
  PermissionGrants,
  PermissionSchemes,
  Permissions,
  PermissionsKeysBean,
  PermittedProjects,
  PriorityId,
  ProjectAvatars,
  ProjectEmailAddress,
  ProjectFeatureState,
  ProjectIdentifiers,
  ProjectIds,
  ProjectIssueSecurityLevels,
  ProjectIssueTypeHierarchy,
  ProjectIssueTypeMappings,
  ProjectRoleActorsUpdateBean,
  ProjectRoleDetails,
  ProjectType,
  PropertyKeys,
  PublishDraftWorkflowScheme,
  RemoteIssueLink,
  RemoteIssueLinkIdentifies,
  RemoteIssueLinkRequest,
  ReorderIssuePriorities,
  ReorderIssueResolutionsRequest,
  Resolution,
  ResolutionId,
  RichText,
  SanitizedJqlQueries,
  ScreenDetails,
  ScreenSchemeDetails,
  ScreenSchemeId,
  ScreenableField,
  SearchAutoCompleteFilter,
  SearchRequestBean,
  SearchResults,
  SecuritySchemes,
  ServerInformation,
  ServiceManagementNavigationInfo,
  SetDefaultPriorityRequest,
  SetDefaultResolutionRequest,
  SharePermissionInputBean,
  SimpleApplicationPropertyBean,
  SoftwareNavigationInfo,
  StatusCreateRequest,
  StatusUpdateRequest,
  StringList,
  SystemAvatars,
  TaskProgressBeanObject,
  TaskProgressBeanRemoveOptionFromIssuesResult,
  TimeTrackingProvider,
  Transitions,
  UiModificationIdentifiers,
  UnrestrictedUserEmail,
  UpdateCustomFieldDetails,
  UpdateDefaultScreenScheme,
  UpdateFieldConfigurationSchemeDetails,
  UpdateNotificationSchemeDetails,
  UpdatePriorityDetails,
  UpdateProjectDetails,
  UpdateResolutionDetails,
  UpdateScreenDetails,
  UpdateScreenSchemeDetails,
  UpdateUiModificationDetails,
  UpdateUserToGroupBean,
  UserMigrationBean,
  VersionIssueCounts,
  VersionMoveBean,
  VersionUnresolvedIssuesCount,
  Votes,
  Watchers,
  WebhookRegistrationDetails,
  WebhooksExpirationDate,
  WorkManagementNavigationInfo,
  WorkflowIDs,
  WorkflowRulesSearch,
  WorkflowRulesSearchDetails,
  WorkflowSchemeProjectAssociation,
  WorkflowTransitionProperty,
  WorkflowTransitionRulesUpdate,
  WorkflowTransitionRulesUpdateErrors,
  WorkflowsWithTransitionRulesDetails,
  WorklogIdsRequestBean,
  Api,
} from "./api";
import * as hasuraSdk from "@hasura/ndc-lambda-sdk";

const api = new Api({
  baseUrl: "",
});

/**
 * Get announcement banner configuration
 * @request GET :/rest/api/3/announcementBanner
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetBanner(
  headers?: hasuraSdk.JSONValue,
): Promise<AnnouncementBannerConfiguration> {
  const result = await api.rest.getBanner({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update announcement banner configuration
 * @request PUT :/rest/api/3/announcementBanner
 * @allowrelaxedtypes
 */
export async function putRestSetBanner(
  /** Request body */
  data: AnnouncementBannerConfigurationUpdate,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setBanner({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update custom fields
 * @request POST :/rest/api/3/app/field/value
 * @allowrelaxedtypes
 */
export async function postRestUpdateMultipleCustomFieldValues(
  query: {
    /**
     * Whether to generate a changelog for this update.
     */
    generateChangelog?: boolean;
  },
  /** Request body */
  data: MultipleCustomFieldValuesUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateMultipleCustomFieldValues({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get custom field configurations
 * @request GET :/rest/api/3/app/field/{fieldIdOrKey}/context/configuration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetCustomFieldConfiguration(
  query: {
    /**
     * The list of configuration IDs. To include multiple configurations, separate IDs with an ampersand: `id=10000&id=10001`. Can't be provided with `fieldContextId`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     */
    id?: number[];
    /**
     * The list of field context IDs. To include multiple field contexts, separate IDs with an ampersand: `fieldContextId=10000&fieldContextId=10001`. Can't be provided with `id`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     */
    fieldContextId?: number[];
    /**
     * The ID of the issue to filter results by. If the issue doesn't exist, an empty list is returned. Can't be provided with `projectKeyOrId`, or `issueTypeId`.
     */
    issueId?: number;
    /**
     * The ID or key of the project to filter results by. Must be provided with `issueTypeId`. Can't be provided with `issueId`.
     */
    projectKeyOrId?: string;
    /**
     * The ID of the issue type to filter results by. Must be provided with `projectKeyOrId`. Can't be provided with `issueId`.
     */
    issueTypeId?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID or key of the custom field, for example `customfield_10000`.
   */
  fieldIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanContextualConfiguration> {
  const result = await api.rest.getCustomFieldConfiguration({
    query: query,
    fieldIdOrKey: fieldIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update custom field configurations
 * @request PUT :/rest/api/3/app/field/{fieldIdOrKey}/context/configuration
 * @allowrelaxedtypes
 */
export async function putRestUpdateCustomFieldConfiguration(
  /**
   * The ID or key of the custom field, for example `customfield_10000`.
   */
  fieldIdOrKey: string,
  /** Request body */
  data: CustomFieldConfigurations,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateCustomFieldConfiguration({
    fieldIdOrKey: fieldIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update custom field value
 * @request PUT :/rest/api/3/app/field/{fieldIdOrKey}/value
 * @allowrelaxedtypes
 */
export async function putRestUpdateCustomFieldValue(
  query: {
    /**
     * Whether to generate a changelog for this update.
     */
    generateChangelog?: boolean;
  },
  /**
   * The ID or key of the custom field. For example, `customfield_10010`.
   */
  fieldIdOrKey: string,
  /** Request body */
  data: CustomFieldValueUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateCustomFieldValue({
    query: query,
    fieldIdOrKey: fieldIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get application property
 * @request GET :/rest/api/3/application-properties
 * @readonly
 */
export async function getRestGetApplicationProperty(
  query: {
    /**
     * The key of the application property.
     */
    key?: string;
    /**
     * The permission level of all items being returned in the list.
     */
    permissionLevel?: string;
    /**
     * When a `key` isn't provided, this filters the list of results by the application property `key` using a regular expression. For example, using `jira.lf.*` will return all application properties with keys that start with *jira.lf.*.
     */
    keyFilter?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ApplicationProperty[]> {
  const result = await api.rest.getApplicationProperty({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get advanced settings
 * @request GET :/rest/api/3/application-properties/advanced-settings
 * @readonly
 */
export async function getRestGetAdvancedSettings(
  headers?: hasuraSdk.JSONValue,
): Promise<ApplicationProperty[]> {
  const result = await api.rest.getAdvancedSettings({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set application property
 * @request PUT :/rest/api/3/application-properties/{id}
 */
export async function putRestSetApplicationProperty(
  /**
   * The key of the application property to update.
   */
  id: string,
  /** Request body */
  data: SimpleApplicationPropertyBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ApplicationProperty> {
  const result = await api.rest.setApplicationProperty({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all application roles
 * @request GET :/rest/api/3/applicationrole
 * @readonly
 */
export async function getRestGetAllApplicationRoles(
  headers?: hasuraSdk.JSONValue,
): Promise<ApplicationRole[]> {
  const result = await api.rest.getAllApplicationRoles({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get application role
 * @request GET :/rest/api/3/applicationrole/{key}
 * @readonly
 */
export async function getRestGetApplicationRole(
  /**
   * The key of the application role. Use the [Get all application roles](#api-rest-api-3-applicationrole-get) operation to get the key for each application role.
   */
  key: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ApplicationRole> {
  const result = await api.rest.getApplicationRole({
    key: key,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get attachment content
 * @request GET :/rest/api/3/attachment/content/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAttachmentContent(
  query: {
    /**
     * Whether a redirect is provided for the attachment download. Clients that do not automatically follow redirects can set this to `false` to avoid making multiple requests to download the attachment.
     */
    redirect?: boolean;
  },
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModule> {
  const result = await api.rest.getAttachmentContent({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get Jira attachment settings
 * @request GET :/rest/api/3/attachment/meta
 * @readonly
 */
export async function getRestGetAttachmentMeta(
  headers?: hasuraSdk.JSONValue,
): Promise<AttachmentSettings> {
  const result = await api.rest.getAttachmentMeta({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get attachment thumbnail
 * @request GET :/rest/api/3/attachment/thumbnail/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAttachmentThumbnail(
  query: {
    /**
     * Whether a redirect is provided for the attachment download. Clients that do not automatically follow redirects can set this to `false` to avoid making multiple requests to download the attachment.
     */
    redirect?: boolean;
    /**
     * Whether a default thumbnail is returned when the requested thumbnail is not found.
     */
    fallbackToDefault?: boolean;
    /**
     * The maximum width to scale the thumbnail to.
     */
    width?: number;
    /**
     * The maximum height to scale the thumbnail to.
     */
    height?: number;
  },
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModule> {
  const result = await api.rest.getAttachmentThumbnail({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete attachment
 * @request DELETE :/rest/api/3/attachment/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveAttachment(
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeAttachment({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get attachment metadata
 * @request GET :/rest/api/3/attachment/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAttachment(
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<AttachmentMetadata> {
  const result = await api.rest.getAttachment({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all metadata for an expanded attachment
 * @request GET :/rest/api/3/attachment/{id}/expand/human
 * @readonly
 */
export async function getRestExpandAttachmentForHumans(
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<AttachmentArchiveMetadataReadable> {
  const result = await api.rest.expandAttachmentForHumans({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get contents metadata for an expanded attachment
 * @request GET :/rest/api/3/attachment/{id}/expand/raw
 * @readonly
 */
export async function getRestExpandAttachmentForMachines(
  /**
   * The ID of the attachment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<AttachmentArchiveImpl> {
  const result = await api.rest.expandAttachmentForMachines({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get audit records
 * @request GET :/rest/api/3/auditing/record
 * @readonly
 */
export async function getRestGetAuditRecords(
  query: {
    /**
     * The number of records to skip before returning the first result.
     */
    offset?: number;
    /**
     * The maximum number of results to return.
     */
    limit?: number;
    /**
     * The strings to match with audit field content, space separated.
     */
    filter?: string;
    /**
     * The date and time on or after which returned audit records must have been created. If `to` is provided `from` must be before `to` or no audit records are returned.
     */
    from?: string;
    /**
     * The date and time on or before which returned audit results must have been created. If `from` is provided `to` must be after `from` or no audit records are returned.
     */
    to?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AuditRecords> {
  const result = await api.rest.getAuditRecords({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get system avatars by type
 * @request GET :/rest/api/3/avatar/{type}/system
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllSystemAvatars(
  /**
   * The avatar type.
   */
  type: "issuetype" | "project" | "user",
  headers?: hasuraSdk.JSONValue,
): Promise<SystemAvatars> {
  const result = await api.rest.getAllSystemAvatars({
    type: type,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get comments by IDs
 * @request POST :/rest/api/3/comment/list
 * @allowrelaxedtypes
 */
export async function postRestGetCommentsByIds(
  query: {
    /**
* Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `renderedBody` Returns the comment body rendered in HTML.
 *  `properties` Returns the comment's properties.
*/
    expand?: string;
  },
  /** Request body */
  data: IssueCommentListRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanComment> {
  const result = await api.rest.getCommentsByIds({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get comment property keys
 * @request GET :/rest/api/3/comment/{commentId}/properties
 * @readonly
 */
export async function getRestGetCommentPropertyKeys(
  /**
   * The ID of the comment.
   */
  commentId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getCommentPropertyKeys({
    commentId: commentId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete comment property
 * @request DELETE :/rest/api/3/comment/{commentId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteCommentProperty(
  /**
   * The ID of the comment.
   */
  commentId: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteCommentProperty({
    commentId: commentId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get comment property
 * @request GET :/rest/api/3/comment/{commentId}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetCommentProperty(
  /**
   * The ID of the comment.
   */
  commentId: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getCommentProperty({
    commentId: commentId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set comment property
 * @request PUT :/rest/api/3/comment/{commentId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetCommentProperty(
  /**
   * The ID of the comment.
   */
  commentId: string,
  /**
   * The key of the property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setCommentProperty({
    commentId: commentId,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Create component
 * @request POST :/rest/api/3/component
 * @allowrelaxedtypes
 */
export async function postRestCreateComponent(
  /** Request body */
  data: ProjectComponent,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectComponent> {
  const result = await api.rest.createComponent({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete component
 * @request DELETE :/rest/api/3/component/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteComponent(
  query: {
    /**
     * The ID of the component to replace the deleted component. If this value is null no replacement is made.
     */
    moveIssuesTo?: string;
  },
  /**
   * The ID of the component.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteComponent({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get component
 * @request GET :/rest/api/3/component/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetComponent(
  /**
   * The ID of the component.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectComponent> {
  const result = await api.rest.getComponent({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update component
 * @request PUT :/rest/api/3/component/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateComponent(
  /**
   * The ID of the component.
   */
  id: string,
  /** Request body */
  data: ProjectComponent,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectComponent> {
  const result = await api.rest.updateComponent({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get component issues count
 * @request GET :/rest/api/3/component/{id}/relatedIssueCounts
 * @readonly
 */
export async function getRestGetComponentRelatedIssues(
  /**
   * The ID of the component.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ComponentIssuesCount> {
  const result = await api.rest.getComponentRelatedIssues({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get global settings
 * @request GET :/rest/api/3/configuration
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetConfiguration(
  headers?: hasuraSdk.JSONValue,
): Promise<Configuration> {
  const result = await api.rest.getConfiguration({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get selected time tracking provider
 * @request GET :/rest/api/3/configuration/timetracking
 * @readonly
 */
export async function getRestGetSelectedTimeTrackingImplementation(
  headers?: hasuraSdk.JSONValue,
): Promise<TimeTrackingProvider> {
  const result = await api.rest.getSelectedTimeTrackingImplementation({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Select time tracking provider
 * @request PUT :/rest/api/3/configuration/timetracking
 * @allowrelaxedtypes
 */
export async function putRestSelectTimeTrackingImplementation(
  /** Request body */
  data: TimeTrackingProvider,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.selectTimeTrackingImplementation({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all time tracking providers
 * @request GET :/rest/api/3/configuration/timetracking/list
 * @readonly
 */
export async function getRestGetAvailableTimeTrackingImplementations(
  headers?: hasuraSdk.JSONValue,
): Promise<TimeTrackingProvider[]> {
  const result = await api.rest.getAvailableTimeTrackingImplementations({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get time tracking settings
 * @request GET :/rest/api/3/configuration/timetracking/options
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetSharedTimeTrackingConfiguration(
  headers?: hasuraSdk.JSONValue,
): Promise<TimeTrackingConfiguration> {
  const result = await api.rest.getSharedTimeTrackingConfiguration({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set time tracking settings
 * @request PUT :/rest/api/3/configuration/timetracking/options
 * @allowrelaxedtypes
 */
export async function putRestSetSharedTimeTrackingConfiguration(
  /** Request body */
  data: TimeTrackingConfiguration,
  headers?: hasuraSdk.JSONValue,
): Promise<TimeTrackingConfiguration> {
  const result = await api.rest.setSharedTimeTrackingConfiguration({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get custom field option
 * @request GET :/rest/api/3/customFieldOption/{id}
 * @readonly
 */
export async function getRestGetCustomFieldOption(
  /**
   * The ID of the custom field option.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<CustomFieldOption> {
  const result = await api.rest.getCustomFieldOption({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all dashboards
 * @request GET :/rest/api/3/dashboard
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllDashboards(
  query: {
    /**
* The filter applied to the list of dashboards. Valid values are:

 *  `favourite` Returns dashboards the user has marked as favorite.
 *  `my` Returns dashboards owned by the user.
*/
    filter?: "my" | "favourite";
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageOfDashboards> {
  const result = await api.rest.getAllDashboards({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create dashboard
 * @request POST :/rest/api/3/dashboard
 * @allowrelaxedtypes
 */
export async function postRestCreateDashboard(
  /** Request body */
  data: DashboardDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Dashboard> {
  const result = await api.rest.createDashboard({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get available gadgets
 * @request GET :/rest/api/3/dashboard/gadgets
 * @readonly
 */
export async function getRestGetAllAvailableDashboardGadgets(
  headers?: hasuraSdk.JSONValue,
): Promise<AvailableDashboardGadgetsResponse> {
  const result = await api.rest.getAllAvailableDashboardGadgets({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Search for dashboards
 * @request GET :/rest/api/3/dashboard/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetDashboardsPaginated(
  query: {
    /**
     * String used to perform a case-insensitive partial match with `name`.
     */
    dashboardName?: string;
    /**
     * User account ID used to return dashboards with the matching `owner.accountId`. This parameter cannot be used with the `owner` parameter.
     */
    accountId?: string;
    /**
     * This parameter is deprecated because of privacy changes. Use `accountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. User name used to return dashboards with the matching `owner.name`. This parameter cannot be used with the `accountId` parameter.
     */
    owner?: string;
    /**
     * As a group's name can change, use of `groupId` is recommended. Group name used to return dashboards that are shared with a group that matches `sharePermissions.group.name`. This parameter cannot be used with the `groupId` parameter.
     */
    groupname?: string;
    /**
     * Group ID used to return dashboards that are shared with a group that matches `sharePermissions.group.groupId`. This parameter cannot be used with the `groupname` parameter.
     */
    groupId?: string;
    /**
     * Project ID used to returns dashboards that are shared with a project that matches `sharePermissions.project.id`.
     */
    projectId?: number;
    /**
* [Order](#ordering) the results by a field:

 *  `description` Sorts by dashboard description. Note that this sort works independently of whether the expand to display the description field is in use.
 *  `favourite_count` Sorts by dashboard popularity.
 *  `id` Sorts by dashboard ID.
 *  `is_favourite` Sorts by whether the dashboard is marked as a favorite.
 *  `name` Sorts by dashboard name.
 *  `owner` Sorts by dashboard owner name.
*/
    orderBy?:
      | "description"
      | "-description"
      | "+description"
      | "favorite_count"
      | "-favorite_count"
      | "+favorite_count"
      | "id"
      | "-id"
      | "+id"
      | "is_favorite"
      | "-is_favorite"
      | "+is_favorite"
      | "name"
      | "-name"
      | "+name"
      | "owner"
      | "-owner"
      | "+owner";
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The status to filter by. It may be active, archived or deleted.
     */
    status?: "active" | "archived" | "deleted";
    /**
* Use [expand](#expansion) to include additional information about dashboard in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `description` Returns the description of the dashboard.
 *  `owner` Returns the owner of the dashboard.
 *  `viewUrl` Returns the URL that is used to view the dashboard.
 *  `favourite` Returns `isFavourite`, an indicator of whether the user has set the dashboard as a favorite.
 *  `favouritedCount` Returns `popularity`, a count of how many users have set this dashboard as a favorite.
 *  `sharePermissions` Returns details of the share permissions defined for the dashboard.
 *  `editPermissions` Returns details of the edit permissions defined for the dashboard.
 *  `isWritable` Returns whether the current user has permission to edit the dashboard.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanDashboard> {
  const result = await api.rest.getDashboardsPaginated({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get gadgets
 * @request GET :/rest/api/3/dashboard/{dashboardId}/gadget
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllGadgets(
  query: {
    /**
     * The list of gadgets module keys. To include multiple module keys, separate module keys with ampersand: `moduleKey=key:one&moduleKey=key:two`.
     */
    moduleKey?: string[];
    /**
     * The list of gadgets URIs. To include multiple URIs, separate URIs with ampersand: `uri=/rest/example/uri/1&uri=/rest/example/uri/2`.
     */
    uri?: string[];
    /**
     * The list of gadgets IDs. To include multiple IDs, separate IDs with ampersand: `gadgetId=10000&gadgetId=10001`.
     */
    gadgetId?: number[];
  },
  /**
   * The ID of the dashboard.
   */
  dashboardId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<DashboardGadgetResponse> {
  const result = await api.rest.getAllGadgets({
    query: query,
    dashboardId: dashboardId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add gadget to dashboard
 * @request POST :/rest/api/3/dashboard/{dashboardId}/gadget
 * @allowrelaxedtypes
 */
export async function postRestAddGadget(
  /**
   * The ID of the dashboard.
   */
  dashboardId: number,
  /** Request body */
  data: DashboardGadgetSettings,
  headers?: hasuraSdk.JSONValue,
): Promise<DashboardGadget> {
  const result = await api.rest.addGadget({
    dashboardId: dashboardId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Remove gadget from dashboard
 * @request DELETE :/rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveGadget(
  /**
   * The ID of the dashboard.
   */
  dashboardId: number,
  /**
   * The ID of the gadget.
   */
  gadgetId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeGadget({
    dashboardId: dashboardId,
    gadgetId: gadgetId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update gadget on dashboard
 * @request PUT :/rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateGadget(
  /**
   * The ID of the dashboard.
   */
  dashboardId: number,
  /**
   * The ID of the gadget.
   */
  gadgetId: number,
  /** Request body */
  data: DashboardGadgetUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateGadget({
    dashboardId: dashboardId,
    gadgetId: gadgetId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get dashboard item property keys
 * @request GET :/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties
 * @readonly
 */
export async function getRestGetDashboardItemPropertyKeys(
  /**
   * The ID of the dashboard.
   */
  dashboardId: string,
  /**
   * The ID of the dashboard item.
   */
  itemId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getDashboardItemPropertyKeys({
    dashboardId: dashboardId,
    itemId: itemId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete dashboard item property
 * @request DELETE :/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteDashboardItemProperty(
  /**
   * The ID of the dashboard.
   */
  dashboardId: string,
  /**
   * The ID of the dashboard item.
   */
  itemId: string,
  /**
   * The key of the dashboard item property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteDashboardItemProperty({
    dashboardId: dashboardId,
    itemId: itemId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get dashboard item property
 * @request GET :/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetDashboardItemProperty(
  /**
   * The ID of the dashboard.
   */
  dashboardId: string,
  /**
   * The ID of the dashboard item.
   */
  itemId: string,
  /**
   * The key of the dashboard item property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getDashboardItemProperty({
    dashboardId: dashboardId,
    itemId: itemId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set dashboard item property
 * @request PUT :/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetDashboardItemProperty(
  /**
   * The ID of the dashboard.
   */
  dashboardId: string,
  /**
   * The ID of the dashboard item.
   */
  itemId: string,
  /**
   * The key of the dashboard item property. The maximum length is 255 characters. For dashboard items with a spec URI and no complete module key, if the provided propertyKey is equal to "config", the request body's JSON must be an object with all keys and values as strings.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setDashboardItemProperty({
    dashboardId: dashboardId,
    itemId: itemId,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete dashboard
 * @request DELETE :/rest/api/3/dashboard/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteDashboard(
  /**
   * The ID of the dashboard.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteDashboard({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get dashboard
 * @request GET :/rest/api/3/dashboard/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetDashboard(
  /**
   * The ID of the dashboard.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Dashboard> {
  const result = await api.rest.getDashboard({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update dashboard
 * @request PUT :/rest/api/3/dashboard/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateDashboard(
  /**
   * The ID of the dashboard to update.
   */
  id: string,
  /** Request body */
  data: DashboardDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Dashboard> {
  const result = await api.rest.updateDashboard({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Copy dashboard
 * @request POST :/rest/api/3/dashboard/{id}/copy
 * @allowrelaxedtypes
 */
export async function postRestCopyDashboard(
  id: string,
  /** Request body */
  data: DashboardDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Dashboard> {
  const result = await api.rest.copyDashboard({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get events
 * @request GET :/rest/api/3/events
 * @readonly
 */
export async function getRestGetEvents(
  headers?: hasuraSdk.JSONValue,
): Promise<IssueEvent[]> {
  const result = await api.rest.getEvents({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Analyse Jira expression
 * @request POST :/rest/api/3/expression/analyse
 * @allowrelaxedtypes
 */
export async function postRestAnalyseExpression(
  query: {
    /**
* The check to perform:

 *  `syntax` Each expression's syntax is checked to ensure the expression can be parsed. Also, syntactic limits are validated. For example, the expression's length.
 *  `type` EXPERIMENTAL. Each expression is type checked and the final type of the expression inferred. Any type errors that would result in the expression failure at runtime are reported. For example, accessing properties that don't exist or passing the wrong number of arguments to functions. Also performs the syntax check.
 *  `complexity` EXPERIMENTAL. Determines the formulae for how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) each expression may execute.
*/
    check?: "syntax" | "type" | "complexity";
  },
  /** Request body */
  data: JiraExpressionForAnalysis,
  headers?: hasuraSdk.JSONValue,
): Promise<JiraExpressionsAnalysis> {
  const result = await api.rest.analyseExpression({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Evaluate Jira expression
 * @request POST :/rest/api/3/expression/eval
 * @allowrelaxedtypes
 */
export async function postRestEvaluateJiraExpression(
  query: {
    /**
     * Use [expand](#expansion) to include additional information in the response. This parameter accepts `meta.complexity` that returns information about the expression complexity. For example, the number of expensive operations used by the expression and how close the expression is to reaching the [complexity limit](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#restrictions). Useful when designing and debugging your expressions.
     */
    expand?: string;
  },
  /** Request body */
  data: JiraExpressionEvalRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<JiraExpressionResult> {
  const result = await api.rest.evaluateJiraExpression({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get fields
 * @request GET :/rest/api/3/field
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFields(
  headers?: hasuraSdk.JSONValue,
): Promise<FieldDetails[]> {
  const result = await api.rest.getFields({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create custom field
 * @request POST :/rest/api/3/field
 * @allowrelaxedtypes
 */
export async function postRestCreateCustomField(
  /** Request body */
  data: CustomFieldDefinitionJsonBean,
  headers?: hasuraSdk.JSONValue,
): Promise<FieldDetails> {
  const result = await api.rest.createCustomField({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get fields paginated
 * @request GET :/rest/api/3/field/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFieldsPaginated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The type of fields to search.
     */
    type?: ("custom" | "system")[];
    /**
     * The IDs of the custom fields to return or, where `query` is specified, filter.
     */
    id?: string[];
    /**
     * String used to perform a case-insensitive partial match with field names or descriptions.
     */
    query?: string;
    /**
* [Order](#ordering) the results by a field:

 *  `contextsCount` sorts by the number of contexts related to a field
 *  `lastUsed` sorts by the date when the value of the field last changed
 *  `name` sorts by the field name
 *  `screensCount` sorts by the number of screens related to a field
*/
    orderBy?:
      | "contextsCount"
      | "-contextsCount"
      | "+contextsCount"
      | "lastUsed"
      | "-lastUsed"
      | "+lastUsed"
      | "name"
      | "-name"
      | "+name"
      | "screensCount"
      | "-screensCount"
      | "+screensCount"
      | "projectsCount"
      | "-projectsCount"
      | "+projectsCount";
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `key` returns the key for each field
 *  `lastUsed` returns the date when the value of the field last changed
 *  `screensCount` returns the number of screens related to a field
 *  `contextsCount` returns the number of contexts related to a field
 *  `isLocked` returns information about whether the field is [locked](https://confluence.atlassian.com/x/ZSN7Og)
 *  `searcherKey` returns the searcher key for each custom field
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanField> {
  const result = await api.rest.getFieldsPaginated({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get fields in trash paginated
 * @request GET :/rest/api/3/field/search/trashed
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetTrashedFieldsPaginated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    id?: string[];
    /**
     * String used to perform a case-insensitive partial match with field names or descriptions.
     */
    query?: string;
    expand?:
      | "name"
      | "-name"
      | "+name"
      | "trashDate"
      | "-trashDate"
      | "+trashDate"
      | "plannedDeletionDate"
      | "-plannedDeletionDate"
      | "+plannedDeletionDate"
      | "projectsCount"
      | "-projectsCount"
      | "+projectsCount";
    /**
* [Order](#ordering) the results by a field:

 *  `name` sorts by the field name
 *  `trashDate` sorts by the date the field was moved to the trash
 *  `plannedDeletionDate` sorts by the planned deletion date
*/
    orderBy?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanField> {
  const result = await api.rest.getTrashedFieldsPaginated({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update custom field
 * @request PUT :/rest/api/3/field/{fieldId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateCustomField(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /** Request body */
  data: UpdateCustomFieldDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateCustomField({
    fieldId: fieldId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get custom field contexts
 * @request GET :/rest/api/3/field/{fieldId}/context
 * @readonly
 */
export async function getRestGetContextsForField(
  query: {
    /**
     * Whether to return contexts that apply to all issue types.
     */
    isAnyIssueType?: boolean;
    /**
     * Whether to return contexts that apply to all projects.
     */
    isGlobalContext?: boolean;
    /**
     * The list of context IDs. To include multiple contexts, separate IDs with ampersand: `contextId=10000&contextId=10001`.
     */
    contextId?: number[];
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanCustomFieldContext> {
  const result = await api.rest.getContextsForField({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create custom field context
 * @request POST :/rest/api/3/field/{fieldId}/context
 */
export async function postRestCreateCustomFieldContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /** Request body */
  data: CreateCustomFieldContext,
  headers?: hasuraSdk.JSONValue,
): Promise<CreateCustomFieldContext> {
  const result = await api.rest.createCustomFieldContext({
    fieldId: fieldId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get custom field contexts default values
 * @request GET :/rest/api/3/field/{fieldId}/context/defaultValue
 * @readonly
 */
export async function getRestGetDefaultValues(
  query: {
    /**
     * The IDs of the contexts.
     */
    contextId?: number[];
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field, for example `customfield\_10000`.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanCustomFieldContextDefaultValue> {
  const result = await api.rest.getDefaultValues({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set custom field contexts default values
 * @request PUT :/rest/api/3/field/{fieldId}/context/defaultValue
 * @allowrelaxedtypes
 */
export async function putRestSetDefaultValues(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /** Request body */
  data: CustomFieldContextDefaultValueUpdate,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setDefaultValues({
    fieldId: fieldId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue types for custom field context
 * @request GET :/rest/api/3/field/{fieldId}/context/issuetypemapping
 * @readonly
 */
export async function getRestGetIssueTypeMappingsForContexts(
  query: {
    /**
     * The ID of the context. To include multiple contexts, provide an ampersand-separated list. For example, `contextId=10001&contextId=10002`.
     */
    contextId?: number[];
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeToContextMapping> {
  const result = await api.rest.getIssueTypeMappingsForContexts({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get custom field contexts for projects and issue types
 * @request POST :/rest/api/3/field/{fieldId}/context/mapping
 */
export async function postRestGetCustomFieldContextsForProjectsAndIssueTypes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /** Request body */
  data: ProjectIssueTypeMappings,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanContextForProjectAndIssueType> {
  const result = await api.rest.getCustomFieldContextsForProjectsAndIssueTypes({
    query: query,
    fieldId: fieldId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project mappings for custom field context
 * @request GET :/rest/api/3/field/{fieldId}/context/projectmapping
 * @readonly
 */
export async function getRestGetProjectContextMapping(
  query: {
    /**
     * The list of context IDs. To include multiple context, separate IDs with ampersand: `contextId=10000&contextId=10001`.
     */
    contextId?: number[];
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field, for example `customfield\_10000`.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanCustomFieldContextProjectMapping> {
  const result = await api.rest.getProjectContextMapping({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete custom field context
 * @request DELETE :/rest/api/3/field/{fieldId}/context/{contextId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteCustomFieldContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteCustomFieldContext({
    fieldId: fieldId,
    contextId: contextId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update custom field context
 * @request PUT :/rest/api/3/field/{fieldId}/context/{contextId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateCustomFieldContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: CustomFieldContextUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateCustomFieldContext({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Add issue types to context
 * @request PUT :/rest/api/3/field/{fieldId}/context/{contextId}/issuetype
 * @allowrelaxedtypes
 */
export async function putRestAddIssueTypesToContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: IssueTypeIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addIssueTypesToContext({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove issue types from context
 * @request POST :/rest/api/3/field/{fieldId}/context/{contextId}/issuetype/remove
 * @allowrelaxedtypes
 */
export async function postRestRemoveIssueTypesFromContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: IssueTypeIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeIssueTypesFromContext({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get custom field options (context)
 * @request GET :/rest/api/3/field/{fieldId}/context/{contextId}/option
 * @readonly
 */
export async function getRestGetOptionsForContext(
  query: {
    /**
     * The ID of the option.
     */
    optionId?: number;
    /**
     * Whether only options are returned.
     */
    onlyOptions?: boolean;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanCustomFieldContextOption> {
  const result = await api.rest.getOptionsForContext({
    query: query,
    fieldId: fieldId,
    contextId: contextId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create custom field options (context)
 * @request POST :/rest/api/3/field/{fieldId}/context/{contextId}/option
 */
export async function postRestCreateCustomFieldOption(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: BulkCustomFieldOptionCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<CustomFieldCreatedContextOptionsList> {
  const result = await api.rest.createCustomFieldOption({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update custom field options (context)
 * @request PUT :/rest/api/3/field/{fieldId}/context/{contextId}/option
 */
export async function putRestUpdateCustomFieldOption(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: BulkCustomFieldOptionUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<CustomFieldUpdatedContextOptionsList> {
  const result = await api.rest.updateCustomFieldOption({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Reorder custom field options (context)
 * @request PUT :/rest/api/3/field/{fieldId}/context/{contextId}/option/move
 * @allowrelaxedtypes
 */
export async function putRestReorderCustomFieldOptions(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: OrderOfCustomFieldOptions,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.reorderCustomFieldOptions({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete custom field options (context)
 * @request DELETE :/rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteCustomFieldOption(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context from which an option should be deleted.
   */
  contextId: number,
  /**
   * The ID of the option to delete.
   */
  optionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteCustomFieldOption({
    fieldId: fieldId,
    contextId: contextId,
    optionId: optionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Assign custom field context to projects
 * @request PUT :/rest/api/3/field/{fieldId}/context/{contextId}/project
 * @allowrelaxedtypes
 */
export async function putRestAssignProjectsToCustomFieldContext(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: ProjectIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignProjectsToCustomFieldContext({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove custom field context from projects
 * @request POST :/rest/api/3/field/{fieldId}/context/{contextId}/project/remove
 * @allowrelaxedtypes
 */
export async function postRestRemoveCustomFieldContextFromProjects(
  /**
   * The ID of the custom field.
   */
  fieldId: string,
  /**
   * The ID of the context.
   */
  contextId: number,
  /** Request body */
  data: ProjectIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeCustomFieldContextFromProjects({
    fieldId: fieldId,
    contextId: contextId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get contexts for a field
 * @request GET :/rest/api/3/field/{fieldId}/contexts
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetContextsForFieldDeprecated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the field to return contexts for.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanContext> {
  const result = await api.rest.getContextsForFieldDeprecated({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get screens for a field
 * @request GET :/rest/api/3/field/{fieldId}/screens
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetScreensForField(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * Use [expand](#expansion) to include additional information about screens in the response. This parameter accepts `tab` which returns details about the screen tabs the field is used in.
     */
    expand?: string;
  },
  /**
   * The ID of the field to return screens for.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanScreenWithTab> {
  const result = await api.rest.getScreensForField({
    query: query,
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all issue field options
 * @request GET :/rest/api/3/field/{fieldKey}/option
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllIssueFieldOptions(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueFieldOption> {
  const result = await api.rest.getAllIssueFieldOptions({
    query: query,
    fieldKey: fieldKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue field option
 * @request POST :/rest/api/3/field/{fieldKey}/option
 * @allowrelaxedtypes
 */
export async function postRestCreateIssueFieldOption(
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  /** Request body */
  data: IssueFieldOptionCreateBean,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueFieldOption> {
  const result = await api.rest.createIssueFieldOption({
    fieldKey: fieldKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get selectable issue field options
 * @request GET :/rest/api/3/field/{fieldKey}/option/suggestions/edit
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetSelectableIssueFieldOptions(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * Filters the results to options that are only available in the specified project.
     */
    projectId?: number;
  },
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueFieldOption> {
  const result = await api.rest.getSelectableIssueFieldOptions({
    query: query,
    fieldKey: fieldKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get visible issue field options
 * @request GET :/rest/api/3/field/{fieldKey}/option/suggestions/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetVisibleIssueFieldOptions(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * Filters the results to options that are only available in the specified project.
     */
    projectId?: number;
  },
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueFieldOption> {
  const result = await api.rest.getVisibleIssueFieldOptions({
    query: query,
    fieldKey: fieldKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue field option
 * @request DELETE :/rest/api/3/field/{fieldKey}/option/{optionId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueFieldOption(
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  /**
   * The ID of the option to be deleted.
   */
  optionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueFieldOption({
    fieldKey: fieldKey,
    optionId: optionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue field option
 * @request GET :/rest/api/3/field/{fieldKey}/option/{optionId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueFieldOption(
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  /**
   * The ID of the option to be returned.
   */
  optionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueFieldOption> {
  const result = await api.rest.getIssueFieldOption({
    fieldKey: fieldKey,
    optionId: optionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update issue field option
 * @request PUT :/rest/api/3/field/{fieldKey}/option/{optionId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateIssueFieldOption(
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  /**
   * The ID of the option to be updated.
   */
  optionId: number,
  /** Request body */
  data: IssueFieldOption,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueFieldOption> {
  const result = await api.rest.updateIssueFieldOption({
    fieldKey: fieldKey,
    optionId: optionId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Replace issue field option
 * @request DELETE :/rest/api/3/field/{fieldKey}/option/{optionId}/issue
 * @allowrelaxedtypes
 */
export async function deleteRestReplaceIssueFieldOption(
  query: {
    /**
     * The ID of the option that will replace the currently selected option.
     */
    replaceWith?: number;
    /**
     * A JQL query that specifies the issues to be updated. For example, *project=10000*.
     */
    jql?: string;
    /**
     * Whether screen security is overridden to enable hidden fields to be edited. Available to Connect and Forge app users with admin permission.
     */
    overrideScreenSecurity?: boolean;
    /**
     * Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideEditableFlag?: boolean;
  },
  /**
* The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

 *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
 *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
*/
  fieldKey: string,
  /**
   * The ID of the option to be deselected.
   */
  optionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.replaceIssueFieldOption({
    query: query,
    fieldKey: fieldKey,
    optionId: optionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete custom field
 * @request DELETE :/rest/api/3/field/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteCustomField(
  /**
   * The ID of a custom field.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteCustomField({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Restore custom field from trash
 * @request POST :/rest/api/3/field/{id}/restore
 * @allowrelaxedtypes
 */
export async function postRestRestoreCustomField(
  /**
   * The ID of a custom field.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.restoreCustomField({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Move custom field to trash
 * @request POST :/rest/api/3/field/{id}/trash
 * @allowrelaxedtypes
 */
export async function postRestTrashCustomField(
  /**
   * The ID of a custom field.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.trashCustomField({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all field configurations
 * @request GET :/rest/api/3/fieldconfiguration
 * @readonly
 */
export async function getRestGetAllFieldConfigurations(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of field configuration IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
    /**
     * If *true* returns default field configurations only.
     */
    isDefault?: boolean;
    /**
     * The query string used to match against field configuration names and descriptions.
     */
    query?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFieldConfigurationDetails> {
  const result = await api.rest.getAllFieldConfigurations({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create field configuration
 * @request POST :/rest/api/3/fieldconfiguration
 */
export async function postRestCreateFieldConfiguration(
  /** Request body */
  data: FieldConfigurationDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<FieldConfiguration> {
  const result = await api.rest.createFieldConfiguration({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete field configuration
 * @request DELETE :/rest/api/3/fieldconfiguration/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteFieldConfiguration(
  /**
   * The ID of the field configuration.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteFieldConfiguration({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update field configuration
 * @request PUT :/rest/api/3/fieldconfiguration/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateFieldConfiguration(
  /**
   * The ID of the field configuration.
   */
  id: number,
  /** Request body */
  data: FieldConfigurationDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateFieldConfiguration({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get field configuration items
 * @request GET :/rest/api/3/fieldconfiguration/{id}/fields
 * @readonly
 */
export async function getRestGetFieldConfigurationItems(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID of the field configuration.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFieldConfigurationItem> {
  const result = await api.rest.getFieldConfigurationItems({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update field configuration items
 * @request PUT :/rest/api/3/fieldconfiguration/{id}/fields
 * @allowrelaxedtypes
 */
export async function putRestUpdateFieldConfigurationItems(
  /**
   * The ID of the field configuration.
   */
  id: number,
  /** Request body */
  data: FieldConfigurationItemsDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateFieldConfigurationItems({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all field configuration schemes
 * @request GET :/rest/api/3/fieldconfigurationscheme
 * @readonly
 */
export async function getRestGetAllFieldConfigurationSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of field configuration scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFieldConfigurationScheme> {
  const result = await api.rest.getAllFieldConfigurationSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create field configuration scheme
 * @request POST :/rest/api/3/fieldconfigurationscheme
 */
export async function postRestCreateFieldConfigurationScheme(
  /** Request body */
  data: UpdateFieldConfigurationSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<FieldConfigurationScheme> {
  const result = await api.rest.createFieldConfigurationScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get field configuration issue type items
 * @request GET :/rest/api/3/fieldconfigurationscheme/mapping
 * @readonly
 */
export async function getRestGetFieldConfigurationSchemeMappings(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of field configuration scheme IDs. To include multiple field configuration schemes separate IDs with ampersand: `fieldConfigurationSchemeId=10000&fieldConfigurationSchemeId=10001`.
     */
    fieldConfigurationSchemeId?: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFieldConfigurationIssueTypeItem> {
  const result = await api.rest.getFieldConfigurationSchemeMappings({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get field configuration schemes for projects
 * @request GET :/rest/api/3/fieldconfigurationscheme/project
 * @readonly
 */
export async function getRestGetFieldConfigurationSchemeProjectMapping(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of project IDs. To include multiple projects, separate IDs with ampersand: `projectId=10000&projectId=10001`.
     */
    projectId: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFieldConfigurationSchemeProjects> {
  const result = await api.rest.getFieldConfigurationSchemeProjectMapping({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Assign field configuration scheme to project
 * @request PUT :/rest/api/3/fieldconfigurationscheme/project
 * @allowrelaxedtypes
 */
export async function putRestAssignFieldConfigurationSchemeToProject(
  /** Request body */
  data: FieldConfigurationSchemeProjectAssociation,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignFieldConfigurationSchemeToProject({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete field configuration scheme
 * @request DELETE :/rest/api/3/fieldconfigurationscheme/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteFieldConfigurationScheme(
  /**
   * The ID of the field configuration scheme.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteFieldConfigurationScheme({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update field configuration scheme
 * @request PUT :/rest/api/3/fieldconfigurationscheme/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateFieldConfigurationScheme(
  /**
   * The ID of the field configuration scheme.
   */
  id: number,
  /** Request body */
  data: UpdateFieldConfigurationSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateFieldConfigurationScheme({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Assign issue types to field configurations
 * @request PUT :/rest/api/3/fieldconfigurationscheme/{id}/mapping
 * @allowrelaxedtypes
 */
export async function putRestSetFieldConfigurationSchemeMapping(
  /**
   * The ID of the field configuration scheme.
   */
  id: number,
  /** Request body */
  data: AssociateFieldConfigurationsWithIssueTypesRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setFieldConfigurationSchemeMapping({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove issue types from field configuration scheme
 * @request POST :/rest/api/3/fieldconfigurationscheme/{id}/mapping/delete
 * @allowrelaxedtypes
 */
export async function postRestRemoveIssueTypesFromGlobalFieldConfigurationScheme(
  /**
   * The ID of the field configuration scheme.
   */
  id: number,
  /** Request body */
  data: IssueTypeIdsToRemove,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.rest.removeIssueTypesFromGlobalFieldConfigurationScheme({
      id: id,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get filters
 * @request GET :/rest/api/3/filter
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFilters(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Filter[]> {
  const result = await api.rest.getFilters({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create filter
 * @request POST :/rest/api/3/filter
 * @allowrelaxedtypes
 */
export async function postRestCreateFilter(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
    /**
     * EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be created. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideSharePermissions?: boolean;
  },
  /** Request body */
  data: Filter,
  headers?: hasuraSdk.JSONValue,
): Promise<Filter> {
  const result = await api.rest.createFilter({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get default share scope
 * @request GET :/rest/api/3/filter/defaultShareScope
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetDefaultShareScope(
  headers?: hasuraSdk.JSONValue,
): Promise<DefaultShareScope> {
  const result = await api.rest.getDefaultShareScope({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set default share scope
 * @request PUT :/rest/api/3/filter/defaultShareScope
 * @allowrelaxedtypes
 */
export async function putRestSetDefaultShareScope(
  /** Request body */
  data: DefaultShareScope,
  headers?: hasuraSdk.JSONValue,
): Promise<DefaultShareScope> {
  const result = await api.rest.setDefaultShareScope({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get favorite filters
 * @request GET :/rest/api/3/filter/favourite
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFavouriteFilters(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Filter[]> {
  const result = await api.rest.getFavouriteFilters({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get my filters
 * @request GET :/rest/api/3/filter/my
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetMyFilters(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
    /**
     * Include the user's favorite filters in the response.
     */
    includeFavourites?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Filter[]> {
  const result = await api.rest.getMyFilters({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Search for filters
 * @request GET :/rest/api/3/filter/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFiltersPaginated(
  query: {
    /**
     * String used to perform a case-insensitive partial match with `name`.
     */
    filterName?: string;
    /**
     * User account ID used to return filters with the matching `owner.accountId`. This parameter cannot be used with `owner`.
     */
    accountId?: string;
    /**
     * This parameter is deprecated because of privacy changes. Use `accountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. User name used to return filters with the matching `owner.name`. This parameter cannot be used with `accountId`.
     */
    owner?: string;
    /**
     * As a group's name can change, use of `groupId` is recommended to identify a group. Group name used to returns filters that are shared with a group that matches `sharePermissions.group.groupname`. This parameter cannot be used with the `groupId` parameter.
     */
    groupname?: string;
    /**
     * Group ID used to returns filters that are shared with a group that matches `sharePermissions.group.groupId`. This parameter cannot be used with the `groupname` parameter.
     */
    groupId?: string;
    /**
     * Project ID used to returns filters that are shared with a project that matches `sharePermissions.project.id`.
     */
    projectId?: number;
    /**
     * The list of filter IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`. Do not exceed 200 filter IDs.
     */
    id?: number[];
    /**
* [Order](#ordering) the results by a field:

 *  `description` Sorts by filter description. Note that this sorting works independently of whether the expand to display the description field is in use.
 *  `favourite_count` Sorts by the count of how many users have this filter as a favorite.
 *  `is_favourite` Sorts by whether the filter is marked as a favorite.
 *  `id` Sorts by filter ID.
 *  `name` Sorts by filter name.
 *  `owner` Sorts by the ID of the filter owner.
 *  `is_shared` Sorts by whether the filter is shared.
*/
    orderBy?:
      | "description"
      | "-description"
      | "+description"
      | "favourite_count"
      | "-favourite_count"
      | "+favourite_count"
      | "id"
      | "-id"
      | "+id"
      | "is_favourite"
      | "-is_favourite"
      | "+is_favourite"
      | "name"
      | "-name"
      | "+name"
      | "owner"
      | "-owner"
      | "+owner"
      | "is_shared"
      | "-is_shared"
      | "+is_shared";
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `description` Returns the description of the filter.
 *  `favourite` Returns an indicator of whether the user has set the filter as a favorite.
 *  `favouritedCount` Returns a count of how many users have set this filter as a favorite.
 *  `jql` Returns the JQL query that the filter uses.
 *  `owner` Returns the owner of the filter.
 *  `searchUrl` Returns a URL to perform the filter's JQL query.
 *  `sharePermissions` Returns the share permissions defined for the filter.
 *  `editPermissions` Returns the edit permissions defined for the filter.
 *  `isWritable` Returns whether the current user has permission to edit the filter.
 *  `subscriptions` Returns the users that are subscribed to the filter.
 *  `viewUrl` Returns a URL to view the filter.
*/
    expand?: string;
    /**
     * EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be returned. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideSharePermissions?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanFilterDetails> {
  const result = await api.rest.getFiltersPaginated({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete filter
 * @request DELETE :/rest/api/3/filter/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteFilter(
  /**
   * The ID of the filter to delete.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteFilter({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get filter
 * @request GET :/rest/api/3/filter/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFilter(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
    /**
     * EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be returned. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideSharePermissions?: boolean;
  },
  /**
   * The ID of the filter to return.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<Filter> {
  const result = await api.rest.getFilter({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update filter
 * @request PUT :/rest/api/3/filter/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateFilter(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
    /**
     * EXPERIMENTAL: Whether share permissions are overridden to enable the addition of any share permissions to filters. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideSharePermissions?: boolean;
  },
  /**
   * The ID of the filter to update.
   */
  id: number,
  /** Request body */
  data: Filter,
  headers?: hasuraSdk.JSONValue,
): Promise<Filter> {
  const result = await api.rest.updateFilter({
    query: query,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Reset columns
 * @request DELETE :/rest/api/3/filter/{id}/columns
 * @allowrelaxedtypes
 */
export async function deleteRestResetColumns(
  /**
   * The ID of the filter.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.resetColumns({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get columns
 * @request GET :/rest/api/3/filter/{id}/columns
 * @readonly
 */
export async function getRestGetColumns(
  /**
   * The ID of the filter.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ColumnItem[]> {
  const result = await api.rest.getColumns({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set columns
 * @request PUT :/rest/api/3/filter/{id}/columns
 * @allowrelaxedtypes
 */
export async function putRestSetColumns(
  /**
   * The ID of the filter.
   */
  id: number,
  /** Request body */
  data: string[],
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setColumns({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove filter as favorite
 * @request DELETE :/rest/api/3/filter/{id}/favourite
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteFavouriteForFilter(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
  },
  /**
   * The ID of the filter.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<Filter> {
  const result = await api.rest.deleteFavouriteForFilter({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add filter as favorite
 * @request PUT :/rest/api/3/filter/{id}/favourite
 * @allowrelaxedtypes
 */
export async function putRestSetFavouriteForFilter(
  query: {
    /**
* Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
 *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
*/
    expand?: string;
  },
  /**
   * The ID of the filter.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<Filter> {
  const result = await api.rest.setFavouriteForFilter({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Change filter owner
 * @request PUT :/rest/api/3/filter/{id}/owner
 * @allowrelaxedtypes
 */
export async function putRestChangeFilterOwner(
  /**
   * The ID of the filter to update.
   */
  id: number,
  /** Request body */
  data: ChangeFilterOwner,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.changeFilterOwner({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get share permissions
 * @request GET :/rest/api/3/filter/{id}/permission
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetSharePermissions(
  /**
   * The ID of the filter.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<SharePermission[]> {
  const result = await api.rest.getSharePermissions({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add share permission
 * @request POST :/rest/api/3/filter/{id}/permission
 * @allowrelaxedtypes
 */
export async function postRestAddSharePermission(
  /**
   * The ID of the filter.
   */
  id: number,
  /** Request body */
  data: SharePermissionInputBean,
  headers?: hasuraSdk.JSONValue,
): Promise<SharePermission[]> {
  const result = await api.rest.addSharePermission({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete share permission
 * @request DELETE :/rest/api/3/filter/{id}/permission/{permissionId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteSharePermission(
  /**
   * The ID of the filter.
   */
  id: number,
  /**
   * The ID of the share permission.
   */
  permissionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteSharePermission({
    id: id,
    permissionId: permissionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get share permission
 * @request GET :/rest/api/3/filter/{id}/permission/{permissionId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetSharePermission(
  /**
   * The ID of the filter.
   */
  id: number,
  /**
   * The ID of the share permission.
   */
  permissionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<SharePermission> {
  const result = await api.rest.getSharePermission({
    id: id,
    permissionId: permissionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Remove group
 * @request DELETE :/rest/api/3/group
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveGroup(
  query: {
    groupname?: string;
    /**
     * The ID of the group. This parameter cannot be used with the `groupname` parameter.
     */
    groupId?: string;
    /**
* As a group's name can change, use of `swapGroupId` is recommended to identify a group.  
The group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the `swapGroupId` parameter.
*/
    swapGroup?: string;
    /**
     * The ID of the group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the `swapGroup` parameter.
     */
    swapGroupId?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeGroup({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get group
 * @request GET :/rest/api/3/group
 * @readonly
 */
export async function getRestGetGroup(
  query: {
    /**
* As a group's name can change, use of `groupId` is recommended to identify a group.  
The name of the group. This parameter cannot be used with the `groupId` parameter.
*/
    groupname?: string;
    /**
     * The ID of the group. This parameter cannot be used with the `groupName` parameter.
     */
    groupId?: string;
    /**
     * List of fields to expand.
     */
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Group> {
  const result = await api.rest.getGroup({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create group
 * @request POST :/rest/api/3/group
 */
export async function postRestCreateGroup(
  /** Request body */
  data: AddGroupBean,
  headers?: hasuraSdk.JSONValue,
): Promise<Group> {
  const result = await api.rest.createGroup({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk get groups
 * @request GET :/rest/api/3/group/bulk
 * @readonly
 */
export async function getRestBulkGetGroups(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The ID of a group. To specify multiple IDs, pass multiple `groupId` parameters. For example, `groupId=5b10a2844c20165700ede21g&groupId=5b10ac8d82e05b22cc7d4ef5`.
     */
    groupId?: string[];
    /**
     * The name of a group. To specify multiple names, pass multiple `groupName` parameters. For example, `groupName=administrators&groupName=jira-software-users`.
     */
    groupName?: string[];
    /**
     * The access level of a group. Valid values: 'site-admin', 'admin', 'user'.
     */
    accessType?: string;
    /**
     * The application key of the product user groups to search for. Valid values: 'jira-servicedesk', 'jira-software', 'jira-product-discovery', 'jira-core'.
     */
    applicationKey?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanGroupDetails> {
  const result = await api.rest.bulkGetGroups({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get users from group
 * @request GET :/rest/api/3/group/member
 * @readonly
 */
export async function getRestGetUsersFromGroup(
  query: {
    /**
* As a group's name can change, use of `groupId` is recommended to identify a group.  
The name of the group. This parameter cannot be used with the `groupId` parameter.
*/
    groupname?: string;
    /**
     * The ID of the group. This parameter cannot be used with the `groupName` parameter.
     */
    groupId?: string;
    /**
     * Include inactive users.
     */
    includeInactiveUsers?: boolean;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanUserDetails> {
  const result = await api.rest.getUsersFromGroup({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Remove user from group
 * @request DELETE :/rest/api/3/group/user
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveUserFromGroup(
  query: {
    /**
* As a group's name can change, use of `groupId` is recommended to identify a group.  
The name of the group. This parameter cannot be used with the `groupId` parameter.
*/
    groupname?: string;
    /**
     * The ID of the group. This parameter cannot be used with the `groupName` parameter.
     */
    groupId?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeUserFromGroup({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Add user to group
 * @request POST :/rest/api/3/group/user
 */
export async function postRestAddUserToGroup(
  query: {
    /**
* As a group's name can change, use of `groupId` is recommended to identify a group.  
The name of the group. This parameter cannot be used with the `groupId` parameter.
*/
    groupname?: string;
    /**
     * The ID of the group. This parameter cannot be used with the `groupName` parameter.
     */
    groupId?: string;
  },
  /** Request body */
  data: UpdateUserToGroupBean,
  headers?: hasuraSdk.JSONValue,
): Promise<Group> {
  const result = await api.rest.addUserToGroup({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find groups
 * @request GET :/rest/api/3/groups/picker
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindGroups(
  query: {
    /**
     * This parameter is deprecated, setting it does not affect the results. To find groups containing a particular user, use [Get user groups](#api-rest-api-3-user-groups-get).
     */
    accountId?: string;
    /**
     * The string to find in group names.
     */
    query?: string;
    /**
* As a group's name can change, use of `excludeGroupIds` is recommended to identify a group.  
A group to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, `exclude=group1&exclude=group2`. This parameter cannot be used with the `excludeGroupIds` parameter.
*/
    exclude?: string[];
    /**
     * A group ID to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, `excludeId=group1-id&excludeId=group2-id`. This parameter cannot be used with the `excludeGroups` parameter.
     */
    excludeId?: string[];
    /**
     * The maximum number of groups to return. The maximum number of groups that can be returned is limited by the system property `jira.ajax.autocomplete.limit`.
     */
    maxResults?: number;
    /**
     * Whether the search for groups should be case insensitive.
     */
    caseInsensitive?: boolean;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    userName?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<FoundGroups> {
  const result = await api.rest.findGroups({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users and groups
 * @request GET :/rest/api/3/groupuserpicker
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindUsersAndGroups(
  query: {
    /**
     * The search string.
     */
    query: string;
    /**
     * The maximum number of items to return in each list.
     */
    maxResults?: number;
    /**
     * Whether the user avatar should be returned. If an invalid value is provided, the default value is used.
     */
    showAvatar?: boolean;
    /**
     * The custom field ID of the field this request is for.
     */
    fieldId?: string;
    /**
     * The ID of a project that returned users and groups must have permission to view. To include multiple projects, provide an ampersand-separated list. For example, `projectId=10000&projectId=10001`. This parameter is only used when `fieldId` is present.
     */
    projectId?: string[];
    /**
     * The ID of an issue type that returned users and groups must have permission to view. To include multiple issue types, provide an ampersand-separated list. For example, `issueTypeId=10000&issueTypeId=10001`. Special values, such as `-1` (all standard issue types) and `-2` (all subtask issue types), are supported. This parameter is only used when `fieldId` is present.
     */
    issueTypeId?: string[];
    /**
     * The size of the avatar to return. If an invalid value is provided, the default value is used.
     */
    avatarSize?:
      | "xsmall"
      | "xsmall@2x"
      | "xsmall@3x"
      | "small"
      | "small@2x"
      | "small@3x"
      | "medium"
      | "medium@2x"
      | "medium@3x"
      | "large"
      | "large@2x"
      | "large@3x"
      | "xlarge"
      | "xlarge@2x"
      | "xlarge@3x"
      | "xxlarge"
      | "xxlarge@2x"
      | "xxlarge@3x"
      | "xxxlarge"
      | "xxxlarge@2x"
      | "xxxlarge@3x";
    /**
     * Whether the search for groups should be case insensitive.
     */
    caseInsensitive?: boolean;
    /**
     * Whether Connect app users and groups should be excluded from the search results. If an invalid value is provided, the default value is used.
     */
    excludeConnectAddons?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<FoundUsersAndGroups> {
  const result = await api.rest.findUsersAndGroups({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get license
 * @request GET :/rest/api/3/instance/license
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetLicense(
  headers?: hasuraSdk.JSONValue,
): Promise<License> {
  const result = await api.rest.getLicense({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue
 * @request POST :/rest/api/3/issue
 * @allowrelaxedtypes
 */
export async function postRestCreateIssue(
  query: {
    /**
     * Whether the project in which the issue is created is added to the user's **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user's history for a project. These values are then used to provide defaults on the issue create screen.
     */
    updateHistory?: boolean;
  },
  /** Request body */
  data: IssueUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<CreatedIssue> {
  const result = await api.rest.createIssue({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk create issue
 * @request POST :/rest/api/3/issue/bulk
 * @allowrelaxedtypes
 */
export async function postRestCreateIssues(
  /** Request body */
  data: IssuesUpdateBean,
  headers?: hasuraSdk.JSONValue,
): Promise<CreatedIssues> {
  const result = await api.rest.createIssues({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get create issue metadata
 * @request GET :/rest/api/3/issue/createmeta
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetCreateIssueMeta(
  query: {
    /**
     * List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, `projectIds=10000,10001&projectIds=10020,10021`. This parameter may be provided with `projectKeys`.
     */
    projectIds?: string[];
    /**
     * List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, `projectKeys=proj1,proj2&projectKeys=proj3`. This parameter may be provided with `projectIds`.
     */
    projectKeys?: string[];
    /**
     * List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, `issuetypeIds=10000,10001&issuetypeIds=10020,10021`. This parameter may be provided with `issuetypeNames`.
     */
    issuetypeIds?: string[];
    /**
     * List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, `issuetypeNames=name1,name2&issuetypeNames=name3`. This parameter may be provided with `issuetypeIds`.
     */
    issuetypeNames?: string[];
    /**
     * Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts `projects.issuetypes.fields`, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the `fields` and `update` fields in [Create issue](#api-rest-api-3-issue-post) and [Create issues](#api-rest-api-3-issue-bulk-post).
     */
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<IssueCreateMetadata> {
  const result = await api.rest.getCreateIssueMeta({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue picker suggestions
 * @request GET :/rest/api/3/issue/picker
 * @readonly
 */
export async function getRestGetIssuePickerResource(
  query: {
    /**
     * A string to match against text fields in the issue such as title, description, or comments.
     */
    query?: string;
    /**
     * A JQL query defining a list of issues to search for the query term. Note that `username` and `userkey` cannot be used as search terms for this parameter, due to privacy reasons. Use `accountId` instead.
     */
    currentJQL?: string;
    /**
     * The key of an issue to exclude from search results. For example, the issue the user is viewing when they perform this query.
     */
    currentIssueKey?: string;
    /**
     * The ID of a project that suggested issues must belong to.
     */
    currentProjectId?: string;
    /**
     * Indicate whether to include subtasks in the suggestions list.
     */
    showSubTasks?: boolean;
    /**
     * When `currentIssueKey` is a subtask, whether to include the parent issue in the suggestions if it matches the query.
     */
    showSubTaskParent?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<IssuePickerSuggestions> {
  const result = await api.rest.getIssuePickerResource({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk set issues properties by list
 * @request POST :/rest/api/3/issue/properties
 * @allowrelaxedtypes
 */
export async function postRestBulkSetIssuesPropertiesList(
  /** Request body */
  data: IssueEntityProperties,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.bulkSetIssuesPropertiesList({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Bulk set issue properties by issue
 * @request POST :/rest/api/3/issue/properties/multi
 * @allowrelaxedtypes
 */
export async function postRestBulkSetIssuePropertiesByIssue(
  /** Request body */
  data: MultiIssueEntityProperties,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.bulkSetIssuePropertiesByIssue({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Bulk delete issue property
 * @request DELETE :/rest/api/3/issue/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestBulkDeleteIssueProperty(
  /**
   * The key of the property.
   */
  propertyKey: string,
  /** Request body */
  data: IssueFilterForBulkPropertyDelete,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.bulkDeleteIssueProperty({
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Bulk set issue property
 * @request PUT :/rest/api/3/issue/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestBulkSetIssueProperty(
  /**
   * The key of the property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: BulkIssuePropertyUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.bulkSetIssueProperty({
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get is watching issue bulk
 * @request POST :/rest/api/3/issue/watching
 */
export async function postRestGetIsWatchingIssueBulk(
  /** Request body */
  data: IssueList,
  headers?: hasuraSdk.JSONValue,
): Promise<BulkIssueIsWatching> {
  const result = await api.rest.getIsWatchingIssueBulk({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssue(
  query: {
    /**
     * Whether the issue's subtasks are deleted when the issue is deleted.
     */
    deleteSubtasks?: "true" | "false";
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssue({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue
 * @request GET :/rest/api/3/issue/{issueIdOrKey}
 * @readonly
 */
export async function getRestGetIssue(
  query: {
    /**
* A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

Examples:

 *  `summary,comment` Returns only the summary and comments fields.
 *  `-description` Returns all (default) fields except description.
 *  `*navigable,-comment` Returns all navigable fields except comment.

This parameter may be specified multiple times. For example, `fields=field1,field2& fields=field3`.

Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-3-search-get) and [Search for issues using JQL (POST)](#api-rest-api-3-search-post) where the default is all navigable fields.
*/
    fields?: string[];
    /**
     * Whether fields in `fields` are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field's key may differ from its ID.
     */
    fieldsByKeys?: boolean;
    /**
* Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Returns a JSON array for each version of a field's value, with the highest number representing the most recent version. Note: When included in the request, the `fields` parameter is ignored.
*/
    expand?: string;
    /**
* A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:

 *  `*all` Returns all issue properties.
 *  Any issue property key, prefixed with a minus to exclude.

Examples:

 *  `*all` Returns all properties.
 *  `*all,-prop1` Returns all properties except `prop1`.
 *  `prop1,prop2` Returns `prop1` and `prop2` properties.

This parameter may be specified multiple times. For example, `properties=prop1,prop2& properties=prop3`.
*/
    properties?: string[];
    /**
     * Whether the project in which the issue is created is added to the user's **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-3-search-get) `lastViewed` field.
     */
    updateHistory?: boolean;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueBean> {
  const result = await api.rest.getIssue({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Edit issue
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}
 * @allowrelaxedtypes
 */
export async function putRestEditIssue(
  query: {
    /**
     * Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn't have the necessary permission the request is ignored.
     */
    notifyUsers?: boolean;
    /**
     * Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideScreenSecurity?: boolean;
    /**
     * Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideEditableFlag?: boolean;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: IssueUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.editIssue({
    query: query,
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Assign issue
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/assignee
 * @allowrelaxedtypes
 */
export async function putRestAssignIssue(
  /**
   * The ID or key of the issue to be assigned.
   */
  issueIdOrKey: string,
  /** Request body */
  data: User,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignIssue({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Add attachment
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/attachments
 */
export async function postRestAddAttachment(
  /**
   * The ID or key of the issue that attachments are added to.
   */
  issueIdOrKey: string,
  /** Request body */
  data: File,
  headers?: hasuraSdk.JSONValue,
): Promise<Attachment[]> {
  const result = await api.rest.addAttachment({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get changelogs
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/changelog
 * @readonly
 */
export async function getRestGetChangeLogs(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanChangelog> {
  const result = await api.rest.getChangeLogs({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get changelogs by IDs
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/changelog/list
 */
export async function postRestGetChangeLogsByIds(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: IssueChangelogIds,
  headers?: hasuraSdk.JSONValue,
): Promise<PageOfChangelogs> {
  const result = await api.rest.getChangeLogsByIds({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get comments
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/comment
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetComments(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * [Order](#ordering) the results by a field. Accepts *created* to sort comments by their created date.
     */
    orderBy?: "created" | "-created" | "+created";
    /**
     * Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     */
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageOfComments> {
  const result = await api.rest.getComments({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add comment
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/comment
 * @allowrelaxedtypes
 */
export async function postRestAddComment(
  query: {
    /**
     * Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     */
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: Comment,
  headers?: hasuraSdk.JSONValue,
): Promise<Comment> {
  const result = await api.rest.addComment({
    query: query,
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete comment
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/comment/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteComment(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the comment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteComment({
    issueIdOrKey: issueIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get comment
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/comment/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetComment(
  query: {
    /**
     * Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     */
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the comment.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Comment> {
  const result = await api.rest.getComment({
    query: query,
    issueIdOrKey: issueIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update comment
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/comment/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateComment(
  query: {
    /**
     * Whether users are notified when a comment is updated.
     */
    notifyUsers?: boolean;
    /**
     * Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with the *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideEditableFlag?: boolean;
    /**
     * Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     */
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the comment.
   */
  id: string,
  /** Request body */
  data: Comment,
  headers?: hasuraSdk.JSONValue,
): Promise<Comment> {
  const result = await api.rest.updateComment({
    query: query,
    issueIdOrKey: issueIdOrKey,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get edit issue metadata
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/editmeta
 * @readonly
 */
export async function getRestGetEditIssueMeta(
  query: {
    /**
     * Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideScreenSecurity?: boolean;
    /**
     * Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    overrideEditableFlag?: boolean;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueUpdateMetadata> {
  const result = await api.rest.getEditIssueMeta({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Send notification for issue
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/notify
 * @allowrelaxedtypes
 */
export async function postRestNotify(
  /**
   * ID or key of the issue that the notification is sent for.
   */
  issueIdOrKey: string,
  /** Request body */
  data: Notification,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.notify({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue property keys
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/properties
 * @readonly
 */
export async function getRestGetIssuePropertyKeys(
  /**
   * The key or ID of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getIssuePropertyKeys({
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue property
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueProperty(
  /**
   * The key or ID of the issue.
   */
  issueIdOrKey: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueProperty({
    issueIdOrKey: issueIdOrKey,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue property
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueProperty(
  /**
   * The key or ID of the issue.
   */
  issueIdOrKey: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getIssueProperty({
    issueIdOrKey: issueIdOrKey,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set issue property
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetIssueProperty(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The key of the issue property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setIssueProperty({
    issueIdOrKey: issueIdOrKey,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete remote issue link by global ID
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/remotelink
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteRemoteIssueLinkByGlobalId(
  query: {
    /**
     * The global ID of a remote issue link.
     */
    globalId: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteRemoteIssueLinkByGlobalId({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get remote issue links
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/remotelink
 * @readonly
 */
export async function getRestGetRemoteIssueLinks(
  query: {
    /**
     * The global ID of the remote issue link.
     */
    globalId?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<RemoteIssueLink> {
  const result = await api.rest.getRemoteIssueLinks({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create or update remote issue link
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/remotelink
 */
export async function postRestCreateOrUpdateRemoteIssueLink(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: RemoteIssueLinkRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<RemoteIssueLinkIdentifies> {
  const result = await api.rest.createOrUpdateRemoteIssueLink({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete remote issue link by ID
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteRemoteIssueLinkById(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of a remote issue link.
   */
  linkId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteRemoteIssueLinkById({
    issueIdOrKey: issueIdOrKey,
    linkId: linkId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get remote issue link by ID
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}
 * @readonly
 */
export async function getRestGetRemoteIssueLinkById(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the remote issue link.
   */
  linkId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<RemoteIssueLink> {
  const result = await api.rest.getRemoteIssueLinkById({
    issueIdOrKey: issueIdOrKey,
    linkId: linkId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update remote issue link by ID
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateRemoteIssueLink(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the remote issue link.
   */
  linkId: string,
  /** Request body */
  data: RemoteIssueLinkRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateRemoteIssueLink({
    issueIdOrKey: issueIdOrKey,
    linkId: linkId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get transitions
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/transitions
 * @readonly
 */
export async function getRestGetTransitions(
  query: {
    /**
     * Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts `transitions.fields`, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the `fields` and `update` fields in [Transition issue](#api-rest-api-3-issue-issueIdOrKey-transitions-post).
     */
    expand?: string;
    /**
     * The ID of the transition.
     */
    transitionId?: string;
    /**
     * Whether transitions with the condition *Hide From User Condition* are included in the response.
     */
    skipRemoteOnlyCondition?: boolean;
    /**
     * Whether details of transitions that fail a condition are included in the response
     */
    includeUnavailableTransitions?: boolean;
    /**
     * Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value.
     */
    sortByOpsBarAndStatus?: boolean;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Transitions> {
  const result = await api.rest.getTransitions({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Transition issue
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/transitions
 * @allowrelaxedtypes
 */
export async function postRestDoTransition(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: IssueUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.doTransition({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete vote
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/votes
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveVote(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeVote({
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get votes
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/votes
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetVotes(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Votes> {
  const result = await api.rest.getVotes({
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add vote
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/votes
 * @allowrelaxedtypes
 */
export async function postRestAddVote(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addVote({
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete watcher
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/watchers
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveWatcher(
  query: {
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required.
     */
    accountId?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeWatcher({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue watchers
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/watchers
 * @readonly
 */
export async function getRestGetIssueWatchers(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Watchers> {
  const result = await api.rest.getIssueWatchers({
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add watcher
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/watchers
 * @allowrelaxedtypes
 */
export async function postRestAddWatcher(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addWatcher({
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue worklogs
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/worklog
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueWorklog(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned.
     */
    startedAfter?: number;
    /**
     * The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned.
     */
    startedBefore?: number;
    /**
     * Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts`properties`, which returns worklog properties.
     */
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageOfWorklogs> {
  const result = await api.rest.getIssueWorklog({
    query: query,
    issueIdOrKey: issueIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add worklog
 * @request POST :/rest/api/3/issue/{issueIdOrKey}/worklog
 * @allowrelaxedtypes
 */
export async function postRestAddWorklog(
  query: {
    /**
     * Whether users watching the issue are notified by email.
     */
    notifyUsers?: boolean;
    /**
* Defines how to update the issue's time estimate, the options are:

 *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
 *  `leave` Leaves the estimate unchanged.
 *  `manual` Reduces the estimate by amount specified in `reduceBy`.
 *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
*/
    adjustEstimate?: "new" | "leave" | "manual" | "auto";
    /**
     * The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     */
    newEstimate?: string;
    /**
     * The amount to reduce the issue's remaining estimate by, as days (\#d), hours (\#h), or minutes (\#m). For example, *2d*. Required when `adjustEstimate` is `manual`.
     */
    reduceBy?: string;
    /**
     * Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts `properties`, which returns worklog properties.
     */
    expand?: string;
    /**
     * Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
     */
    overrideEditableFlag?: boolean;
  },
  /**
   * The ID or key the issue.
   */
  issueIdOrKey: string,
  /** Request body */
  data: Worklog,
  headers?: hasuraSdk.JSONValue,
): Promise<Worklog> {
  const result = await api.rest.addWorklog({
    query: query,
    issueIdOrKey: issueIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete worklog
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/worklog/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorklog(
  query: {
    /**
     * Whether users watching the issue are notified by email.
     */
    notifyUsers?: boolean;
    /**
* Defines how to update the issue's time estimate, the options are:

 *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
 *  `leave` Leaves the estimate unchanged.
 *  `manual` Increases the estimate by amount specified in `increaseBy`.
 *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
*/
    adjustEstimate?: "new" | "leave" | "manual" | "auto";
    /**
     * The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     */
    newEstimate?: string;
    /**
     * The amount to increase the issue's remaining estimate by, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `manual`.
     */
    increaseBy?: string;
    /**
     * Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
     */
    overrideEditableFlag?: boolean;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorklog({
    query: query,
    issueIdOrKey: issueIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get worklog
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/worklog/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorklog(
  query: {
    /**
* Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts

`properties`, which returns worklog properties.
*/
    expand?: string;
  },
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Worklog> {
  const result = await api.rest.getWorklog({
    query: query,
    issueIdOrKey: issueIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update worklog
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/worklog/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateWorklog(
  query: {
    /**
     * Whether users watching the issue are notified by email.
     */
    notifyUsers?: boolean;
    /**
* Defines how to update the issue's time estimate, the options are:

 *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
 *  `leave` Leaves the estimate unchanged.
 *  `auto` Updates the estimate by the difference between the original and updated value of `timeSpent` or `timeSpentSeconds`.
*/
    adjustEstimate?: "new" | "leave" | "manual" | "auto";
    /**
     * The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     */
    newEstimate?: string;
    /**
     * Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties`, which returns worklog properties.
     */
    expand?: string;
    /**
     * Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
     */
    overrideEditableFlag?: boolean;
  },
  /**
   * The ID or key the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  id: string,
  /** Request body */
  data: Worklog,
  headers?: hasuraSdk.JSONValue,
): Promise<Worklog> {
  const result = await api.rest.updateWorklog({
    query: query,
    issueIdOrKey: issueIdOrKey,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get worklog property keys
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties
 * @readonly
 */
export async function getRestGetWorklogPropertyKeys(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  worklogId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getWorklogPropertyKeys({
    issueIdOrKey: issueIdOrKey,
    worklogId: worklogId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete worklog property
 * @request DELETE :/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorklogProperty(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  worklogId: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorklogProperty({
    issueIdOrKey: issueIdOrKey,
    worklogId: worklogId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get worklog property
 * @request GET :/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorklogProperty(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  worklogId: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getWorklogProperty({
    issueIdOrKey: issueIdOrKey,
    worklogId: worklogId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set worklog property
 * @request PUT :/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetWorklogProperty(
  /**
   * The ID or key of the issue.
   */
  issueIdOrKey: string,
  /**
   * The ID of the worklog.
   */
  worklogId: string,
  /**
   * The key of the issue property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setWorklogProperty({
    issueIdOrKey: issueIdOrKey,
    worklogId: worklogId,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Create issue link
 * @request POST :/rest/api/3/issueLink
 * @allowrelaxedtypes
 */
export async function postRestLinkIssues(
  /** Request body */
  data: LinkIssueRequestJsonBean,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.linkIssues({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete issue link
 * @request DELETE :/rest/api/3/issueLink/{linkId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueLink(
  /**
   * The ID of the issue link.
   */
  linkId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueLink({
    linkId: linkId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue link
 * @request GET :/rest/api/3/issueLink/{linkId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueLink(
  /**
   * The ID of the issue link.
   */
  linkId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueLink> {
  const result = await api.rest.getIssueLink({
    linkId: linkId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue link types
 * @request GET :/rest/api/3/issueLinkType
 * @readonly
 */
export async function getRestGetIssueLinkTypes(
  headers?: hasuraSdk.JSONValue,
): Promise<IssueLinkTypes> {
  const result = await api.rest.getIssueLinkTypes({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue link type
 * @request POST :/rest/api/3/issueLinkType
 */
export async function postRestCreateIssueLinkType(
  /** Request body */
  data: IssueLinkType,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueLinkType> {
  const result = await api.rest.createIssueLinkType({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue link type
 * @request DELETE :/rest/api/3/issueLinkType/{issueLinkTypeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueLinkType(
  /**
   * The ID of the issue link type.
   */
  issueLinkTypeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueLinkType({
    issueLinkTypeId: issueLinkTypeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue link type
 * @request GET :/rest/api/3/issueLinkType/{issueLinkTypeId}
 * @readonly
 */
export async function getRestGetIssueLinkType(
  /**
   * The ID of the issue link type.
   */
  issueLinkTypeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueLinkType> {
  const result = await api.rest.getIssueLinkType({
    issueLinkTypeId: issueLinkTypeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update issue link type
 * @request PUT :/rest/api/3/issueLinkType/{issueLinkTypeId}
 */
export async function putRestUpdateIssueLinkType(
  /**
   * The ID of the issue link type.
   */
  issueLinkTypeId: string,
  /** Request body */
  data: IssueLinkType,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueLinkType> {
  const result = await api.rest.updateIssueLinkType({
    issueLinkTypeId: issueLinkTypeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue security schemes
 * @request GET :/rest/api/3/issuesecurityschemes
 * @readonly
 */
export async function getRestGetIssueSecuritySchemes(
  headers?: hasuraSdk.JSONValue,
): Promise<SecuritySchemes> {
  const result = await api.rest.getIssueSecuritySchemes({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue security scheme
 * @request GET :/rest/api/3/issuesecurityschemes/{id}
 * @readonly
 */
export async function getRestGetIssueSecurityScheme(
  /**
   * The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<SecurityScheme> {
  const result = await api.rest.getIssueSecurityScheme({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue security level members
 * @request GET :/rest/api/3/issuesecurityschemes/{issueSecuritySchemeId}/members
 * @readonly
 */
export async function getRestGetIssueSecurityLevelMembers(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of issue security level IDs. To include multiple issue security levels separate IDs with ampersand: `issueSecurityLevelId=10000&issueSecurityLevelId=10001`.
     */
    issueSecurityLevelId?: number[];
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs.
   */
  issueSecuritySchemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueSecurityLevelMember> {
  const result = await api.rest.getIssueSecurityLevelMembers({
    query: query,
    issueSecuritySchemeId: issueSecuritySchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all issue types for user
 * @request GET :/rest/api/3/issuetype
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueAllTypes(
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails[]> {
  const result = await api.rest.getIssueAllTypes({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue type
 * @request POST :/rest/api/3/issuetype
 * @allowrelaxedtypes
 */
export async function postRestCreateIssueType(
  /** Request body */
  data: IssueTypeCreateBean,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails> {
  const result = await api.rest.createIssueType({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue types for project
 * @request GET :/rest/api/3/issuetype/project
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueTypesForProject(
  query: {
    /**
     * The ID of the project.
     */
    projectId: number;
    /**
* The level of the issue type to filter by. Use:

 *  `-1` for Subtask.
 *  `0` for Base.
 *  `1` for Epic.
*/
    level?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails[]> {
  const result = await api.rest.getIssueTypesForProject({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue type
 * @request DELETE :/rest/api/3/issuetype/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueType(
  query: {
    /**
     * The ID of the replacement issue type.
     */
    alternativeIssueTypeId?: string;
  },
  /**
   * The ID of the issue type.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueType({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue type
 * @request GET :/rest/api/3/issuetype/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueType(
  /**
   * The ID of the issue type.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails> {
  const result = await api.rest.getIssueType({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update issue type
 * @request PUT :/rest/api/3/issuetype/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateIssueType(
  /**
   * The ID of the issue type.
   */
  id: string,
  /** Request body */
  data: IssueTypeUpdateBean,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails> {
  const result = await api.rest.updateIssueType({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get alternative issue types
 * @request GET :/rest/api/3/issuetype/{id}/alternatives
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAlternativeIssueTypes(
  /**
   * The ID of the issue type.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeDetails[]> {
  const result = await api.rest.getAlternativeIssueTypes({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Load issue type avatar
 * @request POST :/rest/api/3/issuetype/{id}/avatar2
 */
export async function postRestCreateIssueTypeAvatar(
  query: {
    /**
     * The X coordinate of the top-left corner of the crop region.
     */
    x?: number;
    /**
     * The Y coordinate of the top-left corner of the crop region.
     */
    y?: number;
    /**
     * The length of each side of the crop region.
     */
    size: number;
  },
  /**
   * The ID of the issue type.
   */
  id: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<Avatar> {
  const result = await api.rest.createIssueTypeAvatar({
    query: query,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue type property keys
 * @request GET :/rest/api/3/issuetype/{issueTypeId}/properties
 * @readonly
 */
export async function getRestGetIssueTypePropertyKeys(
  /**
   * The ID of the issue type.
   */
  issueTypeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getIssueTypePropertyKeys({
    issueTypeId: issueTypeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue type property
 * @request DELETE :/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueTypeProperty(
  /**
   * The ID of the issue type.
   */
  issueTypeId: string,
  /**
   * The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueTypeProperty({
    issueTypeId: issueTypeId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue type property
 * @request GET :/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueTypeProperty(
  /**
   * The ID of the issue type.
   */
  issueTypeId: string,
  /**
   * The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getIssueTypeProperty({
    issueTypeId: issueTypeId,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set issue type property
 * @request PUT :/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetIssueTypeProperty(
  /**
   * The ID of the issue type.
   */
  issueTypeId: string,
  /**
   * The key of the issue type property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setIssueTypeProperty({
    issueTypeId: issueTypeId,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all issue type schemes
 * @request GET :/rest/api/3/issuetypescheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllIssueTypeSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of issue type schemes IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
    /**
* [Order](#ordering) the results by a field:

 *  `name` Sorts by issue type scheme name.
 *  `id` Sorts by issue type scheme ID.
*/
    orderBy?: "name" | "-name" | "+name" | "id" | "-id" | "+id";
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `projects` For each issue type schemes, returns information about the projects the issue type scheme is assigned to.
 *  `issueTypes` For each issue type schemes, returns information about the issueTypes the issue type scheme have.
*/
    expand?: string;
    /**
     * String used to perform a case-insensitive partial match with issue type scheme name.
     */
    queryString?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeScheme> {
  const result = await api.rest.getAllIssueTypeSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue type scheme
 * @request POST :/rest/api/3/issuetypescheme
 */
export async function postRestCreateIssueTypeScheme(
  /** Request body */
  data: IssueTypeSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeSchemeID> {
  const result = await api.rest.createIssueTypeScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue type scheme items
 * @request GET :/rest/api/3/issuetypescheme/mapping
 * @readonly
 */
export async function getRestGetIssueTypeSchemesMapping(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of issue type scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `issueTypeSchemeId=10000&issueTypeSchemeId=10001`.
     */
    issueTypeSchemeId?: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeSchemeMapping> {
  const result = await api.rest.getIssueTypeSchemesMapping({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue type schemes for projects
 * @request GET :/rest/api/3/issuetypescheme/project
 * @readonly
 */
export async function getRestGetIssueTypeSchemeForProjects(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of project IDs. To include multiple project IDs, provide an ampersand-separated list. For example, `projectId=10000&projectId=10001`.
     */
    projectId: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeSchemeProjects> {
  const result = await api.rest.getIssueTypeSchemeForProjects({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Assign issue type scheme to project
 * @request PUT :/rest/api/3/issuetypescheme/project
 * @allowrelaxedtypes
 */
export async function putRestAssignIssueTypeSchemeToProject(
  /** Request body */
  data: IssueTypeSchemeProjectAssociation,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignIssueTypeSchemeToProject({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete issue type scheme
 * @request DELETE :/rest/api/3/issuetypescheme/{issueTypeSchemeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueTypeScheme(
  /**
   * The ID of the issue type scheme.
   */
  issueTypeSchemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueTypeScheme({
    issueTypeSchemeId: issueTypeSchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update issue type scheme
 * @request PUT :/rest/api/3/issuetypescheme/{issueTypeSchemeId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateIssueTypeScheme(
  /**
   * The ID of the issue type scheme.
   */
  issueTypeSchemeId: number,
  /** Request body */
  data: IssueTypeSchemeUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateIssueTypeScheme({
    issueTypeSchemeId: issueTypeSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Add issue types to issue type scheme
 * @request PUT :/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype
 * @allowrelaxedtypes
 */
export async function putRestAddIssueTypesToIssueTypeScheme(
  /**
   * The ID of the issue type scheme.
   */
  issueTypeSchemeId: number,
  /** Request body */
  data: IssueTypeIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addIssueTypesToIssueTypeScheme({
    issueTypeSchemeId: issueTypeSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Change order of issue types
 * @request PUT :/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/move
 * @allowrelaxedtypes
 */
export async function putRestReorderIssueTypesInIssueTypeScheme(
  /**
   * The ID of the issue type scheme.
   */
  issueTypeSchemeId: number,
  /** Request body */
  data: OrderOfIssueTypes,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.reorderIssueTypesInIssueTypeScheme({
    issueTypeSchemeId: issueTypeSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove issue type from issue type scheme
 * @request DELETE :/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/{issueTypeId}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveIssueTypeFromIssueTypeScheme(
  /**
   * The ID of the issue type scheme.
   */
  issueTypeSchemeId: number,
  /**
   * The ID of the issue type.
   */
  issueTypeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeIssueTypeFromIssueTypeScheme({
    issueTypeSchemeId: issueTypeSchemeId,
    issueTypeId: issueTypeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue type screen schemes
 * @request GET :/rest/api/3/issuetypescreenscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIssueTypeScreenSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of issue type screen scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
    /**
     * String used to perform a case-insensitive partial match with issue type screen scheme name.
     */
    queryString?: string;
    /**
* [Order](#ordering) the results by a field:

 *  `name` Sorts by issue type screen scheme name.
 *  `id` Sorts by issue type screen scheme ID.
*/
    orderBy?: "name" | "-name" | "+name" | "id" | "-id" | "+id";
    /**
     * Use [expand](#expansion) to include additional information in the response. This parameter accepts `projects` that, for each issue type screen schemes, returns information about the projects the issue type screen scheme is assigned to.
     */
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeScreenScheme> {
  const result = await api.rest.getIssueTypeScreenSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create issue type screen scheme
 * @request POST :/rest/api/3/issuetypescreenscheme
 */
export async function postRestCreateIssueTypeScreenScheme(
  /** Request body */
  data: IssueTypeScreenSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeScreenSchemeId> {
  const result = await api.rest.createIssueTypeScreenScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue type screen scheme items
 * @request GET :/rest/api/3/issuetypescreenscheme/mapping
 * @readonly
 */
export async function getRestGetIssueTypeScreenSchemeMappings(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of issue type screen scheme IDs. To include multiple issue type screen schemes, separate IDs with ampersand: `issueTypeScreenSchemeId=10000&issueTypeScreenSchemeId=10001`.
     */
    issueTypeScreenSchemeId?: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeScreenSchemeItem> {
  const result = await api.rest.getIssueTypeScreenSchemeMappings({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue type screen schemes for projects
 * @request GET :/rest/api/3/issuetypescreenscheme/project
 * @readonly
 */
export async function getRestGetIssueTypeScreenSchemeProjectAssociations(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of project IDs. To include multiple projects, separate IDs with ampersand: `projectId=10000&projectId=10001`.
     */
    projectId: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanIssueTypeScreenSchemesProjects> {
  const result = await api.rest.getIssueTypeScreenSchemeProjectAssociations({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Assign issue type screen scheme to project
 * @request PUT :/rest/api/3/issuetypescreenscheme/project
 * @allowrelaxedtypes
 */
export async function putRestAssignIssueTypeScreenSchemeToProject(
  /** Request body */
  data: IssueTypeScreenSchemeProjectAssociation,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignIssueTypeScreenSchemeToProject({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete issue type screen scheme
 * @request DELETE :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteIssueTypeScreenScheme(
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteIssueTypeScreenScheme({
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update issue type screen scheme
 * @request PUT :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateIssueTypeScreenScheme(
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: string,
  /** Request body */
  data: IssueTypeScreenSchemeUpdateDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateIssueTypeScreenScheme({
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Append mappings to issue type screen scheme
 * @request PUT :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping
 * @allowrelaxedtypes
 */
export async function putRestAppendMappingsForIssueTypeScreenScheme(
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: string,
  /** Request body */
  data: IssueTypeScreenSchemeMappingDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.appendMappingsForIssueTypeScreenScheme({
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update issue type screen scheme default screen scheme
 * @request PUT :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/default
 * @allowrelaxedtypes
 */
export async function putRestUpdateDefaultScreenScheme(
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: string,
  /** Request body */
  data: UpdateDefaultScreenScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateDefaultScreenScheme({
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove mappings from issue type screen scheme
 * @request POST :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/remove
 * @allowrelaxedtypes
 */
export async function postRestRemoveMappingsFromIssueTypeScreenScheme(
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: string,
  /** Request body */
  data: IssueTypeIds,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeMappingsFromIssueTypeScreenScheme({
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get issue type screen scheme projects
 * @request GET :/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/project
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectsForIssueTypeScreenScheme(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    query?: string;
  },
  /**
   * The ID of the issue type screen scheme.
   */
  issueTypeScreenSchemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanProjectDetails> {
  const result = await api.rest.getProjectsForIssueTypeScreenScheme({
    query: query,
    issueTypeScreenSchemeId: issueTypeScreenSchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get field reference data (GET)
 * @request GET :/rest/api/3/jql/autocompletedata
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAutoComplete(
  headers?: hasuraSdk.JSONValue,
): Promise<JQLReferenceData> {
  const result = await api.rest.getAutoComplete({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get field reference data (POST)
 * @request POST :/rest/api/3/jql/autocompletedata
 * @allowrelaxedtypes
 */
export async function postRestGetAutoCompletePost(
  /** Request body */
  data: SearchAutoCompleteFilter,
  headers?: hasuraSdk.JSONValue,
): Promise<JQLReferenceData> {
  const result = await api.rest.getAutoCompletePost({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get field auto complete suggestions
 * @request GET :/rest/api/3/jql/autocompletedata/suggestions
 * @readonly
 */
export async function getRestGetFieldAutoCompleteForQueryString(
  query: {
    /**
     * The name of the field.
     */
    fieldName?: string;
    /**
     * The partial field item name entered by the user.
     */
    fieldValue?: string;
    /**
     * The name of the [ CHANGED operator predicate](https://confluence.atlassian.com/x/hQORLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for which the suggestions are generated. The valid predicate operators are *by*, *from*, and *to*.
     */
    predicateName?: string;
    /**
     * The partial predicate item name entered by the user.
     */
    predicateValue?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<AutoCompleteSuggestions> {
  const result = await api.rest.getFieldAutoCompleteForQueryString({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get precomputation
 * @request GET :/rest/api/3/jql/function/computation
 * @readonly
 */
export async function getRestGetPrecomputations(
  query: {
    functionKey?: string[];
    startAt?: number;
    maxResults?: number;
    orderBy?: string;
    filter?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanJqlFunctionPrecomputationBean> {
  const result = await api.rest.getPrecomputations({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update precomputations
 * @request POST :/rest/api/3/jql/function/computation
 * @allowrelaxedtypes
 */
export async function postRestUpdatePrecomputations(
  /** Request body */
  data: JqlFunctionPrecomputationUpdateRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updatePrecomputations({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Check issues against JQL
 * @request POST :/rest/api/3/jql/match
 */
export async function postRestMatchIssues(
  /** Request body */
  data: IssuesAndJQLQueries,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueMatches> {
  const result = await api.rest.matchIssues({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Parse JQL query
 * @request POST :/rest/api/3/jql/parse
 * @allowrelaxedtypes
 */
export async function postRestParseJqlQueries(
  query: {
    /**
* How to validate the JQL query and treat the validation results. Validation options include:

 *  `strict` Returns all errors. If validation fails, the query structure is not returned.
 *  `warn` Returns all errors. If validation fails but the JQL query is correctly formed, the query structure is returned.
 *  `none` No validation is performed. If JQL query is correctly formed, the query structure is returned.
*/
    validation?: "strict" | "warn" | "none";
  },
  /** Request body */
  data: JqlQueriesToParse,
  headers?: hasuraSdk.JSONValue,
): Promise<ParsedJqlQueries> {
  const result = await api.rest.parseJqlQueries({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Convert user identifiers to account IDs in JQL queries
 * @request POST :/rest/api/3/jql/pdcleaner
 */
export async function postRestMigrateQueries(
  /** Request body */
  data: JQLPersonalDataMigrationRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<ConvertedJQLQueries> {
  const result = await api.rest.migrateQueries({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Sanitize JQL queries
 * @request POST :/rest/api/3/jql/sanitize
 */
export async function postRestSanitiseJqlQueries(
  /** Request body */
  data: JqlQueriesToSanitize,
  headers?: hasuraSdk.JSONValue,
): Promise<SanitizedJqlQueries> {
  const result = await api.rest.sanitiseJqlQueries({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all labels
 * @request GET :/rest/api/3/label
 * @readonly
 */
export async function getRestGetAllLabels(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanString> {
  const result = await api.rest.getAllLabels({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get approximate license count
 * @request GET :/rest/api/3/license/approximateLicenseCount
 * @readonly
 */
export async function getRestGetApproximateLicenseCount(
  headers?: hasuraSdk.JSONValue,
): Promise<LicenseMetric> {
  const result = await api.rest.getApproximateLicenseCount({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get approximate application license count
 * @request GET :/rest/api/3/license/approximateLicenseCount/product/{applicationKey}
 * @readonly
 */
export async function getRestGetApproximateApplicationLicenseCount(
  applicationKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<LicenseMetric> {
  const result = await api.rest.getApproximateApplicationLicenseCount({
    applicationKey: applicationKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get my permissions
 * @request GET :/rest/api/3/mypermissions
 * @readonly
 */
export async function getRestGetMyPermissions(
  query: {
    /**
     * The key of project. Ignored if `projectId` is provided.
     */
    projectKey?: string;
    /**
     * The ID of project.
     */
    projectId?: string;
    /**
     * The key of the issue. Ignored if `issueId` is provided.
     */
    issueKey?: string;
    /**
     * The ID of the issue.
     */
    issueId?: string;
    /**
     * A list of permission keys. (Required) This parameter accepts a comma-separated list. To get the list of available permissions, use [Get all permissions](#api-rest-api-3-permissions-get).
     */
    permissions?: string;
    projectUuid?: string;
    projectConfigurationUuid?: string;
    /**
     * The ID of the comment.
     */
    commentId?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Permissions> {
  const result = await api.rest.getMyPermissions({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete preference
 * @request DELETE :/rest/api/3/mypreferences
 * @allowrelaxedtypes
 */
export async function deleteRestRemovePreference(
  query: {
    /**
     * The key of the preference.
     */
    key: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removePreference({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get preference
 * @request GET :/rest/api/3/mypreferences
 * @readonly
 */
export async function getRestGetPreference(
  query: {
    /**
     * The key of the preference.
     */
    key: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<string> {
  const result = await api.rest.getPreference({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set preference
 * @request PUT :/rest/api/3/mypreferences
 * @allowrelaxedtypes
 */
export async function putRestSetPreference(
  query: {
    /**
     * The key of the preference. The maximum length is 255 characters.
     */
    key: string;
  },
  /** Request body */
  data: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setPreference({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete locale
 * @request DELETE :/rest/api/3/mypreferences/locale
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteLocale(
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteLocale({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get locale
 * @request GET :/rest/api/3/mypreferences/locale
 * @readonly
 */
export async function getRestGetLocale(
  headers?: hasuraSdk.JSONValue,
): Promise<Locale> {
  const result = await api.rest.getLocale({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set locale
 * @request PUT :/rest/api/3/mypreferences/locale
 * @allowrelaxedtypes
 */
export async function putRestSetLocale(
  /** Request body */
  data: Locale,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setLocale({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get current user
 * @request GET :/rest/api/3/myself
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetCurrentUser(
  query: {
    /**
* Use [expand](#expansion) to include additional information about user in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `groups` Returns all groups, including nested groups, the user belongs to.
 *  `applicationRoles` Returns the application roles the user is assigned to.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User> {
  const result = await api.rest.getCurrentUser({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get notification schemes paginated
 * @request GET :/rest/api/3/notificationscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetNotificationSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: string;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: string;
    /**
     * The list of notification schemes IDs to be filtered by
     */
    id?: string[];
    /**
     * The list of projects IDs to be filtered by
     */
    projectId?: string[];
    /**
     * When set to true, returns only the default notification scheme. If you provide project IDs not associated with the default, returns an empty page. The default value is false.
     */
    onlyDefault?: boolean;
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `all` Returns all expandable information
 *  `field` Returns information about any custom fields assigned to receive an event
 *  `group` Returns information about any groups assigned to receive an event
 *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
 *  `projectRole` Returns information about any project roles assigned to receive an event
 *  `user` Returns information about any users assigned to receive an event
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanNotificationScheme> {
  const result = await api.rest.getNotificationSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create notification scheme
 * @request POST :/rest/api/3/notificationscheme
 */
export async function postRestCreateNotificationScheme(
  /** Request body */
  data: CreateNotificationSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationSchemeId> {
  const result = await api.rest.createNotificationScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get projects using notification schemes paginated
 * @request GET :/rest/api/3/notificationscheme/project
 * @readonly
 */
export async function getRestGetNotificationSchemeToProjectMappings(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: string;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: string;
    /**
     * The list of notifications scheme IDs to be filtered out
     */
    notificationSchemeId?: string[];
    /**
     * The list of project IDs to be filtered out
     */
    projectId?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanNotificationSchemeAndProjectMappingJsonBean> {
  const result = await api.rest.getNotificationSchemeToProjectMappings({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get notification scheme
 * @request GET :/rest/api/3/notificationscheme/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetNotificationScheme(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `all` Returns all expandable information
 *  `field` Returns information about any custom fields assigned to receive an event
 *  `group` Returns information about any groups assigned to receive an event
 *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
 *  `projectRole` Returns information about any project roles assigned to receive an event
 *  `user` Returns information about any users assigned to receive an event
*/
    expand?: string;
  },
  /**
   * The ID of the notification scheme. Use [Get notification schemes paginated](#api-rest-api-3-notificationscheme-get) to get a list of notification scheme IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationScheme> {
  const result = await api.rest.getNotificationScheme({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update notification scheme
 * @request PUT :/rest/api/3/notificationscheme/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateNotificationScheme(
  /**
   * The ID of the notification scheme.
   */
  id: string,
  /** Request body */
  data: UpdateNotificationSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateNotificationScheme({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Add notifications to notification scheme
 * @request PUT :/rest/api/3/notificationscheme/{id}/notification
 * @allowrelaxedtypes
 */
export async function putRestAddNotifications(
  /**
   * The ID of the notification scheme.
   */
  id: string,
  /** Request body */
  data: AddNotificationsDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addNotifications({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete notification scheme
 * @request DELETE :/rest/api/3/notificationscheme/{notificationSchemeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteNotificationScheme(
  /**
   * The ID of the notification scheme.
   */
  notificationSchemeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteNotificationScheme({
    notificationSchemeId: notificationSchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Remove notification from notification scheme
 * @request DELETE :/rest/api/3/notificationscheme/{notificationSchemeId}/notification/{notificationId}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveNotificationFromNotificationScheme(
  /**
   * The ID of the notification scheme.
   */
  notificationSchemeId: string,
  /**
   * The ID of the notification.
   */
  notificationId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeNotificationFromNotificationScheme({
    notificationSchemeId: notificationSchemeId,
    notificationId: notificationId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all permissions
 * @request GET :/rest/api/3/permissions
 * @readonly
 */
export async function getRestGetAllPermissions(
  headers?: hasuraSdk.JSONValue,
): Promise<Permissions> {
  const result = await api.rest.getAllPermissions({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get bulk permissions
 * @request POST :/rest/api/3/permissions/check
 */
export async function postRestGetBulkPermissions(
  /** Request body */
  data: BulkPermissionsRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<BulkPermissionGrants> {
  const result = await api.rest.getBulkPermissions({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get permitted projects
 * @request POST :/rest/api/3/permissions/project
 */
export async function postRestGetPermittedProjects(
  /** Request body */
  data: PermissionsKeysBean,
  headers?: hasuraSdk.JSONValue,
): Promise<PermittedProjects> {
  const result = await api.rest.getPermittedProjects({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all permission schemes
 * @request GET :/rest/api/3/permissionscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllPermissionSchemes(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionSchemes> {
  const result = await api.rest.getAllPermissionSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create permission scheme
 * @request POST :/rest/api/3/permissionscheme
 * @allowrelaxedtypes
 */
export async function postRestCreatePermissionScheme(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /** Request body */
  data: PermissionScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionScheme> {
  const result = await api.rest.createPermissionScheme({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete permission scheme
 * @request DELETE :/rest/api/3/permissionscheme/{schemeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeletePermissionScheme(
  /**
   * The ID of the permission scheme being deleted.
   */
  schemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deletePermissionScheme({
    schemeId: schemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get permission scheme
 * @request GET :/rest/api/3/permissionscheme/{schemeId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetPermissionScheme(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The ID of the permission scheme to return.
   */
  schemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionScheme> {
  const result = await api.rest.getPermissionScheme({
    query: query,
    schemeId: schemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update permission scheme
 * @request PUT :/rest/api/3/permissionscheme/{schemeId}
 * @allowrelaxedtypes
 */
export async function putRestUpdatePermissionScheme(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The ID of the permission scheme to update.
   */
  schemeId: number,
  /** Request body */
  data: PermissionScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionScheme> {
  const result = await api.rest.updatePermissionScheme({
    query: query,
    schemeId: schemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get permission scheme grants
 * @request GET :/rest/api/3/permissionscheme/{schemeId}/permission
 * @readonly
 */
export async function getRestGetPermissionSchemeGrants(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

 *  `permissions` Returns all permission grants for each permission scheme.
 *  `user` Returns information about the user who is granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `field` Returns information about the custom field granted the permission.
 *  `all` Returns all expandable information.
*/
    expand?: string;
  },
  /**
   * The ID of the permission scheme.
   */
  schemeId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionGrants> {
  const result = await api.rest.getPermissionSchemeGrants({
    query: query,
    schemeId: schemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create permission grant
 * @request POST :/rest/api/3/permissionscheme/{schemeId}/permission
 */
export async function postRestCreatePermissionGrant(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

 *  `permissions` Returns all permission grants for each permission scheme.
 *  `user` Returns information about the user who is granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `field` Returns information about the custom field granted the permission.
 *  `all` Returns all expandable information.
*/
    expand?: string;
  },
  /**
   * The ID of the permission scheme in which to create a new permission grant.
   */
  schemeId: number,
  /** Request body */
  data: PermissionGrant,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionGrant> {
  const result = await api.rest.createPermissionGrant({
    query: query,
    schemeId: schemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete permission scheme grant
 * @request DELETE :/rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeletePermissionSchemeEntity(
  /**
   * The ID of the permission scheme to delete the permission grant from.
   */
  schemeId: number,
  /**
   * The ID of the permission grant to delete.
   */
  permissionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deletePermissionSchemeEntity({
    schemeId: schemeId,
    permissionId: permissionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get permission scheme grant
 * @request GET :/rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}
 * @readonly
 */
export async function getRestGetPermissionSchemeGrant(
  query: {
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The ID of the permission scheme.
   */
  schemeId: number,
  /**
   * The ID of the permission grant.
   */
  permissionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionGrant> {
  const result = await api.rest.getPermissionSchemeGrant({
    query: query,
    schemeId: schemeId,
    permissionId: permissionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get priorities
 * @request GET :/rest/api/3/priority
 * @readonly
 */
export async function getRestGetPriorities(
  headers?: hasuraSdk.JSONValue,
): Promise<Priority[]> {
  const result = await api.rest.getPriorities({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create priority
 * @request POST :/rest/api/3/priority
 * @allowrelaxedtypes
 */
export async function postRestCreatePriority(
  /** Request body */
  data: CreatePriorityDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<PriorityId> {
  const result = await api.rest.createPriority({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set default priority
 * @request PUT :/rest/api/3/priority/default
 * @allowrelaxedtypes
 */
export async function putRestSetDefaultPriority(
  /** Request body */
  data: SetDefaultPriorityRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setDefaultPriority({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Move priorities
 * @request PUT :/rest/api/3/priority/move
 * @allowrelaxedtypes
 */
export async function putRestMovePriorities(
  /** Request body */
  data: ReorderIssuePriorities,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.movePriorities({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Search priorities
 * @request GET :/rest/api/3/priority/search
 * @readonly
 */
export async function getRestSearchPriorities(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: string;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: string;
    /**
     * The list of priority IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=2&id=3`.
     */
    id?: string[];
    /**
     * Whether only the default priority is returned.
     */
    onlyDefault?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanPriority> {
  const result = await api.rest.searchPriorities({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete priority
 * @request DELETE :/rest/api/3/priority/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeletePriority(
  query: {
    /**
     * The ID of the issue priority that will replace the currently selected resolution.
     */
    replaceWith: string;
  },
  /**
   * The ID of the issue priority.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deletePriority({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get priority
 * @request GET :/rest/api/3/priority/{id}
 * @readonly
 */
export async function getRestGetPriority(
  /**
   * The ID of the issue priority.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Priority> {
  const result = await api.rest.getPriority({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update priority
 * @request PUT :/rest/api/3/priority/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdatePriority(
  /**
   * The ID of the issue priority.
   */
  id: string,
  /** Request body */
  data: UpdatePriorityDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updatePriority({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all projects
 * @request GET :/rest/api/3/project
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllProjects(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

 *  `description` Returns the project description.
 *  `issueTypes` Returns all issue types associated with the project.
 *  `lead` Returns information about the project lead.
 *  `projectKeys` Returns all project keys associated with the project.
*/
    expand?: string;
    /**
     * Returns the user's most recently accessed projects. You may specify the number of results to return up to a maximum of 20. If access is anonymous, then the recently accessed projects are based on the current HTTP session.
     */
    recent?: number;
    /**
     * A list of project properties to return for the project. This parameter accepts a comma-separated list.
     */
    properties?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Project[]> {
  const result = await api.rest.getAllProjects({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create project
 * @request POST :/rest/api/3/project
 * @allowrelaxedtypes
 */
export async function postRestCreateProject(
  /** Request body */
  data: CreateProjectDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectIdentifiers> {
  const result = await api.rest.createProject({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get recent projects
 * @request GET :/rest/api/3/project/recent
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetRecent(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

 *  `description` Returns the project description.
 *  `projectKeys` Returns all project keys associated with a project.
 *  `lead` Returns information about the project lead.
 *  `issueTypes` Returns all issue types associated with the project.
 *  `url` Returns the URL associated with the project.
 *  `permissions` Returns the permissions associated with the project.
 *  `insight` EXPERIMENTAL. Returns the insight details of total issue count and last issue update time for the project.
 *  `*` Returns the project with all available expand options.
*/
    expand?: string;
    /**
     * EXPERIMENTAL. A list of project properties to return for the project. This parameter accepts a comma-separated list. Invalid property names are ignored.
     */
    properties?: StringList[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<Project[]> {
  const result = await api.rest.getRecent({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get projects paginated
 * @request GET :/rest/api/3/project/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestSearchProjects(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
* [Order](#ordering) the results by a field.

 *  `category` Sorts by project category. A complete list of category IDs is found using [Get all project categories](#api-rest-api-3-projectCategory-get).
 *  `issueCount` Sorts by the total number of issues in each project.
 *  `key` Sorts by project key.
 *  `lastIssueUpdatedTime` Sorts by the last issue update time.
 *  `name` Sorts by project name.
 *  `owner` Sorts by project lead.
 *  `archivedDate` EXPERIMENTAL. Sorts by project archived date.
 *  `deletedDate` EXPERIMENTAL. Sorts by project deleted date.
*/
    orderBy?:
      | "category"
      | "-category"
      | "+category"
      | "key"
      | "-key"
      | "+key"
      | "name"
      | "-name"
      | "+name"
      | "owner"
      | "-owner"
      | "+owner"
      | "issueCount"
      | "-issueCount"
      | "+issueCount"
      | "lastIssueUpdatedDate"
      | "-lastIssueUpdatedDate"
      | "+lastIssueUpdatedDate"
      | "archivedDate"
      | "+archivedDate"
      | "-archivedDate"
      | "deletedDate"
      | "+deletedDate"
      | "-deletedDate";
    /**
     * The project IDs to filter the results by. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`. Up to 50 project IDs can be provided.
     */
    id?: number[];
    /**
     * The project keys to filter the results by. To include multiple keys, provide an ampersand-separated list. For example, `keys=PA&keys=PB`. Up to 50 project keys can be provided.
     */
    keys?: string[];
    /**
     * Filter the results using a literal string. Projects with a matching `key` or `name` are returned (case insensitive).
     */
    query?: string;
    /**
     * Orders results by the [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes). This parameter accepts a comma-separated list. Valid values are `business`, `service_desk`, and `software`.
     */
    typeKey?: string;
    /**
     * The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation.
     */
    categoryId?: number;
    /**
* Filter results by projects for which the user can:

 *  `view` the project, meaning that they have one of the following permissions:
    
     *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
     *  *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
     *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
 *  `browse` the project, meaning that they have the *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
 *  `edit` the project, meaning that they have one of the following permissions:
    
     *  *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
     *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
*/
    action?: "view" | "browse" | "edit";
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

 *  `description` Returns the project description.
 *  `projectKeys` Returns all project keys associated with a project.
 *  `lead` Returns information about the project lead.
 *  `issueTypes` Returns all issue types associated with the project.
 *  `url` Returns the URL associated with the project.
 *  `insight` EXPERIMENTAL. Returns the insight details of total issue count and last issue update time for the project.
*/
    expand?: string;
    /**
* EXPERIMENTAL. Filter results by project status:

 *  `live` Search live projects.
 *  `archived` Search archived projects.
 *  `deleted` Search deleted projects, those in the recycle bin.
*/
    status?: ("live" | "archived" | "deleted")[];
    /**
     * EXPERIMENTAL. A list of project properties to return for the project. This parameter accepts a comma-separated list.
     */
    properties?: StringList[];
    /**
     * EXPERIMENTAL. A query string used to search properties. The query string cannot be specified using a JSON object. For example, to search for the value of `nested` from `{"something":{"nested":1,"other":2}}` use `[thepropertykey].something.nested=1`. Note that the propertyQuery key is enclosed in square brackets to enable searching where the propertyQuery key includes dot (.) or equals (=) characters. Note that `thepropertykey` is only returned when included in `properties`.
     */
    propertyQuery?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanProject> {
  const result = await api.rest.searchProjects({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all project types
 * @request GET :/rest/api/3/project/type
 * @readonly
 */
export async function getRestGetAllProjectTypes(
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectType[]> {
  const result = await api.rest.getAllProjectTypes({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get licensed project types
 * @request GET :/rest/api/3/project/type/accessible
 * @readonly
 */
export async function getRestGetAllAccessibleProjectTypes(
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectType[]> {
  const result = await api.rest.getAllAccessibleProjectTypes({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project type by key
 * @request GET :/rest/api/3/project/type/{projectTypeKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectTypeByKey(
  /**
   * The key of the project type.
   */
  projectTypeKey:
    | "software"
    | "service_desk"
    | "business"
    | "product_discovery",
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectType> {
  const result = await api.rest.getProjectTypeByKey({
    projectTypeKey: projectTypeKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get accessible project type by key
 * @request GET :/rest/api/3/project/type/{projectTypeKey}/accessible
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAccessibleProjectTypeByKey(
  /**
   * The key of the project type.
   */
  projectTypeKey:
    | "software"
    | "service_desk"
    | "business"
    | "product_discovery",
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectType> {
  const result = await api.rest.getAccessibleProjectTypeByKey({
    projectTypeKey: projectTypeKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete project
 * @request DELETE :/rest/api/3/project/{projectIdOrKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteProject(
  query: {
    /**
     * Whether this project is placed in the Jira recycle bin where it will be available for restoration.
     */
    enableUndo?: boolean;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteProject({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get project
 * @request GET :/rest/api/3/project/{projectIdOrKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProject(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that the project description, issue types, and project lead are included in all responses by default. Expand options include:

 *  `description` The project description.
 *  `issueTypes` The issue types associated with the project.
 *  `lead` The project lead.
 *  `projectKeys` All project keys associated with the project.
 *  `issueTypeHierarchy` The project issue type hierarchy.
*/
    expand?: string;
    /**
     * A list of project properties to return for the project. This parameter accepts a comma-separated list.
     */
    properties?: string[];
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Project> {
  const result = await api.rest.getProject({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update project
 * @request PUT :/rest/api/3/project/{projectIdOrKey}
 * @allowrelaxedtypes
 */
export async function putRestUpdateProject(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that the project description, issue types, and project lead are included in all responses by default. Expand options include:

 *  `description` The project description.
 *  `issueTypes` The issue types associated with the project.
 *  `lead` The project lead.
 *  `projectKeys` All project keys associated with the project.
*/
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /** Request body */
  data: UpdateProjectDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Project> {
  const result = await api.rest.updateProject({
    query: query,
    projectIdOrKey: projectIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Archive project
 * @request POST :/rest/api/3/project/{projectIdOrKey}/archive
 * @allowrelaxedtypes
 */
export async function postRestArchiveProject(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.archiveProject({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Set project avatar
 * @request PUT :/rest/api/3/project/{projectIdOrKey}/avatar
 * @allowrelaxedtypes
 */
export async function putRestUpdateProjectAvatar(
  /**
   * The ID or (case-sensitive) key of the project.
   */
  projectIdOrKey: string,
  /** Request body */
  data: Avatar,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateProjectAvatar({
    projectIdOrKey: projectIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete project avatar
 * @request DELETE :/rest/api/3/project/{projectIdOrKey}/avatar/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteProjectAvatar(
  /**
   * The project ID or (case-sensitive) key.
   */
  projectIdOrKey: string,
  /**
   * The ID of the avatar.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteProjectAvatar({
    projectIdOrKey: projectIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Load project avatar
 * @request POST :/rest/api/3/project/{projectIdOrKey}/avatar2
 */
export async function postRestCreateProjectAvatar(
  query: {
    /**
     * The X coordinate of the top-left corner of the crop region.
     */
    x?: number;
    /**
     * The Y coordinate of the top-left corner of the crop region.
     */
    y?: number;
    /**
     * The length of each side of the crop region.
     */
    size?: number;
  },
  /**
   * The ID or (case-sensitive) key of the project.
   */
  projectIdOrKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<Avatar> {
  const result = await api.rest.createProjectAvatar({
    query: query,
    projectIdOrKey: projectIdOrKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all project avatars
 * @request GET :/rest/api/3/project/{projectIdOrKey}/avatars
 * @readonly
 */
export async function getRestGetAllProjectAvatars(
  /**
   * The ID or (case-sensitive) key of the project.
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectAvatars> {
  const result = await api.rest.getAllProjectAvatars({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project components paginated
 * @request GET :/rest/api/3/project/{projectIdOrKey}/component
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectComponentsPaginated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
* [Order](#ordering) the results by a field:

 *  `description` Sorts by the component description.
 *  `issueCount` Sorts by the count of issues associated with the component.
 *  `lead` Sorts by the user key of the component's project lead.
 *  `name` Sorts by component name.
*/
    orderBy?:
      | "description"
      | "-description"
      | "+description"
      | "issueCount"
      | "-issueCount"
      | "+issueCount"
      | "lead"
      | "-lead"
      | "+lead"
      | "name"
      | "-name"
      | "+name";
    /**
     * Filter the results using a literal string. Components with a matching `name` or `description` are returned (case insensitive).
     */
    query?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanComponentWithIssueCount> {
  const result = await api.rest.getProjectComponentsPaginated({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project components
 * @request GET :/rest/api/3/project/{projectIdOrKey}/components
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectComponents(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectComponent[]> {
  const result = await api.rest.getProjectComponents({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete project asynchronously
 * @request POST :/rest/api/3/project/{projectIdOrKey}/delete
 * @allowrelaxedtypes
 */
export async function postRestDeleteProjectAsynchronously(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteProjectAsynchronously({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get project features
 * @request GET :/rest/api/3/project/{projectIdOrKey}/features
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetFeaturesForProject(
  /**
   * The ID or (case-sensitive) key of the project.
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ContainerForProjectFeatures> {
  const result = await api.rest.getFeaturesForProject({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set project feature state
 * @request PUT :/rest/api/3/project/{projectIdOrKey}/features/{featureKey}
 * @allowrelaxedtypes
 */
export async function putRestToggleFeatureForProject(
  /**
   * The ID or (case-sensitive) key of the project.
   */
  projectIdOrKey: string,
  /**
   * The key of the feature.
   */
  featureKey: string,
  /** Request body */
  data: ProjectFeatureState,
  headers?: hasuraSdk.JSONValue,
): Promise<ContainerForProjectFeatures> {
  const result = await api.rest.toggleFeatureForProject({
    projectIdOrKey: projectIdOrKey,
    featureKey: featureKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project property keys
 * @request GET :/rest/api/3/project/{projectIdOrKey}/properties
 * @readonly
 */
export async function getRestGetProjectPropertyKeys(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getProjectPropertyKeys({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete project property
 * @request DELETE :/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteProjectProperty(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteProjectProperty({
    projectIdOrKey: projectIdOrKey,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get project property
 * @request GET :/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectProperty(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getProjectProperty({
    projectIdOrKey: projectIdOrKey,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set project property
 * @request PUT :/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetProjectProperty(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The key of the project property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setProjectProperty({
    projectIdOrKey: projectIdOrKey,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Restore deleted or archived project
 * @request POST :/rest/api/3/project/{projectIdOrKey}/restore
 * @allowrelaxedtypes
 */
export async function postRestRestore(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Project> {
  const result = await api.rest.restore({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project roles for project
 * @request GET :/rest/api/3/project/{projectIdOrKey}/role
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectRoles(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.getProjectRoles({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete actors from project role
 * @request DELETE :/rest/api/3/project/{projectIdOrKey}/role/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteActor(
  query: {
    /**
     * The user account ID of the user to remove from the project role.
     */
    user?: string;
    /**
     * The name of the group to remove from the project role. This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended.
     */
    group?: string;
    /**
     * The ID of the group to remove from the project role. This parameter cannot be used with the `group` parameter.
     */
    groupId?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteActor({
    query: query,
    projectIdOrKey: projectIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get project role for project
 * @request GET :/rest/api/3/project/{projectIdOrKey}/role/{id}
 * @readonly
 */
export async function getRestGetProjectRole(
  query: {
    /**
     * Exclude inactive users.
     */
    excludeInactiveUsers?: boolean;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.getProjectRole({
    query: query,
    projectIdOrKey: projectIdOrKey,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add actors to project role
 * @request POST :/rest/api/3/project/{projectIdOrKey}/role/{id}
 */
export async function postRestAddActorUsers(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  /** Request body */
  data: ActorsMap,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.addActorUsers({
    projectIdOrKey: projectIdOrKey,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set actors for project role
 * @request PUT :/rest/api/3/project/{projectIdOrKey}/role/{id}
 */
export async function putRestSetActors(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  /** Request body */
  data: ProjectRoleActorsUpdateBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.setActors({
    projectIdOrKey: projectIdOrKey,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project role details
 * @request GET :/rest/api/3/project/{projectIdOrKey}/roledetails
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectRoleDetails(
  query: {
    /**
     * Whether the roles should be filtered to include only those the user is assigned to.
     */
    currentMember?: boolean;
    excludeConnectAddons?: boolean;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRoleDetails[]> {
  const result = await api.rest.getProjectRoleDetails({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all statuses for project
 * @request GET :/rest/api/3/project/{projectIdOrKey}/statuses
 * @readonly
 */
export async function getRestGetAllStatuses(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeWithStatus[]> {
  const result = await api.rest.getAllStatuses({
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update project type
 * @request PUT :/rest/api/3/project/{projectIdOrKey}/type/{newProjectTypeKey}
 * @allowrelaxedtypes
 */
export async function putRestUpdateProjectType(
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  /**
   * The key of the new project type.
   */
  newProjectTypeKey: "software" | "service_desk" | "business",
  headers?: hasuraSdk.JSONValue,
): Promise<Project> {
  const result = await api.rest.updateProjectType({
    projectIdOrKey: projectIdOrKey,
    newProjectTypeKey: newProjectTypeKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project versions paginated
 * @request GET :/rest/api/3/project/{projectIdOrKey}/version
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetProjectVersionsPaginated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
* [Order](#ordering) the results by a field:

 *  `description` Sorts by version description.
 *  `name` Sorts by version name.
 *  `releaseDate` Sorts by release date, starting with the oldest date. Versions with no release date are listed last.
 *  `sequence` Sorts by the order of appearance in the user interface.
 *  `startDate` Sorts by start date, starting with the oldest date. Versions with no start date are listed last.
*/
    orderBy?:
      | "description"
      | "-description"
      | "+description"
      | "name"
      | "-name"
      | "+name"
      | "releaseDate"
      | "-releaseDate"
      | "+releaseDate"
      | "sequence"
      | "-sequence"
      | "+sequence"
      | "startDate"
      | "-startDate"
      | "+startDate";
    /**
     * Filter the results using a literal string. Versions with matching `name` or `description` are returned (case insensitive).
     */
    query?: string;
    /**
     * A list of status values used to filter the results by version status. This parameter accepts a comma-separated list. The status values are `released`, `unreleased`, and `archived`.
     */
    status?: string;
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `issuesstatus` Returns the number of issues in each status category for each version.
 *  `operations` Returns actions that can be performed on the specified version.
*/
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanVersion> {
  const result = await api.rest.getProjectVersionsPaginated({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project versions
 * @request GET :/rest/api/3/project/{projectIdOrKey}/versions
 * @readonly
 */
export async function getRestGetProjectVersions(
  query: {
    /**
     * Use [expand](#expansion) to include additional information in the response. This parameter accepts `operations`, which returns actions that can be performed on the version.
     */
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectIdOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Version[]> {
  const result = await api.rest.getProjectVersions({
    query: query,
    projectIdOrKey: projectIdOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project's sender email
 * @request GET :/rest/api/3/project/{projectId}/email
 * @readonly
 */
export async function getRestGetProjectEmail(
  /**
   * The project ID.
   */
  projectId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectEmailAddress> {
  const result = await api.rest.getProjectEmail({
    projectId: projectId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set project's sender email
 * @request PUT :/rest/api/3/project/{projectId}/email
 * @allowrelaxedtypes
 */
export async function putRestUpdateProjectEmail(
  /**
   * The project ID.
   */
  projectId: number,
  /** Request body */
  data: ProjectEmailAddress,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateProjectEmail({
    projectId: projectId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get project issue type hierarchy
 * @request GET :/rest/api/3/project/{projectId}/hierarchy
 * @readonly
 */
export async function getRestGetHierarchy(
  /**
   * The ID of the project.
   */
  projectId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectIssueTypeHierarchy> {
  const result = await api.rest.getHierarchy({
    projectId: projectId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project issue security scheme
 * @request GET :/rest/api/3/project/{projectKeyOrId}/issuesecuritylevelscheme
 * @readonly
 */
export async function getRestGetProjectIssueSecurityScheme(
  /**
   * The project ID or project key (case sensitive).
   */
  projectKeyOrId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<SecurityScheme> {
  const result = await api.rest.getProjectIssueSecurityScheme({
    projectKeyOrId: projectKeyOrId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project notification scheme
 * @request GET :/rest/api/3/project/{projectKeyOrId}/notificationscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetNotificationSchemeForProject(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `all` Returns all expandable information
 *  `field` Returns information about any custom fields assigned to receive an event
 *  `group` Returns information about any groups assigned to receive an event
 *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
 *  `projectRole` Returns information about any project roles assigned to receive an event
 *  `user` Returns information about any users assigned to receive an event
*/
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectKeyOrId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<NotificationScheme> {
  const result = await api.rest.getNotificationSchemeForProject({
    query: query,
    projectKeyOrId: projectKeyOrId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get assigned permission scheme
 * @request GET :/rest/api/3/project/{projectKeyOrId}/permissionscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAssignedPermissionScheme(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectKeyOrId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionScheme> {
  const result = await api.rest.getAssignedPermissionScheme({
    query: query,
    projectKeyOrId: projectKeyOrId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Assign permission scheme
 * @request PUT :/rest/api/3/project/{projectKeyOrId}/permissionscheme
 * @allowrelaxedtypes
 */
export async function putRestAssignPermissionScheme(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

 *  `all` Returns all expandable information.
 *  `field` Returns information about the custom field granted the permission.
 *  `group` Returns information about the group that is granted the permission.
 *  `permissions` Returns all permission grants for each permission scheme.
 *  `projectRole` Returns information about the project role granted the permission.
 *  `user` Returns information about the user who is granted the permission.
*/
    expand?: string;
  },
  /**
   * The project ID or project key (case sensitive).
   */
  projectKeyOrId: string,
  /** Request body */
  data: IdBean,
  headers?: hasuraSdk.JSONValue,
): Promise<PermissionScheme> {
  const result = await api.rest.assignPermissionScheme({
    query: query,
    projectKeyOrId: projectKeyOrId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get project issue security levels
 * @request GET :/rest/api/3/project/{projectKeyOrId}/securitylevel
 * @readonly
 */
export async function getRestGetSecurityLevelsForProject(
  /**
   * The project ID or project key (case sensitive).
   */
  projectKeyOrId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectIssueSecurityLevels> {
  const result = await api.rest.getSecurityLevelsForProject({
    projectKeyOrId: projectKeyOrId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all project categories
 * @request GET :/rest/api/3/projectCategory
 * @readonly
 */
export async function getRestGetAllProjectCategories(
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectCategory[]> {
  const result = await api.rest.getAllProjectCategories({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create project category
 * @request POST :/rest/api/3/projectCategory
 */
export async function postRestCreateProjectCategory(
  /** Request body */
  data: ProjectCategory,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectCategory> {
  const result = await api.rest.createProjectCategory({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete project category
 * @request DELETE :/rest/api/3/projectCategory/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveProjectCategory(
  /**
   * ID of the project category to delete.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeProjectCategory({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get project category by ID
 * @request GET :/rest/api/3/projectCategory/{id}
 * @readonly
 */
export async function getRestGetProjectCategoryById(
  /**
   * The ID of the project category.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectCategory> {
  const result = await api.rest.getProjectCategoryById({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update project category
 * @request PUT :/rest/api/3/projectCategory/{id}
 */
export async function putRestUpdateProjectCategory(
  id: number,
  /** Request body */
  data: ProjectCategory,
  headers?: hasuraSdk.JSONValue,
): Promise<UpdatedProjectCategory> {
  const result = await api.rest.updateProjectCategory({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Validate project key
 * @request GET :/rest/api/3/projectvalidate/key
 * @readonly
 */
export async function getRestValidateProjectKey(
  query: {
    /**
     * The project key.
     */
    key?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ErrorCollection> {
  const result = await api.rest.validateProjectKey({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get valid project key
 * @request GET :/rest/api/3/projectvalidate/validProjectKey
 * @readonly
 */
export async function getRestGetValidProjectKey(
  query: {
    /**
     * The project key.
     */
    key?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<string> {
  const result = await api.rest.getValidProjectKey({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get valid project name
 * @request GET :/rest/api/3/projectvalidate/validProjectName
 * @readonly
 */
export async function getRestGetValidProjectName(
  query: {
    /**
     * The project name.
     */
    name: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<string> {
  const result = await api.rest.getValidProjectName({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get resolutions
 * @request GET :/rest/api/3/resolution
 * @readonly
 */
export async function getRestGetResolutions(
  headers?: hasuraSdk.JSONValue,
): Promise<Resolution[]> {
  const result = await api.rest.getResolutions({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create resolution
 * @request POST :/rest/api/3/resolution
 */
export async function postRestCreateResolution(
  /** Request body */
  data: CreateResolutionDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<ResolutionId> {
  const result = await api.rest.createResolution({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set default resolution
 * @request PUT :/rest/api/3/resolution/default
 * @allowrelaxedtypes
 */
export async function putRestSetDefaultResolution(
  /** Request body */
  data: SetDefaultResolutionRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setDefaultResolution({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Move resolutions
 * @request PUT :/rest/api/3/resolution/move
 * @allowrelaxedtypes
 */
export async function putRestMoveResolutions(
  /** Request body */
  data: ReorderIssueResolutionsRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.moveResolutions({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Search resolutions
 * @request GET :/rest/api/3/resolution/search
 * @readonly
 */
export async function getRestSearchResolutions(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: string;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: string;
    /**
     * The list of resolutions IDs to be filtered out
     */
    id?: string[];
    /**
     * When set to true, return default only, when IDs provided, if none of them is default, return empty page. Default value is false
     */
    onlyDefault?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanResolutionJsonBean> {
  const result = await api.rest.searchResolutions({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete resolution
 * @request DELETE :/rest/api/3/resolution/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteResolution(
  query: {
    /**
     * The ID of the issue resolution that will replace the currently selected resolution.
     */
    replaceWith: string;
  },
  /**
   * The ID of the issue resolution.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteResolution({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get resolution
 * @request GET :/rest/api/3/resolution/{id}
 * @readonly
 */
export async function getRestGetResolution(
  /**
   * The ID of the issue resolution value.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Resolution> {
  const result = await api.rest.getResolution({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update resolution
 * @request PUT :/rest/api/3/resolution/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateResolution(
  /**
   * The ID of the issue resolution.
   */
  id: string,
  /** Request body */
  data: UpdateResolutionDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateResolution({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all project roles
 * @request GET :/rest/api/3/role
 * @readonly
 */
export async function getRestGetAllProjectRoles(
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole[]> {
  const result = await api.rest.getAllProjectRoles({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create project role
 * @request POST :/rest/api/3/role
 */
export async function postRestCreateProjectRole(
  /** Request body */
  data: CreateUpdateRoleRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.createProjectRole({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete project role
 * @request DELETE :/rest/api/3/role/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteProjectRole(
  query: {
    /**
     * The ID of the project role that will replace the one being deleted.
     */
    swap?: number;
  },
  /**
   * The ID of the project role to delete. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteProjectRole({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get project role by ID
 * @request GET :/rest/api/3/role/{id}
 * @readonly
 */
export async function getRestGetProjectRoleById(
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.getProjectRoleById({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Partial update project role
 * @request POST :/rest/api/3/role/{id}
 */
export async function postRestPartialUpdateProjectRole(
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  /** Request body */
  data: CreateUpdateRoleRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.partialUpdateProjectRole({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Fully update project role
 * @request PUT :/rest/api/3/role/{id}
 */
export async function putRestFullyUpdateProjectRole(
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  /** Request body */
  data: CreateUpdateRoleRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.fullyUpdateProjectRole({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete default actors from project role
 * @request DELETE :/rest/api/3/role/{id}/actors
 */
export async function deleteRestDeleteProjectRoleActorsFromRole(
  query: {
    /**
     * The user account ID of the user to remove as a default actor.
     */
    user?: string;
    /**
     * The group ID of the group to be removed as a default actor. This parameter cannot be used with the `group` parameter.
     */
    groupId?: string;
    /**
     * The group name of the group to be removed as a default actor.This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended.
     */
    group?: string;
  },
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.deleteProjectRoleActorsFromRole({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get default actors for project role
 * @request GET :/rest/api/3/role/{id}/actors
 * @readonly
 */
export async function getRestGetProjectRoleActorsForRole(
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.getProjectRoleActorsForRole({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add default actors to project role
 * @request POST :/rest/api/3/role/{id}/actors
 */
export async function postRestAddProjectRoleActorsToRole(
  /**
   * The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
   */
  id: number,
  /** Request body */
  data: ActorInputBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ProjectRole> {
  const result = await api.rest.addProjectRoleActorsToRole({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get screens
 * @request GET :/rest/api/3/screens
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetScreens(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of screen IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
    /**
     * String used to perform a case-insensitive partial match with screen name.
     */
    queryString?: string;
    /**
     * The scope filter string. To filter by multiple scope, provide an ampersand-separated list. For example, `scope=GLOBAL&scope=PROJECT`.
     */
    scope?: ("GLOBAL" | "TEMPLATE" | "PROJECT")[];
    /**
* [Order](#ordering) the results by a field:

 *  `id` Sorts by screen ID.
 *  `name` Sorts by screen name.
*/
    orderBy?: "name" | "-name" | "+name" | "id" | "-id" | "+id";
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanScreen> {
  const result = await api.rest.getScreens({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create screen
 * @request POST :/rest/api/3/screens
 * @allowrelaxedtypes
 */
export async function postRestCreateScreen(
  /** Request body */
  data: ScreenDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Screen> {
  const result = await api.rest.createScreen({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add field to default screen
 * @request POST :/rest/api/3/screens/addToDefault/{fieldId}
 * @allowrelaxedtypes
 */
export async function postRestAddFieldToDefaultScreen(
  /**
   * The ID of the field.
   */
  fieldId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.addFieldToDefaultScreen({
    fieldId: fieldId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete screen
 * @request DELETE :/rest/api/3/screens/{screenId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteScreen(
  /**
   * The ID of the screen.
   */
  screenId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteScreen({
    screenId: screenId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Update screen
 * @request PUT :/rest/api/3/screens/{screenId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateScreen(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /** Request body */
  data: UpdateScreenDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<Screen> {
  const result = await api.rest.updateScreen({
    screenId: screenId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get available screen fields
 * @request GET :/rest/api/3/screens/{screenId}/availableFields
 * @readonly
 */
export async function getRestGetAvailableScreenFields(
  /**
   * The ID of the screen.
   */
  screenId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableField[]> {
  const result = await api.rest.getAvailableScreenFields({
    screenId: screenId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all screen tabs
 * @request GET :/rest/api/3/screens/{screenId}/tabs
 * @readonly
 */
export async function getRestGetAllScreenTabs(
  query: {
    /**
     * The key of the project.
     */
    projectKey?: string;
  },
  /**
   * The ID of the screen.
   */
  screenId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableTab[]> {
  const result = await api.rest.getAllScreenTabs({
    query: query,
    screenId: screenId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create screen tab
 * @request POST :/rest/api/3/screens/{screenId}/tabs
 */
export async function postRestAddScreenTab(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /** Request body */
  data: ScreenableTab,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableTab> {
  const result = await api.rest.addScreenTab({
    screenId: screenId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete screen tab
 * @request DELETE :/rest/api/3/screens/{screenId}/tabs/{tabId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteScreenTab(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteScreenTab({
    screenId: screenId,
    tabId: tabId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Update screen tab
 * @request PUT :/rest/api/3/screens/{screenId}/tabs/{tabId}
 */
export async function putRestRenameScreenTab(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  /** Request body */
  data: ScreenableTab,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableTab> {
  const result = await api.rest.renameScreenTab({
    screenId: screenId,
    tabId: tabId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all screen tab fields
 * @request GET :/rest/api/3/screens/{screenId}/tabs/{tabId}/fields
 * @readonly
 */
export async function getRestGetAllScreenTabFields(
  query: {
    /**
     * The key of the project.
     */
    projectKey?: string;
  },
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableField[]> {
  const result = await api.rest.getAllScreenTabFields({
    query: query,
    screenId: screenId,
    tabId: tabId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Add screen tab field
 * @request POST :/rest/api/3/screens/{screenId}/tabs/{tabId}/fields
 */
export async function postRestAddScreenTabField(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  /** Request body */
  data: AddFieldBean,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenableField> {
  const result = await api.rest.addScreenTabField({
    screenId: screenId,
    tabId: tabId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Remove screen tab field
 * @request DELETE :/rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveScreenTabField(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  /**
   * The ID of the field.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeScreenTabField({
    screenId: screenId,
    tabId: tabId,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Move screen tab field
 * @request POST :/rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}/move
 * @allowrelaxedtypes
 */
export async function postRestMoveScreenTabField(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  /**
   * The ID of the field.
   */
  id: string,
  /** Request body */
  data: MoveFieldBean,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.moveScreenTabField({
    screenId: screenId,
    tabId: tabId,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Move screen tab
 * @request POST :/rest/api/3/screens/{screenId}/tabs/{tabId}/move/{pos}
 * @allowrelaxedtypes
 */
export async function postRestMoveScreenTab(
  /**
   * The ID of the screen.
   */
  screenId: number,
  /**
   * The ID of the screen tab.
   */
  tabId: number,
  /**
   * The position of tab. The base index is 0.
   */
  pos: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.moveScreenTab({
    screenId: screenId,
    tabId: tabId,
    pos: pos,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get screen schemes
 * @request GET :/rest/api/3/screenscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetScreenSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The list of screen scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     */
    id?: number[];
    /**
     * Use [expand](#expansion) include additional information in the response. This parameter accepts `issueTypeScreenSchemes` that, for each screen schemes, returns information about the issue type screen scheme the screen scheme is assigned to.
     */
    expand?: string;
    /**
     * String used to perform a case-insensitive partial match with screen scheme name.
     */
    queryString?: string;
    /**
* [Order](#ordering) the results by a field:

 *  `id` Sorts by screen scheme ID.
 *  `name` Sorts by screen scheme name.
*/
    orderBy?: "name" | "-name" | "+name" | "id" | "-id" | "+id";
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanScreenScheme> {
  const result = await api.rest.getScreenSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create screen scheme
 * @request POST :/rest/api/3/screenscheme
 */
export async function postRestCreateScreenScheme(
  /** Request body */
  data: ScreenSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<ScreenSchemeId> {
  const result = await api.rest.createScreenScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete screen scheme
 * @request DELETE :/rest/api/3/screenscheme/{screenSchemeId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteScreenScheme(
  /**
   * The ID of the screen scheme.
   */
  screenSchemeId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteScreenScheme({
    screenSchemeId: screenSchemeId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Update screen scheme
 * @request PUT :/rest/api/3/screenscheme/{screenSchemeId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateScreenScheme(
  /**
   * The ID of the screen scheme.
   */
  screenSchemeId: string,
  /** Request body */
  data: UpdateScreenSchemeDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateScreenScheme({
    screenSchemeId: screenSchemeId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Search for issues using JQL (GET)
 * @request GET :/rest/api/3/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestSearchForIssuesUsingJql(
  query: {
    /**
* The [JQL](https://confluence.atlassian.com/x/egORLQ) that defines the search. Note:

 *  If no JQL expression is provided, all issues are returned.
 *  `username` and `userkey` cannot be used as search terms due to privacy reasons. Use `accountId` instead.
 *  If a user has hidden their email address in their user profile, partial matches of the email address will not find the user. An exact match is required.
*/
    jql?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page. To manage page size, Jira may return fewer items per page where a large number of fields are requested. The greatest number of items returned per page is achieved when requesting `id` or `key` only.
     */
    maxResults?: number;
    /**
* Determines how to validate the JQL query and treat the validation results. Supported values are:

 *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
 *  `warn` Returns all errors as warnings.
 *  `none` No validation is performed.
 *  `true` *Deprecated* A legacy synonym for `strict`.
 *  `false` *Deprecated* A legacy synonym for `warn`.

Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value.
*/
    validateQuery?: "strict" | "warn" | "none" | "true" | "false";
    /**
* A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

Examples:

 *  `summary,comment` Returns only the summary and comments fields.
 *  `-description` Returns all navigable (default) fields except description.
 *  `*all,-comment` Returns all fields except comments.

This parameter may be specified multiple times. For example, `fields=field1,field2&fields=field3`.

Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
*/
    fields?: string[];
    /**
* Use [expand](#expansion) to include additional information about issues in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.
*/
    expand?: string;
    /**
     * A list of issue property keys for issue properties to include in the results. This parameter accepts a comma-separated list. Multiple properties can also be provided using an ampersand separated list. For example, `properties=prop1,prop2&properties=prop3`. A maximum of 5 issue property keys can be specified.
     */
    properties?: string[];
    /**
     * Reference fields by their key (rather than ID).
     */
    fieldsByKeys?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<SearchResults> {
  const result = await api.rest.searchForIssuesUsingJql({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Search for issues using JQL (POST)
 * @request POST :/rest/api/3/search
 * @allowrelaxedtypes
 */
export async function postRestSearchForIssuesUsingJqlPost(
  /** Request body */
  data: SearchRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<SearchResults> {
  const result = await api.rest.searchForIssuesUsingJqlPost({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue security level
 * @request GET :/rest/api/3/securitylevel/{id}
 * @readonly
 */
export async function getRestGetIssueSecurityLevel(
  /**
   * The ID of the issue security level.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<SecurityLevel> {
  const result = await api.rest.getIssueSecurityLevel({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get Jira instance info
 * @request GET :/rest/api/3/serverInfo
 * @readonly
 */
export async function getRestGetServerInfo(
  headers?: hasuraSdk.JSONValue,
): Promise<ServerInformation> {
  const result = await api.rest.getServerInfo({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get issue navigator default columns
 * @request GET :/rest/api/3/settings/columns
 * @readonly
 */
export async function getRestGetIssueNavigatorDefaultColumns(
  headers?: hasuraSdk.JSONValue,
): Promise<ColumnItem[]> {
  const result = await api.rest.getIssueNavigatorDefaultColumns({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set issue navigator default columns
 * @request PUT :/rest/api/3/settings/columns
 * @allowrelaxedtypes
 */
export async function putRestSetIssueNavigatorDefaultColumns(
  /** Request body */
  data: string[],
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setIssueNavigatorDefaultColumns({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get all statuses
 * @request GET :/rest/api/3/status
 * @readonly
 */
export async function getRestGetStatuses(
  headers?: hasuraSdk.JSONValue,
): Promise<StatusDetails[]> {
  const result = await api.rest.getStatuses({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get status
 * @request GET :/rest/api/3/status/{idOrName}
 * @readonly
 */
export async function getRestGetStatus(
  /**
   * The ID or name of the status.
   */
  idOrName: string,
  headers?: hasuraSdk.JSONValue,
): Promise<StatusDetails> {
  const result = await api.rest.getStatus({
    idOrName: idOrName,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all status categories
 * @request GET :/rest/api/3/statuscategory
 * @readonly
 */
export async function getRestGetStatusCategories(
  headers?: hasuraSdk.JSONValue,
): Promise<StatusCategory[]> {
  const result = await api.rest.getStatusCategories({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get status category
 * @request GET :/rest/api/3/statuscategory/{idOrKey}
 * @readonly
 */
export async function getRestGetStatusCategory(
  /**
   * The ID or key of the status category.
   */
  idOrKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<StatusCategory> {
  const result = await api.rest.getStatusCategory({
    idOrKey: idOrKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk delete Statuses
 * @request DELETE :/rest/api/3/statuses
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteStatusesById(
  query: {
    /**
* The list of status IDs. To include multiple IDs, provide an ampersand-separated list. For example, id=10000&id=10001.

Min items `1`, Max items `50`
*/
    id?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteStatusesById({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Bulk get statuses
 * @request GET :/rest/api/3/statuses
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetStatusesById(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `usages` Returns the project and issue types that use the status in their workflow.
*/
    expand?: string;
    /**
* The list of status IDs. To include multiple IDs, provide an ampersand-separated list. For example, id=10000&id=10001.

Min items `1`, Max items `50`
*/
    id?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<JiraStatus[]> {
  const result = await api.rest.getStatusesById({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk create statuses
 * @request POST :/rest/api/3/statuses
 * @allowrelaxedtypes
 */
export async function postRestCreateStatuses(
  /** Request body */
  data: StatusCreateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<JiraStatus[]> {
  const result = await api.rest.createStatuses({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk update statuses
 * @request PUT :/rest/api/3/statuses
 * @allowrelaxedtypes
 */
export async function putRestUpdateStatuses(
  /** Request body */
  data: StatusUpdateRequest,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateStatuses({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Search statuses paginated
 * @request GET :/rest/api/3/statuses/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestSearch(
  query: {
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `usages` Returns the project and issue types that use the status in their workflow.
*/
    expand?: string;
    /**
     * The project the status is part of or null for global statuses.
     */
    projectId?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * Term to match status names against or null to search for all statuses in the search scope.
     */
    searchString?: string;
    /**
     * Category of the status to filter by. The supported values are: `TODO`, `IN_PROGRESS`, and `DONE`.
     */
    statusCategory?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageOfStatuses> {
  const result = await api.rest.search({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get task
 * @request GET :/rest/api/3/task/{taskId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetTask(
  /**
   * The ID of the task.
   */
  taskId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<TaskProgressBeanObject> {
  const result = await api.rest.getTask({
    taskId: taskId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Cancel task
 * @request POST :/rest/api/3/task/{taskId}/cancel
 * @allowrelaxedtypes
 */
export async function postRestCancelTask(
  /**
   * The ID of the task.
   */
  taskId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.cancelTask({
    taskId: taskId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get UI modifications
 * @request GET :/rest/api/3/uiModifications
 * @readonly
 */
export async function getRestGetUiModifications(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
* Use expand to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `data` Returns UI modification data.
 *  `contexts` Returns UI modification contexts.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanUiModificationDetails> {
  const result = await api.rest.getUiModifications({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create UI modification
 * @request POST :/rest/api/3/uiModifications
 */
export async function postRestCreateUiModification(
  /** Request body */
  data: CreateUiModificationDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<UiModificationIdentifiers> {
  const result = await api.rest.createUiModification({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete UI modification
 * @request DELETE :/rest/api/3/uiModifications/{uiModificationId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteUiModification(
  /**
   * The ID of the UI modification.
   */
  uiModificationId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteUiModification({
    uiModificationId: uiModificationId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Update UI modification
 * @request PUT :/rest/api/3/uiModifications/{uiModificationId}
 * @allowrelaxedtypes
 */
export async function putRestUpdateUiModification(
  /**
   * The ID of the UI modification.
   */
  uiModificationId: string,
  /** Request body */
  data: UpdateUiModificationDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.updateUiModification({
    uiModificationId: uiModificationId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get avatars
 * @request GET :/rest/api/3/universal_avatar/type/{type}/owner/{entityId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAvatars(
  /**
   * The avatar type.
   */
  type: "project" | "issuetype",
  /**
   * The ID of the item the avatar is associated with.
   */
  entityId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Avatars> {
  const result = await api.rest.getAvatars({
    type: type,
    entityId: entityId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Load avatar
 * @request POST :/rest/api/3/universal_avatar/type/{type}/owner/{entityId}
 * @allowrelaxedtypes
 */
export async function postRestStoreAvatar(
  query: {
    /**
     * The X coordinate of the top-left corner of the crop region.
     */
    x?: number;
    /**
     * The Y coordinate of the top-left corner of the crop region.
     */
    y?: number;
    /**
     * The length of each side of the crop region.
     */
    size: number;
  },
  /**
   * The avatar type.
   */
  type: "project" | "issuetype",
  /**
   * The ID of the item the avatar is associated with.
   */
  entityId: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<Avatar> {
  const result = await api.rest.storeAvatar({
    query: query,
    type: type,
    entityId: entityId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete avatar
 * @request DELETE :/rest/api/3/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteAvatar(
  /**
   * The avatar type.
   */
  type: "project" | "issuetype",
  /**
   * The ID of the item the avatar is associated with.
   */
  owningObjectId: string,
  /**
   * The ID of the avatar.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteAvatar({
    type: type,
    owningObjectId: owningObjectId,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get avatar image by type
 * @request GET :/rest/api/3/universal_avatar/view/type/{type}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAvatarImageByType(
  query: {
    /**
     * The size of the avatar image. If not provided the default size is returned.
     */
    size?: "xsmall" | "small" | "medium" | "large" | "xlarge";
    /**
     * The format to return the avatar image in. If not provided the original content format is returned.
     */
    format?: "png" | "svg";
  },
  /**
   * The icon type of the avatar.
   */
  type: "issuetype" | "project",
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModule> {
  const result = await api.rest.getAvatarImageByType({
    query: query,
    type: type,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get avatar image by ID
 * @request GET :/rest/api/3/universal_avatar/view/type/{type}/avatar/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAvatarImageById(
  query: {
    /**
     * The size of the avatar image. If not provided the default size is returned.
     */
    size?: "xsmall" | "small" | "medium" | "large" | "xlarge";
    /**
     * The format to return the avatar image in. If not provided the original content format is returned.
     */
    format?: "png" | "svg";
  },
  /**
   * The icon type of the avatar.
   */
  type: "issuetype" | "project",
  /**
   * The ID of the avatar.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModule> {
  const result = await api.rest.getAvatarImageById({
    query: query,
    type: type,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get avatar image by owner
 * @request GET :/rest/api/3/universal_avatar/view/type/{type}/owner/{entityId}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAvatarImageByOwner(
  query: {
    /**
     * The size of the avatar image. If not provided the default size is returned.
     */
    size?: "xsmall" | "small" | "medium" | "large" | "xlarge";
    /**
     * The format to return the avatar image in. If not provided the original content format is returned.
     */
    format?: "png" | "svg";
  },
  /**
   * The icon type of the avatar.
   */
  type: "issuetype" | "project",
  /**
   * The ID of the project or issue type the avatar belongs to.
   */
  entityId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModule> {
  const result = await api.rest.getAvatarImageByOwner({
    query: query,
    type: type,
    entityId: entityId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete user
 * @request DELETE :/rest/api/3/user
 * @allowrelaxedtypes
 */
export async function deleteRestRemoveUser(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    key?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.removeUser({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get user
 * @request GET :/rest/api/3/user
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetUser(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required.
     */
    accountId?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide) for details.
     */
    username?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide) for details.
     */
    key?: string;
    /**
* Use [expand](#expansion) to include additional information about users in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `groups` includes all groups and nested groups to which the user belongs.
 *  `applicationRoles` includes details of all the applications to which the user has access.
*/
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User> {
  const result = await api.rest.getUser({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create user
 * @request POST :/rest/api/3/user
 * @allowrelaxedtypes
 */
export async function postRestCreateUser(
  /** Request body */
  data: NewUserDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<User> {
  const result = await api.rest.createUser({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users assignable to projects
 * @request GET :/rest/api/3/user/assignable/multiProjectSearch
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindBulkAssignableUsers(
  query: {
    /**
     * A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     */
    query?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     */
    accountId?: string;
    /**
     * A list of project keys (case sensitive). This parameter accepts a comma-separated list.
     */
    projectKeys: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.findBulkAssignableUsers({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users assignable to issues
 * @request GET :/rest/api/3/user/assignable/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindAssignableUsers(
  query: {
    /**
     * A query string that is matched against user attributes, such as `displayName`, and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `username` or `accountId` is specified.
     */
    query?: string;
    /**
     * The sessionId of this request. SessionId is the same until the assignee is set.
     */
    sessionId?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     */
    accountId?: string;
    /**
     * The project ID or project key (case sensitive). Required, unless `issueKey` is specified.
     */
    project?: string;
    /**
     * The key of the issue. Required, unless `project` is specified.
     */
    issueKey?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return. This operation may return less than the maximum number of items even if more are available. The operation fetches users up to the maximum and then, from the fetched users, returns only the users that can be assigned to the issue.
     */
    maxResults?: number;
    /**
     * The ID of the transition.
     */
    actionDescriptorId?: number;
    recommend?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.findAssignableUsers({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Bulk get users
 * @request GET :/rest/api/3/user/bulk
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestBulkGetUsers(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string[];
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    key?: string[];
    /**
     * The account ID of a user. To specify multiple users, pass multiple `accountId` parameters. For example, `accountId=5b10a2844c20165700ede21g&accountId=5b10ac8d82e05b22cc7d4ef5`.
     */
    accountId: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanUser> {
  const result = await api.rest.bulkGetUsers({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get account IDs for users
 * @request GET :/rest/api/3/user/bulk/migration
 * @readonly
 */
export async function getRestBulkGetUsersMigration(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * Username of a user. To specify multiple users, pass multiple copies of this parameter. For example, `username=fred&username=barney`. Required if `key` isn't provided. Cannot be provided if `key` is present.
     */
    username?: string[];
    /**
     * Key of a user. To specify multiple users, pass multiple copies of this parameter. For example, `key=fred&key=barney`. Required if `username` isn't provided. Cannot be provided if `username` is present.
     */
    key?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UserMigrationBean[]> {
  const result = await api.rest.bulkGetUsersMigration({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Reset user default columns
 * @request DELETE :/rest/api/3/user/columns
 * @allowrelaxedtypes
 */
export async function deleteRestResetUserColumns(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.resetUserColumns({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get user default columns
 * @request GET :/rest/api/3/user/columns
 * @readonly
 */
export async function getRestGetUserDefaultColumns(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ColumnItem[]> {
  const result = await api.rest.getUserDefaultColumns({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set user default columns
 * @request PUT :/rest/api/3/user/columns
 * @allowrelaxedtypes
 */
export async function putRestSetUserColumns(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
  },
  /** Request body */
  data: string[],
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setUserColumns({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get user email
 * @request GET :/rest/api/3/user/email
 * @readonly
 */
export async function getRestGetUserEmail(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, `5b10ac8d82e05b22cc7d4ef5`.
     */
    accountId: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UnrestrictedUserEmail> {
  const result = await api.rest.getUserEmail({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get user email bulk
 * @request GET :/rest/api/3/user/email/bulk
 * @readonly
 */
export async function getRestGetUserEmailBulk(
  query: {
    /**
     * The account IDs of the users for which emails are required. An `accountId` is an identifier that uniquely identifies the user across all Atlassian products. For example, `5b10ac8d82e05b22cc7d4ef5`. Note, this should be treated as an opaque identifier (that is, do not assume any structure in the value).
     */
    accountId: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<UnrestrictedUserEmail> {
  const result = await api.rest.getUserEmailBulk({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get user groups
 * @request GET :/rest/api/3/user/groups
 * @readonly
 */
export async function getRestGetUserGroups(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    key?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<GroupName[]> {
  const result = await api.rest.getUserGroups({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users with permissions
 * @request GET :/rest/api/3/user/permission/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindUsersWithAllPermissions(
  query: {
    /**
     * A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     */
    query?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     */
    accountId?: string;
    /**
* A comma separated list of permissions. Permissions can be specified as any:

 *  permission returned by [Get all permissions](#api-rest-api-3-permissions-get).
 *  custom project permission added by Connect apps.
 *  (deprecated) one of the following:
    
     *  ASSIGNABLE\_USER
     *  ASSIGN\_ISSUE
     *  ATTACHMENT\_DELETE\_ALL
     *  ATTACHMENT\_DELETE\_OWN
     *  BROWSE
     *  CLOSE\_ISSUE
     *  COMMENT\_DELETE\_ALL
     *  COMMENT\_DELETE\_OWN
     *  COMMENT\_EDIT\_ALL
     *  COMMENT\_EDIT\_OWN
     *  COMMENT\_ISSUE
     *  CREATE\_ATTACHMENT
     *  CREATE\_ISSUE
     *  DELETE\_ISSUE
     *  EDIT\_ISSUE
     *  LINK\_ISSUE
     *  MANAGE\_WATCHER\_LIST
     *  MODIFY\_REPORTER
     *  MOVE\_ISSUE
     *  PROJECT\_ADMIN
     *  RESOLVE\_ISSUE
     *  SCHEDULE\_ISSUE
     *  SET\_ISSUE\_SECURITY
     *  TRANSITION\_ISSUE
     *  VIEW\_VERSION\_CONTROL
     *  VIEW\_VOTERS\_AND\_WATCHERS
     *  VIEW\_WORKFLOW\_READONLY
     *  WORKLOG\_DELETE\_ALL
     *  WORKLOG\_DELETE\_OWN
     *  WORKLOG\_EDIT\_ALL
     *  WORKLOG\_EDIT\_OWN
     *  WORK\_ISSUE
*/
    permissions: string;
    /**
     * The issue key for the issue.
     */
    issueKey?: string;
    /**
     * The project key for the project (case sensitive).
     */
    projectKey?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.findUsersWithAllPermissions({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users for picker
 * @request GET :/rest/api/3/user/picker
 * @readonly
 */
export async function getRestFindUsersForPicker(
  query: {
    /**
     * A query string that is matched against user attributes, such as `displayName`, and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*.
     */
    query: string;
    /**
     * The maximum number of items to return. The total number of matched users is returned in `total`.
     */
    maxResults?: number;
    /**
     * Include the URI to the user's avatar.
     */
    showAvatar?: boolean;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    exclude?: string[];
    /**
     * A list of account IDs to exclude from the search results. This parameter accepts a comma-separated list. Multiple account IDs can also be provided using an ampersand-separated list. For example, `excludeAccountIds=5b10a2844c20165700ede21g,5b10a0effa615349cb016cd8&excludeAccountIds=5b10ac8d82e05b22cc7d4ef5`. Cannot be provided with `exclude`.
     */
    excludeAccountIds?: string[];
    avatarSize?: string;
    excludeConnectUsers?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<FoundUsers> {
  const result = await api.rest.findUsersForPicker({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get user property keys
 * @request GET :/rest/api/3/user/properties
 * @readonly
 */
export async function getRestGetUserPropertyKeys(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    userKey?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.getUserPropertyKeys({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete user property
 * @request DELETE :/rest/api/3/user/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteUserProperty(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    userKey?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  /**
   * The key of the user's property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteUserProperty({
    query: query,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get user property
 * @request GET :/rest/api/3/user/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetUserProperty(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    userKey?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  /**
   * The key of the user's property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.getUserProperty({
    query: query,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set user property
 * @request PUT :/rest/api/3/user/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function putRestSetUserProperty(
  query: {
    /**
     * The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     */
    accountId?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    userKey?: string;
    /**
     * This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
  },
  /**
   * The key of the user's property. The maximum length is 255 characters.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.setUserProperty({
    query: query,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Find users
 * @request GET :/rest/api/3/user/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindUsers(
  query: {
    /**
     * A query string that is matched against user attributes ( `displayName`, and `emailAddress`) to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` or `property` is specified.
     */
    query?: string;
    username?: string;
    /**
     * A query string that is matched exactly against a user `accountId`. Required, unless `query` or `property` is specified.
     */
    accountId?: string;
    /**
     * The index of the first item to return in a page of filtered results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * A query string used to search properties. Property keys are specified by path, so property keys containing dot (.) or equals (=) characters cannot be used. The query string cannot be specified using a JSON object. Example: To search for the value of `nested` from `{"something":{"nested":1,"other":2}}` use `thepropertykey.something.nested=1`. Required, unless `accountId` or `query` is specified.
     */
    property?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.findUsers({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users by query
 * @request GET :/rest/api/3/user/search/query
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindUsersByQuery(
  query: {
    /**
     * The search query.
     */
    query: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanUser> {
  const result = await api.rest.findUsersByQuery({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find user keys by query
 * @request GET :/rest/api/3/user/search/query/key
 * @readonly
 */
export async function getRestFindUserKeysByQuery(
  query: {
    /**
     * The search query.
     */
    query: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanUserKey> {
  const result = await api.rest.findUserKeysByQuery({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Find users with browse permission
 * @request GET :/rest/api/3/user/viewissue/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestFindUsersWithBrowsePermission(
  query: {
    /**
     * A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     */
    query?: string;
    /**
     * This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     */
    username?: string;
    /**
     * A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     */
    accountId?: string;
    /**
     * The issue key for the issue. Required, unless `projectKey` is specified.
     */
    issueKey?: string;
    /**
     * The project key for the project (case sensitive). Required, unless `issueKey` is specified.
     */
    projectKey?: string;
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.findUsersWithBrowsePermission({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all users default
 * @request GET :/rest/api/3/users
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllUsersDefault(
  query: {
    /**
     * The index of the first item to return.
     */
    startAt?: number;
    /**
     * The maximum number of items to return.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.getAllUsersDefault({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all users
 * @request GET :/rest/api/3/users/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllUsers(
  query: {
    /**
     * The index of the first item to return.
     */
    startAt?: number;
    /**
     * The maximum number of items to return.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<User[]> {
  const result = await api.rest.getAllUsers({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create version
 * @request POST :/rest/api/3/version
 */
export async function postRestCreateVersion(
  /** Request body */
  data: Version,
  headers?: hasuraSdk.JSONValue,
): Promise<Version> {
  const result = await api.rest.createVersion({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete version
 * @request DELETE :/rest/api/3/version/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteVersion(
  query: {
    /**
     * The ID of the version to update `fixVersion` to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.
     */
    moveFixIssuesTo?: string;
    /**
     * The ID of the version to update `affectedVersion` to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.
     */
    moveAffectedIssuesTo?: string;
  },
  /**
   * The ID of the version.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteVersion({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get version
 * @request GET :/rest/api/3/version/{id}
 * @readonly
 */
export async function getRestGetVersion(
  query: {
    /**
* Use [expand](#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `operations` Returns the list of operations available for this version.
 *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property represents the number of issues with a status other than *to do*, *in progress*, and *done*.
*/
    expand?: string;
  },
  /**
   * The ID of the version.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<Version> {
  const result = await api.rest.getVersion({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update version
 * @request PUT :/rest/api/3/version/{id}
 */
export async function putRestUpdateVersion(
  /**
   * The ID of the version.
   */
  id: string,
  /** Request body */
  data: Version,
  headers?: hasuraSdk.JSONValue,
): Promise<Version> {
  const result = await api.rest.updateVersion({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Merge versions
 * @request PUT :/rest/api/3/version/{id}/mergeto/{moveIssuesTo}
 * @allowrelaxedtypes
 */
export async function putRestMergeVersions(
  /**
   * The ID of the version to delete.
   */
  id: string,
  /**
   * The ID of the version to merge into.
   */
  moveIssuesTo: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.mergeVersions({
    id: id,
    moveIssuesTo: moveIssuesTo,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Move version
 * @request POST :/rest/api/3/version/{id}/move
 * @allowrelaxedtypes
 */
export async function postRestMoveVersion(
  /**
   * The ID of the version to be moved.
   */
  id: string,
  /** Request body */
  data: VersionMoveBean,
  headers?: hasuraSdk.JSONValue,
): Promise<Version> {
  const result = await api.rest.moveVersion({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get version's related issues count
 * @request GET :/rest/api/3/version/{id}/relatedIssueCounts
 * @readonly
 */
export async function getRestGetVersionRelatedIssues(
  /**
   * The ID of the version.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<VersionIssueCounts> {
  const result = await api.rest.getVersionRelatedIssues({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete and replace version
 * @request POST :/rest/api/3/version/{id}/removeAndSwap
 * @allowrelaxedtypes
 */
export async function postRestDeleteAndReplaceVersion(
  /**
   * The ID of the version.
   */
  id: string,
  /** Request body */
  data: DeleteAndReplaceVersionBean,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteAndReplaceVersion({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get version's unresolved issues count
 * @request GET :/rest/api/3/version/{id}/unresolvedIssueCount
 * @readonly
 */
export async function getRestGetVersionUnresolvedIssues(
  /**
   * The ID of the version.
   */
  id: string,
  headers?: hasuraSdk.JSONValue,
): Promise<VersionUnresolvedIssuesCount> {
  const result = await api.rest.getVersionUnresolvedIssues({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete webhooks by ID
 * @request DELETE :/rest/api/3/webhook
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWebhookById(
  /** Request body */
  data: ContainerForWebhookIDs,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWebhookById({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get dynamic webhooks for app
 * @request GET :/rest/api/3/webhook
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetDynamicWebhooksForApp(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanWebhook> {
  const result = await api.rest.getDynamicWebhooksForApp({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Register dynamic webhooks
 * @request POST :/rest/api/3/webhook
 * @allowrelaxedtypes
 */
export async function postRestRegisterDynamicWebhooks(
  /** Request body */
  data: WebhookRegistrationDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<ContainerForRegisteredWebhooks> {
  const result = await api.rest.registerDynamicWebhooks({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get failed webhooks
 * @request GET :/rest/api/3/webhook/failed
 * @readonly
 */
export async function getRestGetFailedWebhooks(
  query: {
    /**
     * The maximum number of webhooks to return per page. If obeying the maxResults directive would result in records with the same failure time being split across pages, the directive is ignored and all records with the same failure time included on the page.
     */
    maxResults?: number;
    /**
     * The time after which any webhook failure must have occurred for the record to be returned, expressed as milliseconds since the UNIX epoch.
     */
    after?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<FailedWebhooks> {
  const result = await api.rest.getFailedWebhooks({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Extend webhook life
 * @request PUT :/rest/api/3/webhook/refresh
 */
export async function putRestRefreshWebhooks(
  /** Request body */
  data: ContainerForWebhookIDs,
  headers?: hasuraSdk.JSONValue,
): Promise<WebhooksExpirationDate> {
  const result = await api.rest.refreshWebhooks({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get all workflows
 * @request GET :/rest/api/3/workflow
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllWorkflows(
  query: {
    /**
     * The name of the workflow to be returned. Only one workflow can be specified.
     */
    workflowName?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<DeprecatedWorkflow[]> {
  const result = await api.rest.getAllWorkflows({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create workflow
 * @request POST :/rest/api/3/workflow
 * @allowrelaxedtypes
 */
export async function postRestCreateWorkflow(
  /** Request body */
  data: CreateWorkflowDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowIDs> {
  const result = await api.rest.createWorkflow({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get workflow transition rule configurations
 * @request GET :/rest/api/3/workflow/rule/config
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowTransitionRuleConfigurations(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The types of the transition rules to return.
     */
    types: ("postfunction" | "condition" | "validator")[];
    /**
     * The transition rule class keys, as defined in the Connect app descriptor, of the transition rules to return.
     */
    keys?: string[];
    /**
     * EXPERIMENTAL: The list of workflow names to filter by.
     */
    workflowNames?: string[];
    /**
     * EXPERIMENTAL: The list of `tags` to filter by.
     */
    withTags?: string[];
    /**
     * EXPERIMENTAL: Whether draft or published workflows are returned. If not provided, both workflow types are returned.
     */
    draft?: boolean;
    /**
     * Use [expand](#expansion) to include additional information in the response. This parameter accepts `transition`, which, for each rule, returns information about the transition the rule is assigned to.
     */
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanWorkflowTransitionRules> {
  const result = await api.rest.getWorkflowTransitionRuleConfigurations({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update workflow transition rule configurations
 * @request PUT :/rest/api/3/workflow/rule/config
 */
export async function putRestUpdateWorkflowTransitionRuleConfigurations(
  /** Request body */
  data: WorkflowTransitionRulesUpdate,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowTransitionRulesUpdateErrors> {
  const result = await api.rest.updateWorkflowTransitionRuleConfigurations({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete workflow transition rule configurations
 * @request PUT :/rest/api/3/workflow/rule/config/delete
 */
export async function putRestDeleteWorkflowTransitionRuleConfigurations(
  /** Request body */
  data: WorkflowsWithTransitionRulesDetails,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowTransitionRulesUpdateErrors> {
  const result = await api.rest.deleteWorkflowTransitionRuleConfigurations({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get workflows paginated
 * @request GET :/rest/api/3/workflow/search
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowsPaginated(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
    /**
     * The name of a workflow to return. To include multiple workflows, provide an ampersand-separated list. For example, `workflowName=name1&workflowName=name2`.
     */
    workflowName?: string[];
    /**
* Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `transitions` For each workflow, returns information about the transitions inside the workflow.
 *  `transitions.rules` For each workflow transition, returns information about its rules. Transitions are included automatically if this expand is requested.
 *  `transitions.properties` For each workflow transition, returns information about its properties. Transitions are included automatically if this expand is requested.
 *  `statuses` For each workflow, returns information about the statuses inside the workflow.
 *  `statuses.properties` For each workflow status, returns information about its properties. Statuses are included automatically if this expand is requested.
 *  `default` For each workflow, returns information about whether this is the default workflow.
 *  `schemes` For each workflow, returns information about the workflow schemes the workflow is assigned to.
 *  `projects` For each workflow, returns information about the projects the workflow is assigned to, through workflow schemes.
 *  `hasDraftWorkflow` For each workflow, returns information about whether the workflow has a draft version.
 *  `operations` For each workflow, returns information about the actions that can be undertaken on the workflow.
*/
    expand?: string;
    /**
     * String used to perform a case-insensitive partial match with workflow name.
     */
    queryString?: string;
    /**
* [Order](#ordering) the results by a field:

 *  `name` Sorts by workflow name.
 *  `created` Sorts by create time.
 *  `updated` Sorts by update time.
*/
    orderBy?:
      | "name"
      | "-name"
      | "+name"
      | "created"
      | "-created"
      | "+created"
      | "updated"
      | "+updated"
      | "-updated";
    /**
     * Filters active and inactive workflows.
     */
    isActive?: boolean;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanWorkflow> {
  const result = await api.rest.getWorkflowsPaginated({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete workflow transition property
 * @request DELETE :/rest/api/3/workflow/transitions/{transitionId}/properties
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowTransitionProperty(
  query: {
    /**
     * The name of the transition property to delete, also known as the name of the property.
     */
    key: string;
    /**
     * The name of the workflow that the transition belongs to.
     */
    workflowName: string;
    /**
     * The workflow status. Set to `live` for inactive workflows or `draft` for draft workflows. Active workflows cannot be edited.
     */
    workflowMode?: "live" | "draft";
  },
  /**
   * The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
   */
  transitionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorkflowTransitionProperty({
    query: query,
    transitionId: transitionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get workflow transition properties
 * @request GET :/rest/api/3/workflow/transitions/{transitionId}/properties
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowTransitionProperties(
  query: {
    /**
     * Some properties with keys that have the *jira.* prefix are reserved, which means they are not editable. To include these properties in the results, set this parameter to *true*.
     */
    includeReservedKeys?: boolean;
    /**
     * The key of the property being returned, also known as the name of the property. If this parameter is not specified, all properties on the transition are returned.
     */
    key?: string;
    /**
     * The name of the workflow that the transition belongs to.
     */
    workflowName: string;
    /**
     * The workflow status. Set to *live* for active and inactive workflows, or *draft* for draft workflows.
     */
    workflowMode?: "live" | "draft";
  },
  /**
   * The ID of the transition. To get the ID, view the workflow in text mode in the Jira administration console. The ID is shown next to the transition.
   */
  transitionId: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowTransitionProperty> {
  const result = await api.rest.getWorkflowTransitionProperties({
    query: query,
    transitionId: transitionId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create workflow transition property
 * @request POST :/rest/api/3/workflow/transitions/{transitionId}/properties
 * @allowrelaxedtypes
 */
export async function postRestCreateWorkflowTransitionProperty(
  query: {
    /**
     * The key of the property being added, also known as the name of the property. Set this to the same value as the `key` defined in the request body.
     */
    key: string;
    /**
     * The name of the workflow that the transition belongs to.
     */
    workflowName: string;
    /**
     * The workflow status. Set to *live* for inactive workflows or *draft* for draft workflows. Active workflows cannot be edited.
     */
    workflowMode?: "live" | "draft";
  },
  /**
   * The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
   */
  transitionId: number,
  /** Request body */
  data: WorkflowTransitionProperty,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowTransitionProperty> {
  const result = await api.rest.createWorkflowTransitionProperty({
    query: query,
    transitionId: transitionId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update workflow transition property
 * @request PUT :/rest/api/3/workflow/transitions/{transitionId}/properties
 * @allowrelaxedtypes
 */
export async function putRestUpdateWorkflowTransitionProperty(
  query: {
    /**
     * The key of the property being updated, also known as the name of the property. Set this to the same value as the `key` defined in the request body.
     */
    key: string;
    /**
     * The name of the workflow that the transition belongs to.
     */
    workflowName: string;
    /**
     * The workflow status. Set to `live` for inactive workflows or `draft` for draft workflows. Active workflows cannot be edited.
     */
    workflowMode?: "live" | "draft";
  },
  /**
   * The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
   */
  transitionId: number,
  /** Request body */
  data: WorkflowTransitionProperty,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowTransitionProperty> {
  const result = await api.rest.updateWorkflowTransitionProperty({
    query: query,
    transitionId: transitionId,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete inactive workflow
 * @request DELETE :/rest/api/3/workflow/{entityId}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteInactiveWorkflow(
  /**
   * The entity ID of the workflow.
   */
  entityId: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteInactiveWorkflow({
    entityId: entityId,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get all workflow schemes
 * @request GET :/rest/api/3/workflowscheme
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetAllWorkflowSchemes(
  query: {
    /**
     * The index of the first item to return in a page of results (page offset).
     */
    startAt?: number;
    /**
     * The maximum number of items to return per page.
     */
    maxResults?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<PageBeanWorkflowScheme> {
  const result = await api.rest.getAllWorkflowSchemes({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create workflow scheme
 * @request POST :/rest/api/3/workflowscheme
 * @allowrelaxedtypes
 */
export async function postRestCreateWorkflowScheme(
  /** Request body */
  data: WorkflowScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.createWorkflowScheme({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get workflow scheme project associations
 * @request GET :/rest/api/3/workflowscheme/project
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowSchemeProjectAssociations(
  query: {
    /**
     * The ID of a project to return the workflow schemes for. To include multiple projects, provide an ampersand-Jim: oneseparated list. For example, `projectId=10000&projectId=10001`.
     */
    projectId: number[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ContainerOfWorkflowSchemeAssociations> {
  const result = await api.rest.getWorkflowSchemeProjectAssociations({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Assign workflow scheme to project
 * @request PUT :/rest/api/3/workflowscheme/project
 * @allowrelaxedtypes
 */
export async function putRestAssignSchemeToProject(
  /** Request body */
  data: WorkflowSchemeProjectAssociation,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.assignSchemeToProject({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Delete workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowScheme(
  /**
   * The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorkflowScheme({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Get workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowScheme(
  query: {
    /**
     * Returns the workflow scheme's draft rather than scheme itself, if set to true. If the workflow scheme does not have a draft, then the workflow scheme is returned.
     */
    returnDraftIfExists?: boolean;
  },
  /**
   * The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.getWorkflowScheme({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}
 * @allowrelaxedtypes
 */
export async function putRestUpdateWorkflowScheme(
  /**
   * The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
   */
  id: number,
  /** Request body */
  data: WorkflowScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateWorkflowScheme({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Create draft workflow scheme
 * @request POST :/rest/api/3/workflowscheme/{id}/createdraft
 * @allowrelaxedtypes
 */
export async function postRestCreateWorkflowSchemeDraftFromParent(
  /**
   * The ID of the active workflow scheme that the draft is created from.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.createWorkflowSchemeDraftFromParent({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete default workflow
 * @request DELETE :/rest/api/3/workflowscheme/{id}/default
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteDefaultWorkflow(
  query: {
    /**
     * Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     */
    updateDraftIfNeeded?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.deleteDefaultWorkflow({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get default workflow
 * @request GET :/rest/api/3/workflowscheme/{id}/default
 * @readonly
 */
export async function getRestGetDefaultWorkflow(
  query: {
    /**
     * Set to `true` to return the default workflow for the workflow scheme's draft rather than scheme itself. If the workflow scheme does not have a draft, then the default workflow for the workflow scheme is returned.
     */
    returnDraftIfExists?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<DefaultWorkflow> {
  const result = await api.rest.getDefaultWorkflow({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update default workflow
 * @request PUT :/rest/api/3/workflowscheme/{id}/default
 * @allowrelaxedtypes
 */
export async function putRestUpdateDefaultWorkflow(
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  /** Request body */
  data: DefaultWorkflow,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateDefaultWorkflow({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete draft workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}/draft
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowSchemeDraft(
  /**
   * The ID of the active workflow scheme that the draft was created from.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorkflowSchemeDraft({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get draft workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}/draft
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetWorkflowSchemeDraft(
  /**
   * The ID of the active workflow scheme that the draft was created from.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.getWorkflowSchemeDraft({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update draft workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}/draft
 * @allowrelaxedtypes
 */
export async function putRestUpdateWorkflowSchemeDraft(
  /**
   * The ID of the active workflow scheme that the draft was created from.
   */
  id: number,
  /** Request body */
  data: WorkflowScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateWorkflowSchemeDraft({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete draft default workflow
 * @request DELETE :/rest/api/3/workflowscheme/{id}/draft/default
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteDraftDefaultWorkflow(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.deleteDraftDefaultWorkflow({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get draft default workflow
 * @request GET :/rest/api/3/workflowscheme/{id}/draft/default
 * @readonly
 */
export async function getRestGetDraftDefaultWorkflow(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<DefaultWorkflow> {
  const result = await api.rest.getDraftDefaultWorkflow({
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Update draft default workflow
 * @request PUT :/rest/api/3/workflowscheme/{id}/draft/default
 * @allowrelaxedtypes
 */
export async function putRestUpdateDraftDefaultWorkflow(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /** Request body */
  data: DefaultWorkflow,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateDraftDefaultWorkflow({
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete workflow for issue type in draft workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowSchemeDraftIssueType(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.deleteWorkflowSchemeDraftIssueType({
    id: id,
    issueType: issueType,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get workflow for issue type in draft workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}
 * @readonly
 */
export async function getRestGetWorkflowSchemeDraftIssueType(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeWorkflowMapping> {
  const result = await api.rest.getWorkflowSchemeDraftIssueType({
    id: id,
    issueType: issueType,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set workflow for issue type in draft workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}
 * @allowrelaxedtypes
 */
export async function putRestSetWorkflowSchemeDraftIssueType(
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  /** Request body */
  data: IssueTypeWorkflowMapping,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.setWorkflowSchemeDraftIssueType({
    id: id,
    issueType: issueType,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Publish draft workflow scheme
 * @request POST :/rest/api/3/workflowscheme/{id}/draft/publish
 * @allowrelaxedtypes
 */
export async function postRestPublishDraftWorkflowScheme(
  query: {
    /**
     * Whether the request only performs a validation.
     */
    validateOnly?: boolean;
  },
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /** Request body */
  data: PublishDraftWorkflowScheme,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.publishDraftWorkflowScheme({
    query: query,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Delete issue types for workflow in draft workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}/draft/workflow
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteDraftWorkflowMapping(
  query: {
    /**
     * The name of the workflow.
     */
    workflowName: string;
  },
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteDraftWorkflowMapping({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue types for workflows in draft workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}/draft/workflow
 * @readonly
 */
export async function getRestGetDraftWorkflow(
  query: {
    /**
     * The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.
     */
    workflowName?: string;
  },
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypesWorkflowMapping> {
  const result = await api.rest.getDraftWorkflow({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set issue types for workflow in workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}/draft/workflow
 * @allowrelaxedtypes
 */
export async function putRestUpdateDraftWorkflowMapping(
  query: {
    /**
     * The name of the workflow.
     */
    workflowName: string;
  },
  /**
   * The ID of the workflow scheme that the draft belongs to.
   */
  id: number,
  /** Request body */
  data: IssueTypesWorkflowMapping,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateDraftWorkflowMapping({
    query: query,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete workflow for issue type in workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}/issuetype/{issueType}
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowSchemeIssueType(
  query: {
    /**
     * Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     */
    updateDraftIfNeeded?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.deleteWorkflowSchemeIssueType({
    query: query,
    id: id,
    issueType: issueType,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get workflow for issue type in workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}/issuetype/{issueType}
 * @readonly
 */
export async function getRestGetWorkflowSchemeIssueType(
  query: {
    /**
     * Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.
     */
    returnDraftIfExists?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypeWorkflowMapping> {
  const result = await api.rest.getWorkflowSchemeIssueType({
    query: query,
    id: id,
    issueType: issueType,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set workflow for issue type in workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}/issuetype/{issueType}
 * @allowrelaxedtypes
 */
export async function putRestSetWorkflowSchemeIssueType(
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  /**
   * The ID of the issue type.
   */
  issueType: string,
  /** Request body */
  data: IssueTypeWorkflowMapping,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.setWorkflowSchemeIssueType({
    id: id,
    issueType: issueType,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete issue types for workflow in workflow scheme
 * @request DELETE :/rest/api/3/workflowscheme/{id}/workflow
 * @allowrelaxedtypes
 */
export async function deleteRestDeleteWorkflowMapping(
  query: {
    /**
     * The name of the workflow.
     */
    workflowName: string;
    /**
     * Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     */
    updateDraftIfNeeded?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.deleteWorkflowMapping({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get issue types for workflows in workflow scheme
 * @request GET :/rest/api/3/workflowscheme/{id}/workflow
 * @readonly
 */
export async function getRestGetWorkflow(
  query: {
    /**
     * The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.
     */
    workflowName?: string;
    /**
     * Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.
     */
    returnDraftIfExists?: boolean;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  headers?: hasuraSdk.JSONValue,
): Promise<IssueTypesWorkflowMapping> {
  const result = await api.rest.getWorkflow({
    query: query,
    id: id,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set issue types for workflow in workflow scheme
 * @request PUT :/rest/api/3/workflowscheme/{id}/workflow
 * @allowrelaxedtypes
 */
export async function putRestUpdateWorkflowMapping(
  query: {
    /**
     * The name of the workflow.
     */
    workflowName: string;
  },
  /**
   * The ID of the workflow scheme.
   */
  id: number,
  /** Request body */
  data: IssueTypesWorkflowMapping,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowScheme> {
  const result = await api.rest.updateWorkflowMapping({
    query: query,
    id: id,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get IDs of deleted worklogs
 * @request GET :/rest/api/3/worklog/deleted
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIdsOfWorklogsDeletedSince(
  query: {
    /**
     * The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned.
     */
    since?: number;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ChangedWorklogs> {
  const result = await api.rest.getIdsOfWorklogsDeletedSince({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get worklogs
 * @request POST :/rest/api/3/worklog/list
 * @allowrelaxedtypes
 */
export async function postRestGetWorklogsForIds(
  query: {
    /**
     * Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
     */
    expand?: string;
  },
  /** Request body */
  data: WorklogIdsRequestBean,
  headers?: hasuraSdk.JSONValue,
): Promise<Worklog[]> {
  const result = await api.rest.getWorklogsForIds({
    query: query,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get IDs of updated worklogs
 * @request GET :/rest/api/3/worklog/updated
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestGetIdsOfWorklogsModifiedSince(
  query: {
    /**
     * The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned.
     */
    since?: number;
    /**
     * Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
     */
    expand?: string;
  },
  headers?: hasuraSdk.JSONValue,
): Promise<ChangedWorklogs> {
  const result = await api.rest.getIdsOfWorklogsModifiedSince({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Get app properties
 * @request GET :/rest/atlassian-connect/1/addons/{addonKey}/properties
 * @readonly
 */
export async function getRestAddonPropertiesResourceGetAddonPropertiesGet(
  /**
   * The key of the app, as defined in its descriptor.
   */
  addonKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<PropertyKeys> {
  const result = await api.rest.addonPropertiesResourceGetAddonPropertiesGet({
    addonKey: addonKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Delete app property
 * @request DELETE :/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 */
export async function deleteRestAddonPropertiesResourceDeleteAddonPropertyDelete(
  /**
   * The key of the app, as defined in its descriptor.
   */
  addonKey: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.rest.addonPropertiesResourceDeleteAddonPropertyDelete({
      addonKey: addonKey,
      propertyKey: propertyKey,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get app property
 * @request GET :/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestAddonPropertiesResourceGetAddonPropertyGet(
  /**
   * The key of the app, as defined in its descriptor.
   */
  addonKey: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  headers?: hasuraSdk.JSONValue,
): Promise<EntityProperty> {
  const result = await api.rest.addonPropertiesResourceGetAddonPropertyGet({
    addonKey: addonKey,
    propertyKey: propertyKey,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Set app property
 * @request PUT :/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}
 */
export async function putRestAddonPropertiesResourcePutAddonPropertyPut(
  /**
   * The key of the app, as defined in its descriptor.
   */
  addonKey: string,
  /**
   * The key of the property.
   */
  propertyKey: string,
  /** Request body */
  data: any,
  headers?: hasuraSdk.JSONValue,
): Promise<OperationMessage> {
  const result = await api.rest.addonPropertiesResourcePutAddonPropertyPut({
    addonKey: addonKey,
    propertyKey: propertyKey,
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Remove modules
 * @request DELETE :/rest/atlassian-connect/1/app/module/dynamic
 * @allowrelaxedtypes
 */
export async function deleteRestDynamicModulesResourceRemoveModulesDelete(
  query: {
    /**
* The key of the module to remove. To include multiple module keys, provide multiple copies of this parameter.
For example, `moduleKey=dynamic-attachment-entity-property&moduleKey=dynamic-select-field`.
Nonexistent keys are ignored.
*/
    moduleKey?: string[];
  },
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.dynamicModulesResourceRemoveModulesDelete({
    query: query,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Get modules
 * @request GET :/rest/atlassian-connect/1/app/module/dynamic
 * @allowrelaxedtypes
 * @readonly
 */
export async function getRestDynamicModulesResourceGetModulesGet(
  headers?: hasuraSdk.JSONValue,
): Promise<ConnectModules> {
  const result = await api.rest.dynamicModulesResourceGetModulesGet({
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}

/**
 * Register modules
 * @request POST :/rest/atlassian-connect/1/app/module/dynamic
 * @allowrelaxedtypes
 */
export async function postRestDynamicModulesResourceRegisterModulesPost(
  /** Request body */
  data: ConnectModules,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.dynamicModulesResourceRegisterModulesPost({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.error) {
    throw result.error;
  } else {
    return new hasuraSdk.JSONValue(result.data);
  }
}

/**
 * Bulk update custom field value
 * @request PUT :/rest/atlassian-connect/1/migration/field
 * @allowrelaxedtypes
 */
export async function putRestAppIssueFieldValueUpdateResourceUpdateIssueFieldsPut(
  /** Request body */
  data: ConnectCustomFieldValues,
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result =
    await api.rest.appIssueFieldValueUpdateResourceUpdateIssueFieldsPut({
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    });
  if (result.data) {
    return new hasuraSdk.JSONValue(result.data);
  } else {
    throw result.error;
  }
}

/**
 * Bulk update entity properties
 * @request PUT :/rest/atlassian-connect/1/migration/properties/{entityType}
 * @allowrelaxedtypes
 */
export async function putRestMigrationResourceUpdateEntityPropertiesValuePut(
  /**
   * The type indicating the object that contains the entity properties.
   */
  entityType:
    | "IssueProperty"
    | "CommentProperty"
    | "DashboardItemProperty"
    | "IssueTypeProperty"
    | "ProjectProperty"
    | "UserProperty"
    | "WorklogProperty"
    | "BoardProperty"
    | "SprintProperty",
  /** Request body */
  data: EntityPropertyDetails[],
  headers?: hasuraSdk.JSONValue,
): Promise<hasuraSdk.JSONValue> {
  const result = await api.rest.migrationResourceUpdateEntityPropertiesValuePut(
    {
      entityType: entityType,
      data: data,
      params: {
        headers: (headers?.value as Record<string, string>) ?? undefined,
      },
    },
  );
  return new hasuraSdk.JSONValue(result);
}

/**
 * Get workflow transition rule configurations
 * @request POST :/rest/atlassian-connect/1/migration/workflow/rule/search
 */
export async function postRestMigrationResourceWorkflowRuleSearchPost(
  /** Request body */
  data: WorkflowRulesSearch,
  headers?: hasuraSdk.JSONValue,
): Promise<WorkflowRulesSearchDetails> {
  const result = await api.rest.migrationResourceWorkflowRuleSearchPost({
    data: data,
    params: {
      headers: (headers?.value as Record<string, string>) ?? undefined,
    },
  });
  if (result.data) {
    return result.data;
  } else {
    throw result.error;
  }
}
